<!-- HTML header for doxygen -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libMesh: libMesh::MeshCommunication Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="../styles.css" rel="stylesheet" type="text/css" />
<link href="doxygen_stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <nav id="fixedbar">
    <ul id="fixednav">
      <li><a href="../index.html">Home</a></li>
      <li><a href="../support.html">About Us</a></li>
      <li><a href="../publications.html">Publications</a></li>
      <li><a href="../developers.html">Developers</a></li>
      <li><a href="../installation.html">Installation</a></li>
      <li><a href="../examples.html">Examples</a></li>
      <li><a href="../doxygen/index.html">Documentation</a></li>
    </ul>
  </nav>
  <div id="w">
    <header id="logo"><a href="index.html"><span id="logobg">SomeWebsiteLogo</span></a></header>
    <nav id="navigation">
      <ul>
        <li><a href="../index.html">Home</a></li>
        <li><a href="../support.html">About Us</a></li>
        <li><a href="../publications.html">Publications</a></li>
        <li><a href="../developers.html">Developers</a></li>
        <li><a href="../installation.html">Installation</a></li>
        <li><a href="../examples.html">Examples</a></li>
        <li><a href="../doxygen/index.html">Documentation</a></li>
      </ul>
    </nav>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- <\!--BEGIN TITLEAREA-\-> -->
<!-- <div id="titlearea"> -->
<!-- <table cellspacing="0" cellpadding="0"> -->
<!--  <tbody> -->
<!--  <tr style="height: 56px;"> -->
<!--   <\!--BEGIN PROJECT_LOGO-\-> -->
<!--   <td id="projectlogo"><img alt="Logo" src=""/></td> -->
<!--   <\!--END PROJECT_LOGO-\-> -->
<!--   <\!--BEGIN PROJECT_NAME-\-> -->
<!--   <td style="padding-left: 0.5em;"> -->
<!--    <div id="projectname">libMesh -->
<!--    <\!--BEGIN PROJECT_NUMBER-\->&#160;<span id="projectnumber"></span><\!--END PROJECT_NUMBER-\-> -->
<!--    </div> -->
<!--    <\!--BEGIN PROJECT_BRIEF-\-><div id="projectbrief"></div><\!--END PROJECT_BRIEF-\-> -->
<!--   </td> -->
<!--   <\!--END PROJECT_NAME-\-> -->
<!--   <\!--BEGIN !PROJECT_NAME-\-> -->
<!--    <\!--BEGIN PROJECT_BRIEF-\-> -->
<!--     <td style="padding-left: 0.5em;"> -->
<!--     <div id="projectbrief"></div> -->
<!--     </td> -->
<!--    <\!--END PROJECT_BRIEF-\-> -->
<!--   <\!--END !PROJECT_NAME-\-> -->
<!--   <\!--BEGIN DISABLE_INDEX-\-> -->
<!--    <\!--BEGIN SEARCHENGINE-\-> -->
<!--    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td> -->
<!--    <\!--END SEARCHENGINE-\-> -->
<!--   <\!--END DISABLE_INDEX-\-> -->
<!--  </tr> -->
<!--  </tbody> -->
<!-- </table> -->
<!-- </div> -->
<!-- <\!--END TITLEAREA-\-> -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibMesh.html">libMesh</a></li><li class="navelem"><a class="el" href="classlibMesh_1_1MeshCommunication.html">MeshCommunication</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classlibMesh_1_1MeshCommunication-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libMesh::MeshCommunication Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="mesh__communication_8h_source.html">mesh_communication.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af7a9fe6fa2f8d820a0772e6ce73f0990"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#af7a9fe6fa2f8d820a0772e6ce73f0990">MeshCommunication</a> ()</td></tr>
<tr class="separator:af7a9fe6fa2f8d820a0772e6ce73f0990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e700d5cae2559747f64283dfc2ad81c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#a7e700d5cae2559747f64283dfc2ad81c">~MeshCommunication</a> ()</td></tr>
<tr class="separator:a7e700d5cae2559747f64283dfc2ad81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227f46dad6159d846d8e6c90a9cfe3cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#a227f46dad6159d846d8e6c90a9cfe3cb">clear</a> ()</td></tr>
<tr class="separator:a227f46dad6159d846d8e6c90a9cfe3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd58bfae74fde1354254205047b36e59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#afd58bfae74fde1354254205047b36e59">broadcast</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;) const</td></tr>
<tr class="separator:afd58bfae74fde1354254205047b36e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df56ecdd0e08323cdcfcd0740572188"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#a6df56ecdd0e08323cdcfcd0740572188">redistribute</a> (<a class="el" href="classlibMesh_1_1DistributedMesh.html">DistributedMesh</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, bool newly_coarsened_only=false) const</td></tr>
<tr class="separator:a6df56ecdd0e08323cdcfcd0740572188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde0fa5a9755f487ce193aeca053412e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#acde0fa5a9755f487ce193aeca053412e">gather_neighboring_elements</a> (<a class="el" href="classlibMesh_1_1DistributedMesh.html">DistributedMesh</a> &amp;) const</td></tr>
<tr class="separator:acde0fa5a9755f487ce193aeca053412e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc471121e143376e28683be08230a53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#a8fc471121e143376e28683be08230a53">send_coarse_ghosts</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;) const</td></tr>
<tr class="separator:a8fc471121e143376e28683be08230a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4415895c15cce32bdad9b3b23c0d119a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#a4415895c15cce32bdad9b3b23c0d119a">gather</a> (const <a class="el" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> root_id, <a class="el" href="classlibMesh_1_1DistributedMesh.html">DistributedMesh</a> &amp;) const</td></tr>
<tr class="separator:a4415895c15cce32bdad9b3b23c0d119a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1cb1464c91b52c806ef3cd3d7ac639"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#abe1cb1464c91b52c806ef3cd3d7ac639">allgather</a> (<a class="el" href="classlibMesh_1_1DistributedMesh.html">DistributedMesh</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>) const</td></tr>
<tr class="separator:abe1cb1464c91b52c806ef3cd3d7ac639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c5c1853317c91b7ac49cf06f16cbb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#a24c5c1853317c91b7ac49cf06f16cbb3">delete_remote_elements</a> (<a class="el" href="classlibMesh_1_1DistributedMesh.html">DistributedMesh</a> &amp;, const std::set&lt; <a class="el" href="classlibMesh_1_1Elem.html">Elem</a> *&gt; &amp;) const</td></tr>
<tr class="separator:a24c5c1853317c91b7ac49cf06f16cbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357ec2a6b99b8a335b805bec55b0c45f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#a357ec2a6b99b8a335b805bec55b0c45f">assign_global_indices</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;) const</td></tr>
<tr class="separator:a357ec2a6b99b8a335b805bec55b0c45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2139c13a54f24e2108b7b233d3c7ba80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#a2139c13a54f24e2108b7b233d3c7ba80">check_for_duplicate_global_indices</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;) const</td></tr>
<tr class="separator:a2139c13a54f24e2108b7b233d3c7ba80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562715b6bb00fc8e3d6c54cb0ffad446"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a562715b6bb00fc8e3d6c54cb0ffad446"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#a562715b6bb00fc8e3d6c54cb0ffad446">find_local_indices</a> (const <a class="el" href="classlibMesh_1_1BoundingBox.html">libMesh::BoundingBox</a> &amp;, const ForwardIterator &amp;, const ForwardIterator &amp;, std::unordered_map&lt; <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a>, <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> &gt; &amp;) const</td></tr>
<tr class="separator:a562715b6bb00fc8e3d6c54cb0ffad446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c133d4fec5cd9cddcdd3033d4ca600"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a64c133d4fec5cd9cddcdd3033d4ca600"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#a64c133d4fec5cd9cddcdd3033d4ca600">find_global_indices</a> (const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Parallel::Communicator</a> &amp;communicator, const <a class="el" href="classlibMesh_1_1BoundingBox.html">libMesh::BoundingBox</a> &amp;, const ForwardIterator &amp;, const ForwardIterator &amp;, std::vector&lt; <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> &gt; &amp;) const</td></tr>
<tr class="separator:a64c133d4fec5cd9cddcdd3033d4ca600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737da6ee13b781ac7aef37851a99af58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#a737da6ee13b781ac7aef37851a99af58">make_elems_parallel_consistent</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;)</td></tr>
<tr class="separator:a737da6ee13b781ac7aef37851a99af58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb166973b14e95ae36c14a39105907a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#a9eb166973b14e95ae36c14a39105907a">make_p_levels_parallel_consistent</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;)</td></tr>
<tr class="separator:a9eb166973b14e95ae36c14a39105907a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0eae4e562c489db701776c3970e772b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#ab0eae4e562c489db701776c3970e772b">make_node_ids_parallel_consistent</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;)</td></tr>
<tr class="separator:ab0eae4e562c489db701776c3970e772b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e83bbe1c114c9de7be87927f7db9e85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#a0e83bbe1c114c9de7be87927f7db9e85">make_node_unique_ids_parallel_consistent</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;)</td></tr>
<tr class="separator:a0e83bbe1c114c9de7be87927f7db9e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67880939a7d98e9cb3e7a6425a4d7ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#ab67880939a7d98e9cb3e7a6425a4d7ec">make_node_proc_ids_parallel_consistent</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;)</td></tr>
<tr class="separator:ab67880939a7d98e9cb3e7a6425a4d7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09a612b52ccb019c89165d3bfce5773"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#ae09a612b52ccb019c89165d3bfce5773">make_new_node_proc_ids_parallel_consistent</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;)</td></tr>
<tr class="separator:ae09a612b52ccb019c89165d3bfce5773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76dd6bc5f023e8836591ca42a9caa94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#ac76dd6bc5f023e8836591ca42a9caa94">make_nodes_parallel_consistent</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;)</td></tr>
<tr class="separator:ac76dd6bc5f023e8836591ca42a9caa94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa47da82381f82ded5e3f0bedb0dbd5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1MeshCommunication.html#afa47da82381f82ded5e3f0bedb0dbd5b">make_new_nodes_parallel_consistent</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;)</td></tr>
<tr class="separator:afa47da82381f82ded5e3f0bedb0dbd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the <code><a class="el" href="classlibMesh_1_1MeshCommunication.html">MeshCommunication</a></code> class. It handles all the details of communicating mesh information from one processor to another. All parallelization of the <code><a class="el" href="classlibMesh_1_1Mesh.html" title="Manages a collection of Nodes and Elems. ">Mesh</a></code> data structures is done via this class.</p>
<dl class="section author"><dt>Author</dt><dd>Benjamin S. Kirk </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2003 </dd></dl>

<p class="definition">Definition at line <a class="el" href="mesh__communication_8h_source.html#l00050">50</a> of file <a class="el" href="mesh__communication_8h_source.html">mesh_communication.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af7a9fe6fa2f8d820a0772e6ce73f0990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a9fe6fa2f8d820a0772e6ce73f0990">&#9670;&nbsp;</a></span>MeshCommunication()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::MeshCommunication::MeshCommunication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. </p>

<p class="definition">Definition at line <a class="el" href="mesh__communication_8h_source.html#l00057">57</a> of file <a class="el" href="mesh__communication_8h_source.html">mesh_communication.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;{}</div></div><!-- fragment -->
</div>
</div>
<a id="a7e700d5cae2559747f64283dfc2ad81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e700d5cae2559747f64283dfc2ad81c">&#9670;&nbsp;</a></span>~MeshCommunication()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::MeshCommunication::~MeshCommunication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

<p class="definition">Definition at line <a class="el" href="mesh__communication_8h_source.html#l00062">62</a> of file <a class="el" href="mesh__communication_8h_source.html">mesh_communication.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;{}</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abe1cb1464c91b52c806ef3cd3d7ac639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1cb1464c91b52c806ef3cd3d7ac639">&#9670;&nbsp;</a></span>allgather()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::allgather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1DistributedMesh.html">DistributedMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method takes an input <code><a class="el" href="classlibMesh_1_1DistributedMesh.html" title="Mesh data structure which is distributed across all processors. ">DistributedMesh</a></code> which may be distributed among all the processors. Each processor then sends its local nodes and elements to the other processors. The end result is that a previously distributed <code><a class="el" href="classlibMesh_1_1DistributedMesh.html" title="Mesh data structure which is distributed across all processors. ">DistributedMesh</a></code> will be serialized on each processor. Since this method is collective it must be called by all processors. </p>

<p class="definition">Definition at line <a class="el" href="mesh__communication_8h_source.html#l00135">135</a> of file <a class="el" href="mesh__communication_8h_source.html">mesh_communication.h</a>.</p>

<p class="reference">References <a class="el" href="mesh__communication_8C_source.html#l01156">gather()</a>, <a class="el" href="dof__object_8h_source.html#l00358">libMesh::DofObject::invalid_processor_id</a>, and <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>.</p>

<p class="reference">Referenced by <a class="el" href="distributed__mesh_8C_source.html#l01418">libMesh::DistributedMesh::allgather()</a>.</p>
<div class="fragment"><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;  { <a class="code" href="classlibMesh_1_1MeshCommunication.html#a4415895c15cce32bdad9b3b23c0d119a">MeshCommunication::gather</a>(<a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>, <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>); }</div><div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_aa65deab833c8b1802790cd43ab1b6ee4"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">libMesh::DofObject::invalid_processor_id</a></div><div class="ttdeci">static const processor_id_type invalid_processor_id</div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00358">dof_object.h:358</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshCommunication_html_a4415895c15cce32bdad9b3b23c0d119a"><div class="ttname"><a href="classlibMesh_1_1MeshCommunication.html#a4415895c15cce32bdad9b3b23c0d119a">libMesh::MeshCommunication::gather</a></div><div class="ttdeci">void gather(const processor_id_type root_id, DistributedMesh &amp;) const</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01156">mesh_communication.C:1156</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a357ec2a6b99b8a335b805bec55b0c45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357ec2a6b99b8a335b805bec55b0c45f">&#9670;&nbsp;</a></span>assign_global_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::assign_global_indices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method assigns globally unique, partition-agnostic indices to the nodes and elements in the mesh. The approach is to compute the <a class="el" href="namespaceHilbert.html">Hilbert</a> space-filling curve key and use its value to assign an index in [0,N_global). Since the <a class="el" href="namespaceHilbert.html">Hilbert</a> key is unique for each spatial location, two objects occupying the same location will be assigned the same global id. Thus, this method can also be useful for identifying duplicate nodes which may occur during parallel refinement. </p>

<p class="definition">Definition at line <a class="el" href="mesh__communication__global__indices_8C_source.html#l00168">168</a> of file <a class="el" href="mesh__communication__global__indices_8C_source.html">mesh_communication_global_indices.C</a>.</p>

<p class="reference">References <a class="el" href="parallel__sort_8C_source.html#l00260">libMesh::Parallel::Sort&lt; KeyType, IdxType &gt;::bin()</a>, <a class="el" href="parallel__object_8h_source.html#l00089">libMesh::ParallelObject::comm()</a>, <a class="el" href="mesh__tools_8C_source.html#l00411">libMesh::MeshTools::create_nodal_bounding_box()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a5173d38b4db709085b1cde698137d042">libMesh::MeshBase::element_ptr_range()</a>, <a class="el" href="variant__filter__iterator_8h_source.html#l00343">end</a>, <a class="el" href="mesh__generation_8C_source.html#l00070">libMesh::MeshTools::Generation::Private::idx()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a5b67c2aa94e76310a6db3470cce8ef11">libMesh::MeshBase::local_elements_begin()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#ab8bd839216a1ef9c0912d523b68ae136">libMesh::MeshBase::local_elements_end()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a7a87dbe56aaa89961e03d60a25a36e8b">libMesh::MeshBase::local_nodes_begin()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#ad0daaecd9c183194a99609db6507198c">libMesh::MeshBase::local_nodes_end()</a>, <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a190e556d3be87f5ccd8d4fc98d1779d3">libMesh::MeshBase::n_elem()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a5b76b109bc6bd087c981774897aa6167">libMesh::MeshBase::n_nodes()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a36c73b238ec8e3f2b2c2a7abd167206a">libMesh::MeshBase::node_ptr_range()</a>, <a class="el" href="threads__none_8h_source.html#l00073">libMesh::Threads::parallel_for()</a>, <a class="el" href="parallel__sync_8h_source.html#l00472">libMesh::Parallel::pull_parallel_vector_data()</a>, and <a class="el" href="parallel__sort_8C_source.html#l00060">libMesh::Parallel::Sort&lt; KeyType, IdxType &gt;::sort()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mesh__tools_8C_source.html#l02424">libMesh::MeshTools::Private::globally_renumber_nodes_and_elements()</a>.</p>
<div class="fragment"><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;{</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;  LOG_SCOPE (<span class="stringliteral">&quot;assign_global_indices()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;  <span class="comment">// This method determines partition-agnostic global indices</span></div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;  <span class="comment">// for nodes and elements.</span></div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;  <span class="comment">// Algorithm:</span></div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  <span class="comment">// (1) compute the Hilbert key for each local node/element</span></div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;  <span class="comment">// (2) perform a parallel sort of the Hilbert key</span></div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;  <span class="comment">// (3) get the min/max value on each processor</span></div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;  <span class="comment">// (4) determine the position in the global ranking for</span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;  <span class="comment">//     each local object</span></div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;  <span class="keyword">const</span> <a class="code" href="classlibMesh_1_1Parallel_1_1Communicator.html">Parallel::Communicator</a> &amp; <a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a> (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">comm</a>());</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;  <span class="comment">// Global bounding box.  We choose the nodal bounding box for</span></div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;  <span class="comment">// backwards compatibility; the element bounding box may be looser</span></div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;  <span class="comment">// on curved elements.</span></div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;  <a class="code" href="classlibMesh_1_1BoundingBox.html">BoundingBox</a> bbox =</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    <a class="code" href="namespacelibMesh_1_1MeshTools.html#a9cc1d9577393d91d5df11f4034e1264b">MeshTools::create_nodal_bounding_box</a> (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;  <span class="comment">//-------------------------------------------------------------</span></div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;  <span class="comment">// (1) compute Hilbert keys</span></div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;  std::vector&lt;Parallel::DofObjectKey&gt;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    node_keys, elem_keys;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;  {</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    <span class="comment">// Nodes first</span></div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    {</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;      <a class="code" href="classlibMesh_1_1StoredRange.html">ConstNodeRange</a> nr (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a7a87dbe56aaa89961e03d60a25a36e8b">local_nodes_begin</a>(),</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;                         <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#ad0daaecd9c183194a99609db6507198c">local_nodes_end</a>());</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;      node_keys.resize (nr.size());</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;      <a class="code" href="namespacelibMesh_1_1Threads.html#a97dcd01ff677ad850c3c9f6d8380dba2">Threads::parallel_for</a> (nr, ComputeHilbertKeys (bbox, node_keys));</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;      <span class="comment">// // It&#39;s O(N^2) to check that these keys don&#39;t duplicate before the</span></div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;      <span class="comment">// // sort...</span></div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;      <span class="comment">// MeshBase::const_node_iterator nodei = mesh.local_nodes_begin();</span></div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;      <span class="comment">// for (std::size_t i = 0; i != node_keys.size(); ++i, ++nodei)</span></div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;      <span class="comment">//   {</span></div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;      <span class="comment">//     MeshBase::const_node_iterator nodej = mesh.local_nodes_begin();</span></div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;      <span class="comment">//     for (std::size_t j = 0; j != i; ++j, ++nodej)</span></div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;      <span class="comment">//       {</span></div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;      <span class="comment">//         if (node_keys[i] == node_keys[j])</span></div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;      <span class="comment">//           {</span></div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;      <span class="comment">//             CFixBitVec icoords[3], jcoords[3];</span></div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;      <span class="comment">//             get_hilbert_coords(**nodej, bbox, jcoords);</span></div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;      <span class="comment">//             libMesh::err &lt;&lt;</span></div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;      <span class="comment">//               &quot;node &quot; &lt;&lt; (*nodej)-&gt;id() &lt;&lt; &quot;, &quot; &lt;&lt;</span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;      <span class="comment">//               *(Point *)(*nodej) &lt;&lt; &quot; has HilbertIndices &quot; &lt;&lt;</span></div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;      <span class="comment">//               node_keys[j] &lt;&lt; std::endl;</span></div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;      <span class="comment">//             get_hilbert_coords(**nodei, bbox, icoords);</span></div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;      <span class="comment">//             libMesh::err &lt;&lt;</span></div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;      <span class="comment">//               &quot;node &quot; &lt;&lt; (*nodei)-&gt;id() &lt;&lt; &quot;, &quot; &lt;&lt;</span></div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;      <span class="comment">//               *(Point *)(*nodei) &lt;&lt; &quot; has HilbertIndices &quot; &lt;&lt;</span></div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;      <span class="comment">//               node_keys[i] &lt;&lt; std::endl;</span></div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;      <span class="comment">//             libmesh_error_msg(&quot;Error: nodes with duplicate Hilbert keys!&quot;);</span></div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;      <span class="comment">//           }</span></div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;      <span class="comment">//       }</span></div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;      <span class="comment">//   }</span></div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    }</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    <span class="comment">// Elements next</span></div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    {</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;      <a class="code" href="classlibMesh_1_1StoredRange.html">ConstElemRange</a> er (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a5b67c2aa94e76310a6db3470cce8ef11">local_elements_begin</a>(),</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;                         <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#ab8bd839216a1ef9c0912d523b68ae136">local_elements_end</a>());</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;      elem_keys.resize (er.size());</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;      <a class="code" href="namespacelibMesh_1_1Threads.html#a97dcd01ff677ad850c3c9f6d8380dba2">Threads::parallel_for</a> (er, ComputeHilbertKeys (bbox, elem_keys));</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;      <span class="comment">// // For elements, the keys can be (and in the case of TRI, are</span></div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;      <span class="comment">// // expected to be) duplicates, but only if the elements are at</span></div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;      <span class="comment">// // different levels</span></div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;      <span class="comment">// MeshBase::const_element_iterator elemi = mesh.local_elements_begin();</span></div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;      <span class="comment">// for (std::size_t i = 0; i != elem_keys.size(); ++i, ++elemi)</span></div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;      <span class="comment">//   {</span></div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;      <span class="comment">//     MeshBase::const_element_iterator elemj = mesh.local_elements_begin();</span></div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;      <span class="comment">//     for (std::size_t j = 0; j != i; ++j, ++elemj)</span></div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;      <span class="comment">//       {</span></div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;      <span class="comment">//         if ((elem_keys[i] == elem_keys[j]) &amp;&amp;</span></div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;      <span class="comment">//             ((*elemi)-&gt;level() == (*elemj)-&gt;level()))</span></div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;      <span class="comment">//           {</span></div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;      <span class="comment">//             libMesh::err &lt;&lt;</span></div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;      <span class="comment">//               &quot;level &quot; &lt;&lt; (*elemj)-&gt;level() &lt;&lt; &quot; elem\n&quot; &lt;&lt;</span></div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;      <span class="comment">//               (**elemj) &lt;&lt; &quot; centroid &quot; &lt;&lt;</span></div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;      <span class="comment">//               (*elemj)-&gt;centroid() &lt;&lt; &quot; has HilbertIndices &quot; &lt;&lt;</span></div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;      <span class="comment">//               elem_keys[j] &lt;&lt; &quot; or &quot; &lt;&lt;</span></div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;      <span class="comment">//               get_dofobject_key((*elemj), bbox) &lt;&lt;</span></div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;      <span class="comment">//               std::endl;</span></div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;      <span class="comment">//             libMesh::err &lt;&lt;</span></div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;      <span class="comment">//               &quot;level &quot; &lt;&lt; (*elemi)-&gt;level() &lt;&lt; &quot; elem\n&quot; &lt;&lt;</span></div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;      <span class="comment">//               (**elemi) &lt;&lt; &quot; centroid &quot; &lt;&lt;</span></div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;      <span class="comment">//               (*elemi)-&gt;centroid() &lt;&lt; &quot; has HilbertIndices &quot; &lt;&lt;</span></div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;      <span class="comment">//               elem_keys[i] &lt;&lt; &quot; or &quot; &lt;&lt;</span></div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;      <span class="comment">//               get_dofobject_key((*elemi), bbox) &lt;&lt;</span></div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;      <span class="comment">//               std::endl;</span></div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;      <span class="comment">//             libmesh_error_msg(&quot;Error: level &quot; &lt;&lt; (*elemi)-&gt;level() &lt;&lt; &quot; elements with duplicate Hilbert keys!&quot;);</span></div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;      <span class="comment">//           }</span></div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;      <span class="comment">//       }</span></div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;      <span class="comment">//   }</span></div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    }</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;  } <span class="comment">// done computing Hilbert keys</span></div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;  <span class="comment">//-------------------------------------------------------------</span></div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;  <span class="comment">// (2) parallel sort the Hilbert keys</span></div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;  <a class="code" href="classlibMesh_1_1Parallel_1_1Sort.html">Parallel::Sort&lt;Parallel::DofObjectKey&gt;</a> node_sorter (<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>,</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                                                      node_keys);</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;  node_sorter.sort(); <span class="comment">/* done with node_keys */</span> <span class="comment">//node_keys.clear();</span></div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;  <span class="keyword">const</span> std::vector&lt;Parallel::DofObjectKey&gt; &amp; my_node_bin =</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;    node_sorter.bin();</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;  <a class="code" href="classlibMesh_1_1Parallel_1_1Sort.html">Parallel::Sort&lt;Parallel::DofObjectKey&gt;</a> elem_sorter (<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>,</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;                                                      elem_keys);</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;  elem_sorter.sort(); <span class="comment">/* done with elem_keys */</span> <span class="comment">//elem_keys.clear();</span></div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;  <span class="keyword">const</span> std::vector&lt;Parallel::DofObjectKey&gt; &amp; my_elem_bin =</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    elem_sorter.bin();</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;  <span class="comment">//-------------------------------------------------------------</span></div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;  <span class="comment">// (3) get the max value on each processor</span></div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;  std::vector&lt;Parallel::DofObjectKey&gt;</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    node_upper_bounds(<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.size()),</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    elem_upper_bounds(<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.size());</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;  { <span class="comment">// limit scope of temporaries</span></div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    std::vector&lt;Parallel::DofObjectKey&gt; recvbuf(2*<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.size());</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    std::vector&lt;unsigned short int&gt; <span class="comment">/* do not use a vector of bools here since it is not always so! */</span></div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;      empty_nodes (<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.size()),</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;      empty_elem  (<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.size());</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    std::vector&lt;Parallel::DofObjectKey&gt; my_max(2);</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    <a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.allgather (static_cast&lt;unsigned short int&gt;(my_node_bin.empty()), empty_nodes);</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    <a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.allgather (static_cast&lt;unsigned short int&gt;(my_elem_bin.empty()),  empty_elem);</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;    <span class="keywordflow">if</span> (!my_node_bin.empty()) my_max[0] = my_node_bin.back();</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    <span class="keywordflow">if</span> (!my_elem_bin.empty()) my_max[1] = my_elem_bin.back();</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;    <a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.allgather (my_max, <span class="comment">/* identical_buffer_sizes = */</span> <span class="keyword">true</span>);</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    <span class="comment">// Be careful here.  The *_upper_bounds will be used to find the processor</span></div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    <span class="comment">// a given object belongs to.  So, if a processor contains no objects (possible!)</span></div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;    <span class="comment">// then copy the bound from the lower processor id.</span></div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;    <span class="keywordflow">for</span> (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> p=0; p&lt;<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.size(); p++)</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;      {</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;        node_upper_bounds[p] = my_max[2*p+0];</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;        elem_upper_bounds[p] = my_max[2*p+1];</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;        <span class="keywordflow">if</span> (p &gt; 0) <span class="comment">// default hilbert index value is the OK upper bound for processor 0.</span></div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;          {</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;            <span class="keywordflow">if</span> (empty_nodes[p]) node_upper_bounds[p] = node_upper_bounds[p-1];</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;            <span class="keywordflow">if</span> (empty_elem[p])  elem_upper_bounds[p] = elem_upper_bounds[p-1];</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;          }</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;      }</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;  }</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;  <span class="comment">//-------------------------------------------------------------</span></div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;  <span class="comment">// (4) determine the position in the global ranking for</span></div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;  <span class="comment">//     each local object</span></div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;  {</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    <span class="comment">//----------------------------------------------</span></div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    <span class="comment">// Nodes first -- all nodes, not just local ones</span></div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    {</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;      <span class="comment">// Request sets to send to each processor</span></div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;      std::map&lt;processor_id_type, std::vector&lt;Parallel::DofObjectKey&gt;&gt;</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;        requested_ids;</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;      <span class="comment">// Results to gather from each processor - kept in a map so we</span></div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;      <span class="comment">// do only one loop over nodes after all receives are done.</span></div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;      std::map&lt;dof_id_type, std::vector&lt;dof_id_type&gt;&gt;</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;        filled_request;</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;      <span class="comment">// build up list of requests</span></div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; node : <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a36c73b238ec8e3f2b2c2a7abd167206a">node_ptr_range</a>())</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;        {</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;          libmesh_assert(node);</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;          <span class="keyword">const</span> <a class="code" href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">Parallel::DofObjectKey</a> hi =</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;            get_dofobject_key (node, bbox);</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;          <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> pid =</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;            cast_int&lt;processor_id_type&gt;</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;            (std::distance (node_upper_bounds.begin(),</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;                            std::lower_bound(node_upper_bounds.begin(),</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;                                             node_upper_bounds.end(),</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;                                             hi)));</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;          libmesh_assert_less (pid, <a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.size());</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;          requested_ids[pid].push_back(hi);</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;        }</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;      <span class="comment">// The number of objects in my_node_bin on each processor</span></div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;      std::vector&lt;dof_id_type&gt; node_bin_sizes(<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.size());</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;      <a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.allgather (static_cast&lt;dof_id_type&gt;(my_node_bin.size()), node_bin_sizes);</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;      <span class="comment">// The offset of my first global index</span></div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;      <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> my_offset = 0;</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;      <span class="keywordflow">for</span> (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> pid=0; pid&lt;<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.rank(); pid++)</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;        my_offset += node_bin_sizes[pid];</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;      <span class="keyword">auto</span> gather_functor =</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;        [</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;<span class="preprocessor">#ifndef NDEBUG</span></div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;         &amp; node_upper_bounds,</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;         &amp; <a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>,</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;         &amp; my_node_bin,</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;         my_offset</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        ]</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a>,</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;         <span class="keyword">const</span> std::vector&lt;Parallel::DofObjectKey&gt; &amp; keys,</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;         std::vector&lt;dof_id_type&gt; &amp; global_ids)</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;        {</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;          <span class="comment">// Fill the requests</span></div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;          <span class="keyword">const</span> std::size_t keys_size = keys.size();</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;          global_ids.reserve(keys_size);</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;          <span class="keywordflow">for</span> (std::size_t <a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a>=0; <a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a> != keys_size; <a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a>++)</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;            {</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;              <span class="keyword">const</span> <a class="code" href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">Parallel::DofObjectKey</a> &amp; hi = keys[<a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a>];</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;              libmesh_assert_less_equal (hi, node_upper_bounds[<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.rank()]);</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;              <span class="comment">// find the requested index in my node bin</span></div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;              std::vector&lt;Parallel::DofObjectKey&gt;::const_iterator pos =</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;                std::lower_bound (my_node_bin.begin(), my_node_bin.end(), hi);</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;              libmesh_assert (pos != my_node_bin.end());</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;              libmesh_assert_equal_to (*pos, hi);</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;              <span class="comment">// Finally, assign the global index based off the position of the index</span></div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;              <span class="comment">// in my array, properly offset.</span></div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;              global_ids.push_back(cast_int&lt;dof_id_type&gt;(std::distance(my_node_bin.begin(), pos) + my_offset));</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;            }</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;        };</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;      <span class="keyword">auto</span> action_functor =</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;        [&amp;filled_request]</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;        (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> pid,</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;         <span class="keyword">const</span> std::vector&lt;Parallel::DofObjectKey&gt; &amp;,</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;         <span class="keyword">const</span> std::vector&lt;dof_id_type&gt; &amp; global_ids)</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;        {</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;          filled_request[pid] = global_ids;</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;        };</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;      <span class="comment">// Trade requests with other processors</span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;      <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> * ex = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;      <a class="code" href="namespacelibMesh_1_1Parallel.html#a21797734483c801c09fa26822455d989">Parallel::pull_parallel_vector_data</a></div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;        (<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>, requested_ids, gather_functor, action_functor, ex);</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;      <span class="comment">// We now have all the filled requests, so we can loop through our</span></div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;      <span class="comment">// nodes once and assign the global index to each one.</span></div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;      {</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;        std::map&lt;dof_id_type, std::vector&lt;dof_id_type&gt;::const_iterator&gt;</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;          next_obj_on_proc;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; p : filled_request)</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;          next_obj_on_proc[p.first] = p.second.begin();</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; node : <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a36c73b238ec8e3f2b2c2a7abd167206a">node_ptr_range</a>())</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;          {</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;            libmesh_assert(node);</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;            <span class="keyword">const</span> <a class="code" href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">Parallel::DofObjectKey</a> hi =</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;              get_dofobject_key (node, bbox);</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;            <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> pid =</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;              cast_int&lt;processor_id_type&gt;</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;              (std::distance (node_upper_bounds.begin(),</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;                              std::lower_bound(node_upper_bounds.begin(),</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;                                               node_upper_bounds.end(),</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;                                               hi)));</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;            libmesh_assert_less (pid, <a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.size());</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;            libmesh_assert (next_obj_on_proc[pid] != filled_request[pid].<a class="code" href="variant__filter__iterator_8h.html#a785f0bd261d7bd1918b031c5133da2b9">end</a>());</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;            <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> global_index = *next_obj_on_proc[pid];</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;            libmesh_assert_less (global_index, <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a5b76b109bc6bd087c981774897aa6167">n_nodes</a>());</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;            node-&gt;set_id() = global_index;</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;            ++next_obj_on_proc[pid];</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;          }</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;      }</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;    }</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    <span class="comment">//---------------------------------------------------</span></div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    <span class="comment">// elements next -- all elements, not just local ones</span></div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;    {</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;      <span class="comment">// Request sets to send to each processor</span></div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;      std::map&lt;processor_id_type, std::vector&lt;Parallel::DofObjectKey&gt;&gt;</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;        requested_ids;</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;      <span class="comment">// Results to gather from each processor - kept in a map so we</span></div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;      <span class="comment">// do only one loop over elements after all receives are done.</span></div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;      std::map&lt;dof_id_type, std::vector&lt;dof_id_type&gt;&gt;</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;        filled_request;</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; elem : <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a5173d38b4db709085b1cde698137d042">element_ptr_range</a>())</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;        {</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;          libmesh_assert(elem);</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;          <span class="keyword">const</span> <a class="code" href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">Parallel::DofObjectKey</a> hi =</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;            get_dofobject_key (elem, bbox);</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;          <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> pid =</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;            cast_int&lt;processor_id_type&gt;</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;            (std::distance (elem_upper_bounds.begin(),</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;                            std::lower_bound(elem_upper_bounds.begin(),</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;                                             elem_upper_bounds.end(),</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;                                             hi)));</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;          libmesh_assert_less (pid, <a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.size());</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;          requested_ids[pid].push_back(hi);</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;        }</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;      <span class="comment">// The number of objects in my_elem_bin on each processor</span></div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;      std::vector&lt;dof_id_type&gt; elem_bin_sizes(<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.size());</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;      <a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.allgather (static_cast&lt;dof_id_type&gt;(my_elem_bin.size()), elem_bin_sizes);</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;      <span class="comment">// The offset of my first global index</span></div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;      <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> my_offset = 0;</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;      <span class="keywordflow">for</span> (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> pid=0; pid&lt;<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.rank(); pid++)</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;        my_offset += elem_bin_sizes[pid];</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;      <span class="keyword">auto</span> gather_functor =</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;        [</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;<span class="preprocessor">#ifndef NDEBUG</span></div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;         &amp; elem_upper_bounds,</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;         &amp; <a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>,</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;         &amp; my_elem_bin,</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;         my_offset</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;        ]</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;        (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a>,</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;         <span class="keyword">const</span> std::vector&lt;Parallel::DofObjectKey&gt; &amp; keys,</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;         std::vector&lt;dof_id_type&gt; &amp; global_ids)</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;        {</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;          <span class="comment">// Fill the requests</span></div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;          <span class="keyword">const</span> std::size_t keys_size = keys.size();</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;          global_ids.reserve(keys_size);</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;          <span class="keywordflow">for</span> (std::size_t <a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a>=0; <a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a> != keys_size; <a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a>++)</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;            {</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;              <span class="keyword">const</span> <a class="code" href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">Parallel::DofObjectKey</a> &amp; hi = keys[<a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a>];</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;              libmesh_assert_less_equal (hi, elem_upper_bounds[<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.rank()]);</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;              <span class="comment">// find the requested index in my elem bin</span></div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;              std::vector&lt;Parallel::DofObjectKey&gt;::const_iterator pos =</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;                std::lower_bound (my_elem_bin.begin(), my_elem_bin.end(), hi);</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;              libmesh_assert (pos != my_elem_bin.end());</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;              libmesh_assert_equal_to (*pos, hi);</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;              <span class="comment">// Finally, assign the global index based off the position of the index</span></div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;              <span class="comment">// in my array, properly offset.</span></div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;              global_ids.push_back (cast_int&lt;dof_id_type&gt;(std::distance(my_elem_bin.begin(), pos) + my_offset));</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;            }</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;        };</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;      <span class="keyword">auto</span> action_functor =</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;        [&amp;filled_request]</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;        (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> pid,</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;         <span class="keyword">const</span> std::vector&lt;Parallel::DofObjectKey&gt; &amp;,</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;         <span class="keyword">const</span> std::vector&lt;dof_id_type&gt; &amp; global_ids)</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;        {</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;          filled_request[pid] = global_ids;</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;        };</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;      <span class="comment">// Trade requests with other processors</span></div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;      <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> * ex = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;      <a class="code" href="namespacelibMesh_1_1Parallel.html#a21797734483c801c09fa26822455d989">Parallel::pull_parallel_vector_data</a></div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;        (<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>, requested_ids, gather_functor, action_functor, ex);</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;      <span class="comment">// We now have all the filled requests, so we can loop through our</span></div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;      <span class="comment">// elements once and assign the global index to each one.</span></div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;      {</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;        std::vector&lt;std::vector&lt;dof_id_type&gt;::const_iterator&gt;</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;          next_obj_on_proc; next_obj_on_proc.reserve(<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.size());</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> pid=0; pid&lt;<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.size(); pid++)</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;          next_obj_on_proc.push_back(filled_request[pid].begin());</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a5173d38b4db709085b1cde698137d042">element_ptr_range</a>())</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;          {</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;            libmesh_assert(elem);</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;            <span class="keyword">const</span> <a class="code" href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">Parallel::DofObjectKey</a> hi =</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;              get_dofobject_key (elem, bbox);</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;            <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> pid =</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;              cast_int&lt;processor_id_type&gt;</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;              (std::distance (elem_upper_bounds.begin(),</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;                              std::lower_bound(elem_upper_bounds.begin(),</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;                                               elem_upper_bounds.end(),</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;                                               hi)));</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;            libmesh_assert_less (pid, <a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.size());</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;            libmesh_assert (next_obj_on_proc[pid] != filled_request[pid].<a class="code" href="variant__filter__iterator_8h.html#a785f0bd261d7bd1918b031c5133da2b9">end</a>());</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;            <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> global_index = *next_obj_on_proc[pid];</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;            libmesh_assert_less (global_index, <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a190e556d3be87f5ccd8d4fc98d1779d3">n_elem</a>());</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;            elem-&gt;set_id() = global_index;</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;            ++next_obj_on_proc[pid];</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;          }</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;      }</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;    }</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;  }</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;}</div><div class="ttc" id="classlibMesh_1_1Parallel_1_1Communicator_html"><div class="ttname"><a href="classlibMesh_1_1Parallel_1_1Communicator.html">libMesh::Parallel::Communicator</a></div><div class="ttdef"><b>Definition:</b> <a href="communicator_8h_source.html#l00092">communicator.h:92</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Threads_html_a97dcd01ff677ad850c3c9f6d8380dba2"><div class="ttname"><a href="namespacelibMesh_1_1Threads.html#a97dcd01ff677ad850c3c9f6d8380dba2">libMesh::Threads::parallel_for</a></div><div class="ttdeci">void parallel_for(const Range &amp;range, const Body &amp;body)</div><div class="ttdef"><b>Definition:</b> <a href="threads__none_8h_source.html#l00073">threads_none.h:73</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_aefbe7c94fa1895557e56fdc001710b16"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">libMesh::Parallel::DofObjectKey</a></div><div class="ttdeci">std::pair&lt; Hilbert::HilbertIndices, unique_id_type &gt; DofObjectKey</div><div class="ttdef"><b>Definition:</b> <a href="parallel__hilbert_8h_source.html#l00069">parallel_hilbert.h:69</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_a2cdfa6faf50f37586a86c57926bda43e"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">libMesh::Parallel::communicator</a></div><div class="ttdeci">MPI_Comm communicator</div><div class="ttdef"><b>Definition:</b> <a href="communicator_8h_source.html#l00057">communicator.h:57</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a5b67c2aa94e76310a6db3470cce8ef11"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a5b67c2aa94e76310a6db3470cce8ef11">libMesh::MeshBase::local_elements_begin</a></div><div class="ttdeci">virtual element_iterator local_elements_begin()=0</div></div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
<div class="ttc" id="namespacelibMesh_html_afebcb3616f8c81cda531dec404f2420d"><div class="ttname"><a href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">libMesh::processor_id_type</a></div><div class="ttdeci">uint8_t processor_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00099">id_types.h:99</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a4dfeba78f759a8e42683bb559ce1e9fa"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const</div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00089">parallel_object.h:89</a></div></div>
<div class="ttc" id="variant__filter__iterator_8h_html_a785f0bd261d7bd1918b031c5133da2b9"><div class="ttname"><a href="variant__filter__iterator_8h.html#a785f0bd261d7bd1918b031c5133da2b9">end</a></div><div class="ttdeci">IterBase * end</div><div class="ttdef"><b>Definition:</b> <a href="variant__filter__iterator_8h_source.html#l00343">variant_filter_iterator.h:343</a></div></div>
<div class="ttc" id="classlibMesh_1_1StoredRange_html"><div class="ttname"><a href="classlibMesh_1_1StoredRange.html">libMesh::StoredRange</a></div><div class="ttdoc">Utility class for defining generic ranges for threading. </div><div class="ttdef"><b>Definition:</b> <a href="stored__range_8h_source.html#l00052">stored_range.h:52</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a5173d38b4db709085b1cde698137d042"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a5173d38b4db709085b1cde698137d042">libMesh::MeshBase::element_ptr_range</a></div><div class="ttdeci">virtual SimpleRange&lt; element_iterator &gt; element_ptr_range()=0</div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_ad0daaecd9c183194a99609db6507198c"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#ad0daaecd9c183194a99609db6507198c">libMesh::MeshBase::local_nodes_end</a></div><div class="ttdeci">virtual node_iterator local_nodes_end()=0</div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_a21797734483c801c09fa26822455d989"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#a21797734483c801c09fa26822455d989">libMesh::Parallel::pull_parallel_vector_data</a></div><div class="ttdeci">void pull_parallel_vector_data(const Communicator &amp;comm, const MapToVectors &amp;queries, RequestContainer &amp;reqs, GatherFunctor &amp;gather_data, ActionFunctor &amp;act_on_data, const datum *example)</div><div class="ttdef"><b>Definition:</b> <a href="parallel__sync_8h_source.html#l00472">parallel_sync.h:472</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a36c73b238ec8e3f2b2c2a7abd167206a"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a36c73b238ec8e3f2b2c2a7abd167206a">libMesh::MeshBase::node_ptr_range</a></div><div class="ttdeci">virtual SimpleRange&lt; node_iterator &gt; node_ptr_range()=0</div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_ab8bd839216a1ef9c0912d523b68ae136"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#ab8bd839216a1ef9c0912d523b68ae136">libMesh::MeshBase::local_elements_end</a></div><div class="ttdeci">virtual element_iterator local_elements_end()=0</div></div>
<div class="ttc" id="classlibMesh_1_1BoundingBox_html"><div class="ttname"><a href="classlibMesh_1_1BoundingBox.html">libMesh::BoundingBox</a></div><div class="ttdef"><b>Definition:</b> <a href="bounding__box_8h_source.html#l00040">bounding_box.h:40</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a7a87dbe56aaa89961e03d60a25a36e8b"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a7a87dbe56aaa89961e03d60a25a36e8b">libMesh::MeshBase::local_nodes_begin</a></div><div class="ttdeci">virtual node_iterator local_nodes_begin()=0</div></div>
<div class="ttc" id="classlibMesh_1_1Parallel_1_1Sort_html"><div class="ttname"><a href="classlibMesh_1_1Parallel_1_1Sort.html">libMesh::Parallel::Sort</a></div><div class="ttdoc">Object for performing parallel sorts using MPI. </div><div class="ttdef"><b>Definition:</b> <a href="parallel__sort_8h_source.html#l00053">parallel_sort.h:53</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_a9cc1d9577393d91d5df11f4034e1264b"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#a9cc1d9577393d91d5df11f4034e1264b">libMesh::MeshTools::create_nodal_bounding_box</a></div><div class="ttdeci">libMesh::BoundingBox create_nodal_bounding_box(const MeshBase &amp;mesh)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00411">mesh_tools.C:411</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a190e556d3be87f5ccd8d4fc98d1779d3"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a190e556d3be87f5ccd8d4fc98d1779d3">libMesh::MeshBase::n_elem</a></div><div class="ttdeci">virtual dof_id_type n_elem() const =0</div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a5b76b109bc6bd087c981774897aa6167"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a5b76b109bc6bd087c981774897aa6167">libMesh::MeshBase::n_nodes</a></div><div class="ttdeci">virtual dof_id_type n_nodes() const =0</div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private_html_acd3e3226af58784e414a3c242a3ef740"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">libMesh::MeshTools::Generation::Private::idx</a></div><div class="ttdeci">unsigned int idx(const ElemType type, const unsigned int nx, const unsigned int i, const unsigned int j)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__generation_8C_source.html#l00070">mesh_generation.C:70</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00064">id_types.h:64</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="afd58bfae74fde1354254205047b36e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd58bfae74fde1354254205047b36e59">&#9670;&nbsp;</a></span>broadcast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::broadcast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds all the processors that may contain elements that neighbor my elements. This list is guaranteed to include all processors that border any of my elements, but may include additional ones as well. This method computes bounding boxes for the elements on each processor and checks for overlaps. This method takes a mesh (which is assumed to reside on processor 0) and broadcasts it to all the other processors. It also broadcasts any boundary information the mesh has associated with it. </p>

<p class="definition">Definition at line <a class="el" href="mesh__communication_8C_source.html#l01084">1084</a> of file <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a>.</p>

<p class="reference">Referenced by <a class="el" href="namebased__io_8C_source.html#l00059">libMesh::NameBasedIO::read()</a>, and <a class="el" href="checkpoint__io_8C_source.html#l00750">libMesh::CheckpointIO::read()</a>.</p>
<div class="fragment"><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;{</div><div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;  <span class="comment">// no MPI == one processor, no need for this method...</span></div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;  <span class="keywordflow">return</span>;</div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a2139c13a54f24e2108b7b233d3c7ba80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2139c13a54f24e2108b7b233d3c7ba80">&#9670;&nbsp;</a></span>check_for_duplicate_global_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::check_for_duplicate_global_indices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Throw an error if we have any index clashes in the numbering used by assign_global_indices. </p>

<p class="definition">Definition at line <a class="el" href="mesh__communication__global__indices_8C_source.html#l00575">575</a> of file <a class="el" href="mesh__communication__global__indices_8C_source.html">mesh_communication_global_indices.C</a>.</p>

<p class="reference">References <a class="el" href="mesh__tools_8C_source.html#l00411">libMesh::MeshTools::create_nodal_bounding_box()</a>, <a class="el" href="libmesh__common_8h_source.html#l00229">libMesh::err</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a5b67c2aa94e76310a6db3470cce8ef11">libMesh::MeshBase::local_elements_begin()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#ab8bd839216a1ef9c0912d523b68ae136">libMesh::MeshBase::local_elements_end()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a7a87dbe56aaa89961e03d60a25a36e8b">libMesh::MeshBase::local_nodes_begin()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#ad0daaecd9c183194a99609db6507198c">libMesh::MeshBase::local_nodes_end()</a>, <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>, and <a class="el" href="threads__none_8h_source.html#l00073">libMesh::Threads::parallel_for()</a>.</p>
<div class="fragment"><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;{</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;  LOG_SCOPE (<span class="stringliteral">&quot;check_for_duplicate_global_indices()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;  <span class="comment">// Global bounding box.  We choose the nodal bounding box for</span></div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;  <span class="comment">// backwards compatibility; the element bounding box may be looser</span></div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;  <span class="comment">// on curved elements.</span></div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;  <a class="code" href="classlibMesh_1_1BoundingBox.html">BoundingBox</a> bbox =</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;    <a class="code" href="namespacelibMesh_1_1MeshTools.html#a9cc1d9577393d91d5df11f4034e1264b">MeshTools::create_nodal_bounding_box</a> (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;  std::vector&lt;Parallel::DofObjectKey&gt;</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;    node_keys, elem_keys;</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;  {</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;    <span class="comment">// Nodes first</span></div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;    {</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;      <a class="code" href="classlibMesh_1_1StoredRange.html">ConstNodeRange</a> nr (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a7a87dbe56aaa89961e03d60a25a36e8b">local_nodes_begin</a>(),</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;                         <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#ad0daaecd9c183194a99609db6507198c">local_nodes_end</a>());</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;      node_keys.resize (nr.size());</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;      <a class="code" href="namespacelibMesh_1_1Threads.html#a97dcd01ff677ad850c3c9f6d8380dba2">Threads::parallel_for</a> (nr, ComputeHilbertKeys (bbox, node_keys));</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;      <span class="comment">// It&#39;s O(N^2) to check that these keys don&#39;t duplicate before the</span></div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;      <span class="comment">// sort...</span></div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;      <a class="code" href="structlibMesh_1_1MeshBase_1_1const__node__iterator.html">MeshBase::const_node_iterator</a> nodei = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a7a87dbe56aaa89961e03d60a25a36e8b">local_nodes_begin</a>();</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;      <span class="keywordflow">for</span> (std::size_t i = 0; i != node_keys.size(); ++i, ++nodei)</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;        {</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;          <a class="code" href="structlibMesh_1_1MeshBase_1_1const__node__iterator.html">MeshBase::const_node_iterator</a> nodej = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a7a87dbe56aaa89961e03d60a25a36e8b">local_nodes_begin</a>();</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;          <span class="keywordflow">for</span> (std::size_t j = 0; j != i; ++j, ++nodej)</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;            {</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;              <span class="keywordflow">if</span> (node_keys[i] == node_keys[j])</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;                {</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;                  CFixBitVec icoords[3], jcoords[3];</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;                  get_hilbert_coords(**nodej, bbox, jcoords);</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;                  <a class="code" href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a> &lt;&lt;</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;                    <span class="stringliteral">&quot;node &quot;</span> &lt;&lt; (*nodej)-&gt;id() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt;</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;                    *(<a class="code" href="classlibMesh_1_1Point.html">Point</a> *)(*nodej) &lt;&lt; <span class="stringliteral">&quot; has HilbertIndices &quot;</span> &lt;&lt;</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;                    node_keys[j] &lt;&lt; std::endl;</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;                  get_hilbert_coords(**nodei, bbox, icoords);</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;                  <a class="code" href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a> &lt;&lt;</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;                    <span class="stringliteral">&quot;node &quot;</span> &lt;&lt; (*nodei)-&gt;id() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt;</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;                    *(<a class="code" href="classlibMesh_1_1Point.html">Point</a> *)(*nodei) &lt;&lt; <span class="stringliteral">&quot; has HilbertIndices &quot;</span> &lt;&lt;</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;                    node_keys[i] &lt;&lt; std::endl;</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;                  libmesh_error_msg(<span class="stringliteral">&quot;Error: nodes with duplicate Hilbert keys!&quot;</span>);</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;                }</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;            }</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;        }</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;    }</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;    <span class="comment">// Elements next</span></div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;    {</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;      <a class="code" href="classlibMesh_1_1StoredRange.html">ConstElemRange</a> er (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a5b67c2aa94e76310a6db3470cce8ef11">local_elements_begin</a>(),</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;                         <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#ab8bd839216a1ef9c0912d523b68ae136">local_elements_end</a>());</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;      elem_keys.resize (er.size());</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;      <a class="code" href="namespacelibMesh_1_1Threads.html#a97dcd01ff677ad850c3c9f6d8380dba2">Threads::parallel_for</a> (er, ComputeHilbertKeys (bbox, elem_keys));</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;      <span class="comment">// For elements, the keys can be (and in the case of TRI, are</span></div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;      <span class="comment">// expected to be) duplicates, but only if the elements are at</span></div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;      <span class="comment">// different levels</span></div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;      <a class="code" href="structlibMesh_1_1MeshBase_1_1const__element__iterator.html">MeshBase::const_element_iterator</a> elemi = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a5b67c2aa94e76310a6db3470cce8ef11">local_elements_begin</a>();</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;      <span class="keywordflow">for</span> (std::size_t i = 0; i != elem_keys.size(); ++i, ++elemi)</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;        {</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;          <a class="code" href="structlibMesh_1_1MeshBase_1_1const__element__iterator.html">MeshBase::const_element_iterator</a> elemj = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a5b67c2aa94e76310a6db3470cce8ef11">local_elements_begin</a>();</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;          <span class="keywordflow">for</span> (std::size_t j = 0; j != i; ++j, ++elemj)</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;            {</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;              <span class="keywordflow">if</span> ((elem_keys[i] == elem_keys[j]) &amp;&amp;</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;                  ((*elemi)-&gt;level() == (*elemj)-&gt;level()))</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;                {</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;                  <a class="code" href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a> &lt;&lt;</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;                    <span class="stringliteral">&quot;level &quot;</span> &lt;&lt; (*elemj)-&gt;level() &lt;&lt; <span class="stringliteral">&quot; elem\n&quot;</span> &lt;&lt;</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;                    (**elemj) &lt;&lt; <span class="stringliteral">&quot; centroid &quot;</span> &lt;&lt;</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;                    (*elemj)-&gt;centroid() &lt;&lt; <span class="stringliteral">&quot; has HilbertIndices &quot;</span> &lt;&lt;</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;                    elem_keys[j] &lt;&lt; <span class="stringliteral">&quot; or &quot;</span> &lt;&lt;</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;                    get_dofobject_key((*elemj), bbox) &lt;&lt;</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;                    std::endl;</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;                  <a class="code" href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a> &lt;&lt;</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;                    <span class="stringliteral">&quot;level &quot;</span> &lt;&lt; (*elemi)-&gt;level() &lt;&lt; <span class="stringliteral">&quot; elem\n&quot;</span> &lt;&lt;</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;                    (**elemi) &lt;&lt; <span class="stringliteral">&quot; centroid &quot;</span> &lt;&lt;</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;                    (*elemi)-&gt;centroid() &lt;&lt; <span class="stringliteral">&quot; has HilbertIndices &quot;</span> &lt;&lt;</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;                    elem_keys[i] &lt;&lt; <span class="stringliteral">&quot; or &quot;</span> &lt;&lt;</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;                    get_dofobject_key((*elemi), bbox) &lt;&lt;</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;                    std::endl;</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;                  libmesh_error_msg(<span class="stringliteral">&quot;Error: level &quot;</span> &lt;&lt; (*elemi)-&gt;level() &lt;&lt; <span class="stringliteral">&quot; elements with duplicate Hilbert keys!&quot;</span>);</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;                }</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;            }</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;        }</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;    }</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;  } <span class="comment">// done checking Hilbert keys</span></div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;}</div><div class="ttc" id="namespacelibMesh_1_1Threads_html_a97dcd01ff677ad850c3c9f6d8380dba2"><div class="ttname"><a href="namespacelibMesh_1_1Threads.html#a97dcd01ff677ad850c3c9f6d8380dba2">libMesh::Threads::parallel_for</a></div><div class="ttdeci">void parallel_for(const Range &amp;range, const Body &amp;body)</div><div class="ttdef"><b>Definition:</b> <a href="threads__none_8h_source.html#l00073">threads_none.h:73</a></div></div>
<div class="ttc" id="structlibMesh_1_1MeshBase_1_1const__element__iterator_html"><div class="ttname"><a href="structlibMesh_1_1MeshBase_1_1const__element__iterator.html">libMesh::MeshBase::const_element_iterator</a></div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l01527">mesh_base.h:1527</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a5b67c2aa94e76310a6db3470cce8ef11"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a5b67c2aa94e76310a6db3470cce8ef11">libMesh::MeshBase::local_elements_begin</a></div><div class="ttdeci">virtual element_iterator local_elements_begin()=0</div></div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
<div class="ttc" id="classlibMesh_1_1StoredRange_html"><div class="ttname"><a href="classlibMesh_1_1StoredRange.html">libMesh::StoredRange</a></div><div class="ttdoc">Utility class for defining generic ranges for threading. </div><div class="ttdef"><b>Definition:</b> <a href="stored__range_8h_source.html#l00052">stored_range.h:52</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_ad0daaecd9c183194a99609db6507198c"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#ad0daaecd9c183194a99609db6507198c">libMesh::MeshBase::local_nodes_end</a></div><div class="ttdeci">virtual node_iterator local_nodes_end()=0</div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_ab8bd839216a1ef9c0912d523b68ae136"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#ab8bd839216a1ef9c0912d523b68ae136">libMesh::MeshBase::local_elements_end</a></div><div class="ttdeci">virtual element_iterator local_elements_end()=0</div></div>
<div class="ttc" id="namespacelibMesh_html_a74e5bc8a72d210b3d87b0221b1f69db1"><div class="ttname"><a href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a></div><div class="ttdeci">OStreamProxy err(std::cerr)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00229">libmesh_common.h:229</a></div></div>
<div class="ttc" id="classlibMesh_1_1BoundingBox_html"><div class="ttname"><a href="classlibMesh_1_1BoundingBox.html">libMesh::BoundingBox</a></div><div class="ttdef"><b>Definition:</b> <a href="bounding__box_8h_source.html#l00040">bounding_box.h:40</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a7a87dbe56aaa89961e03d60a25a36e8b"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a7a87dbe56aaa89961e03d60a25a36e8b">libMesh::MeshBase::local_nodes_begin</a></div><div class="ttdeci">virtual node_iterator local_nodes_begin()=0</div></div>
<div class="ttc" id="structlibMesh_1_1MeshBase_1_1const__node__iterator_html"><div class="ttname"><a href="structlibMesh_1_1MeshBase_1_1const__node__iterator.html">libMesh::MeshBase::const_node_iterator</a></div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l01581">mesh_base.h:1581</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_a9cc1d9577393d91d5df11f4034e1264b"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#a9cc1d9577393d91d5df11f4034e1264b">libMesh::MeshTools::create_nodal_bounding_box</a></div><div class="ttdeci">libMesh::BoundingBox create_nodal_bounding_box(const MeshBase &amp;mesh)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00411">mesh_tools.C:411</a></div></div>
<div class="ttc" id="classlibMesh_1_1Point_html"><div class="ttname"><a href="classlibMesh_1_1Point.html">libMesh::Point</a></div><div class="ttdoc">A geometric point in (x,y,z) space. </div><div class="ttdef"><b>Definition:</b> <a href="point_8h_source.html#l00038">point.h:38</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a227f46dad6159d846d8e6c90a9cfe3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227f46dad6159d846d8e6c90a9cfe3cb">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears all data structures and resets to a pristine state. </p>

<p class="definition">Definition at line <a class="el" href="mesh__communication_8C_source.html#l00275">275</a> of file <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a>.</p>
<div class="fragment"><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;{</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;  <span class="comment">//  _neighboring_processors.clear();</span></div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a24c5c1853317c91b7ac49cf06f16cbb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c5c1853317c91b7ac49cf06f16cbb3">&#9670;&nbsp;</a></span>delete_remote_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::delete_remote_elements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1DistributedMesh.html">DistributedMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classlibMesh_1_1Elem.html">Elem</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>extra_ghost_elem_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method takes an input <code><a class="el" href="classlibMesh_1_1DistributedMesh.html" title="Mesh data structure which is distributed across all processors. ">DistributedMesh</a></code> which may be distributed among all the processors. Each processor deletes all elements which are neither local elements nor "ghost" elements which touch local elements, and deletes all nodes which are not contained in local or ghost elements. The end result is that a previously serial <code><a class="el" href="classlibMesh_1_1DistributedMesh.html" title="Mesh data structure which is distributed across all processors. ">DistributedMesh</a></code> will be distributed between processors. Since this method is collective it must be called by all processors.</p>
<p>The std::set is a list of extra elements that you <em>don't</em> want to delete. These will be left on the current processor along with local elements and ghosted neighbors. </p>

<p class="definition">Definition at line <a class="el" href="mesh__communication_8C_source.html#l01844">1844</a> of file <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a>.</p>

<p class="reference">References <a class="el" href="elem_8C_source.html#l01577">libMesh::Elem::active_family_tree()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#adc5aec9a40a3a62556acd46ce5e6b247">libMesh::MeshBase::active_pid_elements_begin()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a748cac2a4553a50b41e8c9f6af148b51">libMesh::MeshBase::active_pid_elements_end()</a>, <a class="el" href="simple__range_8h_source.html#l00057">libMesh::as_range()</a>, <a class="el" href="mesh__base_8C_source.html#l00517">libMesh::MeshBase::clear_point_locator()</a>, <a class="el" href="parallel__object_8h_source.html#l00089">libMesh::ParallelObject::comm()</a>, <a class="el" href="mesh__communication_8C_source.html#l00168">libMesh::connect_children()</a>, <a class="el" href="mesh__communication_8C_source.html#l00191">libMesh::connect_families()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a5c7824047ed759b5a4891a6936b546cc">libMesh::MeshBase::delete_elem()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a32f377b1687ed195cf7d1683c4b880e0">libMesh::MeshBase::delete_node()</a>, <a class="el" href="mesh__base_8h_source.html#l00131">libMesh::MeshBase::get_boundary_info()</a>, <a class="el" href="mesh__base_8h_source.html#l00835">libMesh::MeshBase::ghosting_functors_begin()</a>, <a class="el" href="mesh__base_8h_source.html#l00841">libMesh::MeshBase::ghosting_functors_end()</a>, <a class="el" href="mesh__base_8h_source.html#l00154">libMesh::MeshBase::is_serial()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a0a4aaa9ec643866aac1330dcd22f33d8">libMesh::MeshBase::level_elements_begin()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a1d98b8c062de7f861f0eca8cc16b9b79">libMesh::MeshBase::level_elements_end()</a>, <a class="el" href="mesh__tools_8C_source.html#l02033">libMesh::MeshTools::libmesh_assert_valid_refinement_tree()</a>, <a class="el" href="elem_8C_source.html#l01149">libMesh::Elem::make_links_to_me_remote()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a807e5541b5e0608c8847daf6f3ffc1cf">libMesh::MeshBase::max_elem_id()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a613704304440df6ceafa622096befe68">libMesh::MeshBase::max_node_id()</a>, <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>, <a class="el" href="mesh__tools_8C_source.html#l00653">libMesh::MeshTools::n_levels()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a36c73b238ec8e3f2b2c2a7abd167206a">libMesh::MeshBase::node_ptr_range()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#ad609aa21a1ced09d57aae6243a7b0e6f">libMesh::MeshBase::pid_elements_begin()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a3d62eed7f06bd8ccbc4de91e47b8094a">libMesh::MeshBase::pid_elements_end()</a>, <a class="el" href="parallel__object_8h_source.html#l00101">libMesh::ParallelObject::processor_id()</a>, <a class="el" href="mesh__communication_8C_source.html#l00137">libMesh::query_ghosting_functors()</a>, <a class="el" href="mesh__communication_8C_source.html#l00258">libMesh::reconnect_nodes()</a>, <a class="el" href="boundary__info_8C_source.html#l00122">libMesh::BoundaryInfo::regenerate_id_sets()</a>, <a class="el" href="elem_8h_source.html#l02408">libMesh::Elem::subactive()</a>, and <a class="el" href="parallel__implementation_8h_source.html#l01928">libMesh::Parallel::Communicator::verify()</a>.</p>

<p class="reference">Referenced by <a class="el" href="distributed__mesh_8C_source.html#l01338">libMesh::DistributedMesh::delete_remote_elements()</a>.</p>
<div class="fragment"><div class="line"><a name="l01846"></a><span class="lineno"> 1846</span>&#160;{</div><div class="line"><a name="l01847"></a><span class="lineno"> 1847</span>&#160;  <span class="comment">// The mesh should know it&#39;s about to be parallelized</span></div><div class="line"><a name="l01848"></a><span class="lineno"> 1848</span>&#160;  libmesh_assert (!<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a0629d79c85d44523e4e11624aa96cd85">is_serial</a>());</div><div class="line"><a name="l01849"></a><span class="lineno"> 1849</span>&#160;</div><div class="line"><a name="l01850"></a><span class="lineno"> 1850</span>&#160;  LOG_SCOPE(<span class="stringliteral">&quot;delete_remote_elements()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div><div class="line"><a name="l01851"></a><span class="lineno"> 1851</span>&#160;</div><div class="line"><a name="l01852"></a><span class="lineno"> 1852</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div><div class="line"><a name="l01853"></a><span class="lineno"> 1853</span>&#160;  <span class="comment">// We expect maximum ids to be in sync so we can use them to size</span></div><div class="line"><a name="l01854"></a><span class="lineno"> 1854</span>&#160;  <span class="comment">// vectors</span></div><div class="line"><a name="l01855"></a><span class="lineno"> 1855</span>&#160;  libmesh_assert(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">comm</a>().<a class="code" href="classlibMesh_1_1Parallel_1_1Communicator.html#aaa64d157da7003e39404ad0d794e4d4f">verify</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a613704304440df6ceafa622096befe68">max_node_id</a>()));</div><div class="line"><a name="l01856"></a><span class="lineno"> 1856</span>&#160;  libmesh_assert(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">comm</a>().<a class="code" href="classlibMesh_1_1Parallel_1_1Communicator.html#aaa64d157da7003e39404ad0d794e4d4f">verify</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a807e5541b5e0608c8847daf6f3ffc1cf">max_elem_id</a>()));</div><div class="line"><a name="l01857"></a><span class="lineno"> 1857</span>&#160;  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> par_max_node_id = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.parallel_max_node_id();</div><div class="line"><a name="l01858"></a><span class="lineno"> 1858</span>&#160;  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> par_max_elem_id = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.parallel_max_elem_id();</div><div class="line"><a name="l01859"></a><span class="lineno"> 1859</span>&#160;  libmesh_assert_equal_to (par_max_node_id, <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a613704304440df6ceafa622096befe68">max_node_id</a>());</div><div class="line"><a name="l01860"></a><span class="lineno"> 1860</span>&#160;  libmesh_assert_equal_to (par_max_elem_id, <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a807e5541b5e0608c8847daf6f3ffc1cf">max_elem_id</a>());</div><div class="line"><a name="l01861"></a><span class="lineno"> 1861</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l01862"></a><span class="lineno"> 1862</span>&#160;</div><div class="line"><a name="l01863"></a><span class="lineno"> 1863</span>&#160;  std::set&lt;const Elem *, CompareElemIdsByLevel&gt; elements_to_keep;</div><div class="line"><a name="l01864"></a><span class="lineno"> 1864</span>&#160;</div><div class="line"><a name="l01865"></a><span class="lineno"> 1865</span>&#160;  <span class="comment">// Don&#39;t delete elements that we were explicitly told not to</span></div><div class="line"><a name="l01866"></a><span class="lineno"> 1866</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; elem : extra_ghost_elem_ids)</div><div class="line"><a name="l01867"></a><span class="lineno"> 1867</span>&#160;    {</div><div class="line"><a name="l01868"></a><span class="lineno"> 1868</span>&#160;      std::vector&lt;const Elem *&gt; active_family;</div><div class="line"><a name="l01869"></a><span class="lineno"> 1869</span>&#160;<span class="preprocessor">#ifdef LIBMESH_ENABLE_AMR</span></div><div class="line"><a name="l01870"></a><span class="lineno"> 1870</span>&#160;      <span class="keywordflow">if</span> (!elem-&gt;subactive())</div><div class="line"><a name="l01871"></a><span class="lineno"> 1871</span>&#160;        elem-&gt;active_family_tree(active_family);</div><div class="line"><a name="l01872"></a><span class="lineno"> 1872</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l01873"></a><span class="lineno"> 1873</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l01874"></a><span class="lineno"> 1874</span>&#160;        active_family.push_back(elem);</div><div class="line"><a name="l01875"></a><span class="lineno"> 1875</span>&#160;</div><div class="line"><a name="l01876"></a><span class="lineno"> 1876</span>&#160;      <span class="keywordflow">for</span> (std::size_t i=0; i != active_family.size(); ++i)</div><div class="line"><a name="l01877"></a><span class="lineno"> 1877</span>&#160;        elements_to_keep.insert(active_family[i]);</div><div class="line"><a name="l01878"></a><span class="lineno"> 1878</span>&#160;    }</div><div class="line"><a name="l01879"></a><span class="lineno"> 1879</span>&#160;</div><div class="line"><a name="l01880"></a><span class="lineno"> 1880</span>&#160;  <span class="comment">// See which elements we still need to keep ghosted, given that</span></div><div class="line"><a name="l01881"></a><span class="lineno"> 1881</span>&#160;  <span class="comment">// we&#39;re keeping local and unpartitioned elements.</span></div><div class="line"><a name="l01882"></a><span class="lineno"> 1882</span>&#160;  <a class="code" href="namespacelibMesh.html#a397847170d2f9b1bef560ecd9dc9c20b">query_ghosting_functors</a></div><div class="line"><a name="l01883"></a><span class="lineno"> 1883</span>&#160;    (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#a62700690227d24d28c853ab62d38ebb9">processor_id</a>(),</div><div class="line"><a name="l01884"></a><span class="lineno"> 1884</span>&#160;     <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#adc5aec9a40a3a62556acd46ce5e6b247">active_pid_elements_begin</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#a62700690227d24d28c853ab62d38ebb9">processor_id</a>()),</div><div class="line"><a name="l01885"></a><span class="lineno"> 1885</span>&#160;     <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a748cac2a4553a50b41e8c9f6af148b51">active_pid_elements_end</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#a62700690227d24d28c853ab62d38ebb9">processor_id</a>()),</div><div class="line"><a name="l01886"></a><span class="lineno"> 1886</span>&#160;     elements_to_keep);</div><div class="line"><a name="l01887"></a><span class="lineno"> 1887</span>&#160;  <a class="code" href="namespacelibMesh.html#a397847170d2f9b1bef560ecd9dc9c20b">query_ghosting_functors</a></div><div class="line"><a name="l01888"></a><span class="lineno"> 1888</span>&#160;    (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, <a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>,</div><div class="line"><a name="l01889"></a><span class="lineno"> 1889</span>&#160;     <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#adc5aec9a40a3a62556acd46ce5e6b247">active_pid_elements_begin</a>(<a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>),</div><div class="line"><a name="l01890"></a><span class="lineno"> 1890</span>&#160;     <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a748cac2a4553a50b41e8c9f6af148b51">active_pid_elements_end</a>(<a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>),</div><div class="line"><a name="l01891"></a><span class="lineno"> 1891</span>&#160;     elements_to_keep);</div><div class="line"><a name="l01892"></a><span class="lineno"> 1892</span>&#160;</div><div class="line"><a name="l01893"></a><span class="lineno"> 1893</span>&#160;  <span class="comment">// The inactive elements we need to send should have their</span></div><div class="line"><a name="l01894"></a><span class="lineno"> 1894</span>&#160;  <span class="comment">// immediate children present.</span></div><div class="line"><a name="l01895"></a><span class="lineno"> 1895</span>&#160;  <a class="code" href="namespacelibMesh.html#ac1bdc0a8df25c1ddb9116c84db959a6b">connect_children</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#ad609aa21a1ced09d57aae6243a7b0e6f">pid_elements_begin</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#a62700690227d24d28c853ab62d38ebb9">processor_id</a>()),</div><div class="line"><a name="l01896"></a><span class="lineno"> 1896</span>&#160;                   <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a3d62eed7f06bd8ccbc4de91e47b8094a">pid_elements_end</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#a62700690227d24d28c853ab62d38ebb9">processor_id</a>()),</div><div class="line"><a name="l01897"></a><span class="lineno"> 1897</span>&#160;                   elements_to_keep);</div><div class="line"><a name="l01898"></a><span class="lineno"> 1898</span>&#160;  <a class="code" href="namespacelibMesh.html#ac1bdc0a8df25c1ddb9116c84db959a6b">connect_children</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>,</div><div class="line"><a name="l01899"></a><span class="lineno"> 1899</span>&#160;                   <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#ad609aa21a1ced09d57aae6243a7b0e6f">pid_elements_begin</a>(<a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>),</div><div class="line"><a name="l01900"></a><span class="lineno"> 1900</span>&#160;                   <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a3d62eed7f06bd8ccbc4de91e47b8094a">pid_elements_end</a>(<a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>),</div><div class="line"><a name="l01901"></a><span class="lineno"> 1901</span>&#160;                   elements_to_keep);</div><div class="line"><a name="l01902"></a><span class="lineno"> 1902</span>&#160;</div><div class="line"><a name="l01903"></a><span class="lineno"> 1903</span>&#160;  <span class="comment">// The elements we need should have their ancestors and their</span></div><div class="line"><a name="l01904"></a><span class="lineno"> 1904</span>&#160;  <span class="comment">// subactive children present too.</span></div><div class="line"><a name="l01905"></a><span class="lineno"> 1905</span>&#160;  <a class="code" href="namespacelibMesh.html#af3db0ef5e34c239c49e8bee7cb88850e">connect_families</a>(elements_to_keep);</div><div class="line"><a name="l01906"></a><span class="lineno"> 1906</span>&#160;</div><div class="line"><a name="l01907"></a><span class="lineno"> 1907</span>&#160;  <span class="comment">// Don&#39;t delete nodes that our semilocal elements need</span></div><div class="line"><a name="l01908"></a><span class="lineno"> 1908</span>&#160;  std::set&lt;const Node *&gt; connected_nodes;</div><div class="line"><a name="l01909"></a><span class="lineno"> 1909</span>&#160;  <a class="code" href="namespacelibMesh.html#a5ea0b7205c832583e566baccf716bc4a">reconnect_nodes</a>(elements_to_keep, connected_nodes);</div><div class="line"><a name="l01910"></a><span class="lineno"> 1910</span>&#160;</div><div class="line"><a name="l01911"></a><span class="lineno"> 1911</span>&#160;  <span class="comment">// Delete all the elements we have no reason to save,</span></div><div class="line"><a name="l01912"></a><span class="lineno"> 1912</span>&#160;  <span class="comment">// starting with the most refined so that the mesh</span></div><div class="line"><a name="l01913"></a><span class="lineno"> 1913</span>&#160;  <span class="comment">// is valid at all intermediate steps</span></div><div class="line"><a name="l01914"></a><span class="lineno"> 1914</span>&#160;  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacelibMesh_1_1MeshTools.html#ae15ece869d4ef3d283edb677942e8439">n_levels</a> = <a class="code" href="namespacelibMesh_1_1MeshTools.html#ae15ece869d4ef3d283edb677942e8439">MeshTools::n_levels</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div><div class="line"><a name="l01915"></a><span class="lineno"> 1915</span>&#160;</div><div class="line"><a name="l01916"></a><span class="lineno"> 1916</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l = <a class="code" href="namespacelibMesh_1_1MeshTools.html#ae15ece869d4ef3d283edb677942e8439">n_levels</a> - 1; l &gt;= 0; --l)</div><div class="line"><a name="l01917"></a><span class="lineno"> 1917</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : <a class="code" href="namespacelibMesh.html#a977361a82b7a9e7ad8e50ae1cae40d20">as_range</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a0a4aaa9ec643866aac1330dcd22f33d8">level_elements_begin</a>(l),</div><div class="line"><a name="l01918"></a><span class="lineno"> 1918</span>&#160;                                <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a1d98b8c062de7f861f0eca8cc16b9b79">level_elements_end</a>(l)))</div><div class="line"><a name="l01919"></a><span class="lineno"> 1919</span>&#160;      {</div><div class="line"><a name="l01920"></a><span class="lineno"> 1920</span>&#160;        libmesh_assert (elem);</div><div class="line"><a name="l01921"></a><span class="lineno"> 1921</span>&#160;        <span class="comment">// Make sure we don&#39;t leave any invalid pointers</span></div><div class="line"><a name="l01922"></a><span class="lineno"> 1922</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">bool</span> keep_me = elements_to_keep.count(elem);</div><div class="line"><a name="l01923"></a><span class="lineno"> 1923</span>&#160;</div><div class="line"><a name="l01924"></a><span class="lineno"> 1924</span>&#160;        <span class="keywordflow">if</span> (!keep_me)</div><div class="line"><a name="l01925"></a><span class="lineno"> 1925</span>&#160;          elem-&gt;make_links_to_me_remote();</div><div class="line"><a name="l01926"></a><span class="lineno"> 1926</span>&#160;</div><div class="line"><a name="l01927"></a><span class="lineno"> 1927</span>&#160;        <span class="comment">// delete_elem doesn&#39;t currently invalidate element</span></div><div class="line"><a name="l01928"></a><span class="lineno"> 1928</span>&#160;        <span class="comment">// iterators... that had better not change</span></div><div class="line"><a name="l01929"></a><span class="lineno"> 1929</span>&#160;        <span class="keywordflow">if</span> (!keep_me)</div><div class="line"><a name="l01930"></a><span class="lineno"> 1930</span>&#160;          <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a5c7824047ed759b5a4891a6936b546cc">delete_elem</a>(elem);</div><div class="line"><a name="l01931"></a><span class="lineno"> 1931</span>&#160;      }</div><div class="line"><a name="l01932"></a><span class="lineno"> 1932</span>&#160;</div><div class="line"><a name="l01933"></a><span class="lineno"> 1933</span>&#160;  <span class="comment">// Delete all the nodes we have no reason to save</span></div><div class="line"><a name="l01934"></a><span class="lineno"> 1934</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; node : <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a36c73b238ec8e3f2b2c2a7abd167206a">node_ptr_range</a>())</div><div class="line"><a name="l01935"></a><span class="lineno"> 1935</span>&#160;    {</div><div class="line"><a name="l01936"></a><span class="lineno"> 1936</span>&#160;      libmesh_assert(node);</div><div class="line"><a name="l01937"></a><span class="lineno"> 1937</span>&#160;      <span class="keywordflow">if</span> (!connected_nodes.count(node))</div><div class="line"><a name="l01938"></a><span class="lineno"> 1938</span>&#160;        <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a32f377b1687ed195cf7d1683c4b880e0">delete_node</a>(node);</div><div class="line"><a name="l01939"></a><span class="lineno"> 1939</span>&#160;    }</div><div class="line"><a name="l01940"></a><span class="lineno"> 1940</span>&#160;</div><div class="line"><a name="l01941"></a><span class="lineno"> 1941</span>&#160;  <span class="comment">// If we had a point locator, it&#39;s invalid now that some of the</span></div><div class="line"><a name="l01942"></a><span class="lineno"> 1942</span>&#160;  <span class="comment">// elements it pointed to have been deleted.</span></div><div class="line"><a name="l01943"></a><span class="lineno"> 1943</span>&#160;  <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#acc11230de16adce50cbd3edabe8b778a">clear_point_locator</a>();</div><div class="line"><a name="l01944"></a><span class="lineno"> 1944</span>&#160;</div><div class="line"><a name="l01945"></a><span class="lineno"> 1945</span>&#160;  <span class="comment">// Much of our boundary info may have been for now-remote parts of</span></div><div class="line"><a name="l01946"></a><span class="lineno"> 1946</span>&#160;  <span class="comment">// the mesh, in which case we don&#39;t want to keep local copies.</span></div><div class="line"><a name="l01947"></a><span class="lineno"> 1947</span>&#160;  <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a640865bf6d6c35628d6c56703dc51834">get_boundary_info</a>().<a class="code" href="classlibMesh_1_1BoundaryInfo.html#ac21e6a4631ede0d563db9c7c6e2c26cf">regenerate_id_sets</a>();</div><div class="line"><a name="l01948"></a><span class="lineno"> 1948</span>&#160;</div><div class="line"><a name="l01949"></a><span class="lineno"> 1949</span>&#160;  <span class="comment">// We now have all remote elements and nodes deleted; our ghosting</span></div><div class="line"><a name="l01950"></a><span class="lineno"> 1950</span>&#160;  <span class="comment">// functors should be ready to delete any now-redundant cached data</span></div><div class="line"><a name="l01951"></a><span class="lineno"> 1951</span>&#160;  <span class="comment">// they use too.</span></div><div class="line"><a name="l01952"></a><span class="lineno"> 1952</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; gf : <a class="code" href="namespacelibMesh.html#a977361a82b7a9e7ad8e50ae1cae40d20">as_range</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a48bf3be3c919bc3649ace7f5cc74f417">ghosting_functors_begin</a>(), <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a39ca8ac59e331f9ed37ac3c666e7f933">ghosting_functors_end</a>()))</div><div class="line"><a name="l01953"></a><span class="lineno"> 1953</span>&#160;    gf-&gt;delete_remote_elements();</div><div class="line"><a name="l01954"></a><span class="lineno"> 1954</span>&#160;</div><div class="line"><a name="l01955"></a><span class="lineno"> 1955</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div><div class="line"><a name="l01956"></a><span class="lineno"> 1956</span>&#160;  <a class="code" href="namespacelibMesh_1_1MeshTools.html#ad394faa2ff745fcf291cb4c03c20ce73">MeshTools::libmesh_assert_valid_refinement_tree</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div><div class="line"><a name="l01957"></a><span class="lineno"> 1957</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l01958"></a><span class="lineno"> 1958</span>&#160;}</div><div class="ttc" id="classlibMesh_1_1MeshBase_html_a0a4aaa9ec643866aac1330dcd22f33d8"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a0a4aaa9ec643866aac1330dcd22f33d8">libMesh::MeshBase::level_elements_begin</a></div><div class="ttdeci">virtual element_iterator level_elements_begin(unsigned int level)=0</div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_ad394faa2ff745fcf291cb4c03c20ce73"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#ad394faa2ff745fcf291cb4c03c20ce73">libMesh::MeshTools::libmesh_assert_valid_refinement_tree</a></div><div class="ttdeci">void libmesh_assert_valid_refinement_tree(const MeshBase &amp;mesh)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l02033">mesh_tools.C:2033</a></div></div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a4dfeba78f759a8e42683bb559ce1e9fa"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const</div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00089">parallel_object.h:89</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a640865bf6d6c35628d6c56703dc51834"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a640865bf6d6c35628d6c56703dc51834">libMesh::MeshBase::get_boundary_info</a></div><div class="ttdeci">const BoundaryInfo &amp; get_boundary_info() const</div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l00131">mesh_base.h:131</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a1d98b8c062de7f861f0eca8cc16b9b79"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a1d98b8c062de7f861f0eca8cc16b9b79">libMesh::MeshBase::level_elements_end</a></div><div class="ttdeci">virtual element_iterator level_elements_end(unsigned int level)=0</div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a0629d79c85d44523e4e11624aa96cd85"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a0629d79c85d44523e4e11624aa96cd85">libMesh::MeshBase::is_serial</a></div><div class="ttdeci">virtual bool is_serial() const</div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l00154">mesh_base.h:154</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a5c7824047ed759b5a4891a6936b546cc"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a5c7824047ed759b5a4891a6936b546cc">libMesh::MeshBase::delete_elem</a></div><div class="ttdeci">virtual void delete_elem(Elem *e)=0</div></div>
<div class="ttc" id="namespacelibMesh_html_a5ea0b7205c832583e566baccf716bc4a"><div class="ttname"><a href="namespacelibMesh.html#a5ea0b7205c832583e566baccf716bc4a">libMesh::reconnect_nodes</a></div><div class="ttdeci">void reconnect_nodes(const std::set&lt; const Elem *, CompareElemIdsByLevel &gt; &amp;connected_elements, std::set&lt; const Node *&gt; &amp;connected_nodes)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l00258">mesh_communication.C:258</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_aa65deab833c8b1802790cd43ab1b6ee4"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">libMesh::DofObject::invalid_processor_id</a></div><div class="ttdeci">static const processor_id_type invalid_processor_id</div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00358">dof_object.h:358</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_adc5aec9a40a3a62556acd46ce5e6b247"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#adc5aec9a40a3a62556acd46ce5e6b247">libMesh::MeshBase::active_pid_elements_begin</a></div><div class="ttdeci">virtual element_iterator active_pid_elements_begin(processor_id_type proc_id)=0</div></div>
<div class="ttc" id="namespacelibMesh_html_af3db0ef5e34c239c49e8bee7cb88850e"><div class="ttname"><a href="namespacelibMesh.html#af3db0ef5e34c239c49e8bee7cb88850e">libMesh::connect_families</a></div><div class="ttdeci">void connect_families(std::set&lt; const Elem *, CompareElemIdsByLevel &gt; &amp;connected_elements)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l00191">mesh_communication.C:191</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_ae15ece869d4ef3d283edb677942e8439"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#ae15ece869d4ef3d283edb677942e8439">libMesh::MeshTools::n_levels</a></div><div class="ttdeci">unsigned int n_levels(const MeshBase &amp;mesh)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00653">mesh_tools.C:653</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a36c73b238ec8e3f2b2c2a7abd167206a"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a36c73b238ec8e3f2b2c2a7abd167206a">libMesh::MeshBase::node_ptr_range</a></div><div class="ttdeci">virtual SimpleRange&lt; node_iterator &gt; node_ptr_range()=0</div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a807e5541b5e0608c8847daf6f3ffc1cf"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a807e5541b5e0608c8847daf6f3ffc1cf">libMesh::MeshBase::max_elem_id</a></div><div class="ttdeci">virtual dof_id_type max_elem_id() const =0</div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_acc11230de16adce50cbd3edabe8b778a"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#acc11230de16adce50cbd3edabe8b778a">libMesh::MeshBase::clear_point_locator</a></div><div class="ttdeci">void clear_point_locator()</div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8C_source.html#l00517">mesh_base.C:517</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a977361a82b7a9e7ad8e50ae1cae40d20"><div class="ttname"><a href="namespacelibMesh.html#a977361a82b7a9e7ad8e50ae1cae40d20">libMesh::as_range</a></div><div class="ttdeci">SimpleRange&lt; I &gt; as_range(const std::pair&lt; I, I &gt; &amp;p)</div><div class="ttdef"><b>Definition:</b> <a href="simple__range_8h_source.html#l00057">simple_range.h:57</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a32f377b1687ed195cf7d1683c4b880e0"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a32f377b1687ed195cf7d1683c4b880e0">libMesh::MeshBase::delete_node</a></div><div class="ttdeci">virtual void delete_node(Node *n)=0</div></div>
<div class="ttc" id="classlibMesh_1_1BoundaryInfo_html_ac21e6a4631ede0d563db9c7c6e2c26cf"><div class="ttname"><a href="classlibMesh_1_1BoundaryInfo.html#ac21e6a4631ede0d563db9c7c6e2c26cf">libMesh::BoundaryInfo::regenerate_id_sets</a></div><div class="ttdeci">void regenerate_id_sets()</div><div class="ttdef"><b>Definition:</b> <a href="boundary__info_8C_source.html#l00122">boundary_info.C:122</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_ad609aa21a1ced09d57aae6243a7b0e6f"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#ad609aa21a1ced09d57aae6243a7b0e6f">libMesh::MeshBase::pid_elements_begin</a></div><div class="ttdeci">virtual element_iterator pid_elements_begin(processor_id_type proc_id)=0</div></div>
<div class="ttc" id="namespacelibMesh_html_a397847170d2f9b1bef560ecd9dc9c20b"><div class="ttname"><a href="namespacelibMesh.html#a397847170d2f9b1bef560ecd9dc9c20b">libMesh::query_ghosting_functors</a></div><div class="ttdeci">void query_ghosting_functors(const MeshBase &amp;mesh, processor_id_type pid, MeshBase::const_element_iterator elem_it, MeshBase::const_element_iterator elem_end, std::set&lt; const Elem *, CompareElemIdsByLevel &gt; &amp;connected_elements)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l00137">mesh_communication.C:137</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a48bf3be3c919bc3649ace7f5cc74f417"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a48bf3be3c919bc3649ace7f5cc74f417">libMesh::MeshBase::ghosting_functors_begin</a></div><div class="ttdeci">std::set&lt; GhostingFunctor * &gt;::const_iterator ghosting_functors_begin() const</div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l00835">mesh_base.h:835</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a748cac2a4553a50b41e8c9f6af148b51"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a748cac2a4553a50b41e8c9f6af148b51">libMesh::MeshBase::active_pid_elements_end</a></div><div class="ttdeci">virtual element_iterator active_pid_elements_end(processor_id_type proc_id)=0</div></div>
<div class="ttc" id="namespacelibMesh_html_ac1bdc0a8df25c1ddb9116c84db959a6b"><div class="ttname"><a href="namespacelibMesh.html#ac1bdc0a8df25c1ddb9116c84db959a6b">libMesh::connect_children</a></div><div class="ttdeci">void connect_children(const MeshBase &amp;mesh, MeshBase::const_element_iterator elem_it, MeshBase::const_element_iterator elem_end, std::set&lt; const Elem *, CompareElemIdsByLevel &gt; &amp;connected_elements)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l00168">mesh_communication.C:168</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a613704304440df6ceafa622096befe68"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a613704304440df6ceafa622096befe68">libMesh::MeshBase::max_node_id</a></div><div class="ttdeci">virtual dof_id_type max_node_id() const =0</div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a62700690227d24d28c853ab62d38ebb9"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a62700690227d24d28c853ab62d38ebb9">libMesh::ParallelObject::processor_id</a></div><div class="ttdeci">processor_id_type processor_id() const</div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00101">parallel_object.h:101</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a39ca8ac59e331f9ed37ac3c666e7f933"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a39ca8ac59e331f9ed37ac3c666e7f933">libMesh::MeshBase::ghosting_functors_end</a></div><div class="ttdeci">std::set&lt; GhostingFunctor * &gt;::const_iterator ghosting_functors_end() const</div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l00841">mesh_base.h:841</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00064">id_types.h:64</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a3d62eed7f06bd8ccbc4de91e47b8094a"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a3d62eed7f06bd8ccbc4de91e47b8094a">libMesh::MeshBase::pid_elements_end</a></div><div class="ttdeci">virtual element_iterator pid_elements_end(processor_id_type proc_id)=0</div></div>
<div class="ttc" id="classlibMesh_1_1Parallel_1_1Communicator_html_aaa64d157da7003e39404ad0d794e4d4f"><div class="ttname"><a href="classlibMesh_1_1Parallel_1_1Communicator.html#aaa64d157da7003e39404ad0d794e4d4f">libMesh::Parallel::Communicator::verify</a></div><div class="ttdeci">bool verify(const T &amp;r) const</div><div class="ttdef"><b>Definition:</b> <a href="parallel__implementation_8h_source.html#l01928">parallel_implementation.h:1928</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a64c133d4fec5cd9cddcdd3033d4ca600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c133d4fec5cd9cddcdd3033d4ca600">&#9670;&nbsp;</a></span>find_global_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::find_global_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Parallel::Communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1BoundingBox.html">libMesh::BoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method determines a globally unique, partition-agnostic index for each object in the input range. </p>

<p class="definition">Definition at line <a class="el" href="mesh__communication__global__indices_8C_source.html#l00708">708</a> of file <a class="el" href="mesh__communication__global__indices_8C_source.html">mesh_communication_global_indices.C</a>.</p>

<p class="reference">References <a class="el" href="parallel__sort_8C_source.html#l00260">libMesh::Parallel::Sort&lt; KeyType, IdxType &gt;::bin()</a>, <a class="el" href="variant__filter__iterator_8h_source.html#l00343">end</a>, <a class="el" href="mesh__generation_8C_source.html#l00070">libMesh::MeshTools::Generation::Private::idx()</a>, <a class="el" href="dof__object_8h_source.html#l00358">libMesh::DofObject::invalid_processor_id</a>, <a class="el" href="libmesh__common_8h_source.html#l00461">libMesh::libmesh_ignore()</a>, <a class="el" href="libmesh__augment__std__namespace_8h_source.html#l00027">std::max()</a>, <a class="el" href="parallel__sync_8h_source.html#l00472">libMesh::Parallel::pull_parallel_vector_data()</a>, <a class="el" href="libmesh__common_8h_source.html#l00131">libMesh::Real</a>, and <a class="el" href="parallel__sort_8C_source.html#l00060">libMesh::Parallel::Sort&lt; KeyType, IdxType &gt;::sort()</a>.</p>

<p class="reference">Referenced by <a class="el" href="parmetis__partitioner_8C_source.html#l00214">libMesh::ParmetisPartitioner::initialize()</a>, <a class="el" href="metis__partitioner_8C_source.html#l00056">libMesh::MetisPartitioner::partition_range()</a>, and <a class="el" href="partitioner_8C_source.html#l00194">libMesh::Partitioner::partition_unpartitioned_elements()</a>.</p>
<div class="fragment"><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;{</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;  LOG_SCOPE (<span class="stringliteral">&quot;find_global_indices()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;  <span class="comment">// This method determines partition-agnostic global indices</span></div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;  <span class="comment">// for nodes and elements.</span></div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;  <span class="comment">// Algorithm:</span></div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;  <span class="comment">// (1) compute the Hilbert key for each local node/element</span></div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;  <span class="comment">// (2) perform a parallel sort of the Hilbert key</span></div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;  <span class="comment">// (3) get the min/max value on each processor</span></div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;  <span class="comment">// (4) determine the position in the global ranking for</span></div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;  <span class="comment">//     each local object</span></div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;  index_map.clear();</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;  std::size_t n_objects = std::distance (begin, <a class="code" href="variant__filter__iterator_8h.html#a785f0bd261d7bd1918b031c5133da2b9">end</a>);</div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;  index_map.reserve(n_objects);</div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;</div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;  <span class="comment">//-------------------------------------------------------------</span></div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;  <span class="comment">// (1) compute Hilbert keys</span></div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;  <span class="comment">// These aren&#39;t trivial to compute, and we will need them again.</span></div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;  <span class="comment">// But the binsort will sort the input vector, trashing the order</span></div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;  <span class="comment">// that we&#39;d like to rely on.  So, two vectors...</span></div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;  std::vector&lt;Parallel::DofObjectKey&gt;</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;    sorted_hilbert_keys,</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;    hilbert_keys;</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;  sorted_hilbert_keys.reserve(n_objects);</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;  hilbert_keys.reserve(n_objects);</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;  {</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;    LOG_SCOPE(<span class="stringliteral">&quot;compute_hilbert_indices()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;    <span class="keywordflow">for</span> (ForwardIterator it=begin; it!=<a class="code" href="variant__filter__iterator_8h.html#a785f0bd261d7bd1918b031c5133da2b9">end</a>; ++it)</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;      {</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">Parallel::DofObjectKey</a> hi(get_dofobject_key (*it, bbox));</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;        hilbert_keys.push_back(hi);</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;        <span class="keywordflow">if</span> ((*it)-&gt;processor_id() == <a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.rank())</div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;          sorted_hilbert_keys.push_back(hi);</div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;        <span class="comment">// someone needs to take care of unpartitioned objects!</span></div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;        <span class="keywordflow">if</span> ((<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.rank() == 0) &amp;&amp;</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;            ((*it)-&gt;processor_id() == <a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>))</div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;          sorted_hilbert_keys.push_back(hi);</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;      }</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;  }</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;  <span class="comment">//-------------------------------------------------------------</span></div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;  <span class="comment">// (2) parallel sort the Hilbert keys</span></div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;  START_LOG (<span class="stringliteral">&quot;parallel_sort()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;  <a class="code" href="classlibMesh_1_1Parallel_1_1Sort.html">Parallel::Sort&lt;Parallel::DofObjectKey&gt;</a> sorter (<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>,</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;                                                 sorted_hilbert_keys);</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;  sorter.sort();</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;  STOP_LOG (<span class="stringliteral">&quot;parallel_sort()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;  <span class="keyword">const</span> std::vector&lt;Parallel::DofObjectKey&gt; &amp; my_bin = sorter.bin();</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;  <span class="comment">// The number of objects in my_bin on each processor</span></div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;  std::vector&lt;unsigned int&gt; bin_sizes(<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.size());</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.allgather (static_cast&lt;unsigned int&gt;(my_bin.size()), bin_sizes);</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;  <span class="comment">// The offset of my first global index</span></div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> my_offset = 0;</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pid=0; pid&lt;<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.rank(); pid++)</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;    my_offset += bin_sizes[pid];</div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;  <span class="comment">//-------------------------------------------------------------</span></div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;  <span class="comment">// (3) get the max value on each processor</span></div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;  std::vector&lt;Parallel::DofObjectKey&gt;</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;    upper_bounds(1);</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;</div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;  <span class="keywordflow">if</span> (!my_bin.empty())</div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;    upper_bounds[0] = my_bin.back();</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.allgather (upper_bounds, <span class="comment">/* identical_buffer_sizes = */</span> <span class="keyword">true</span>);</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;</div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;  <span class="comment">// Be careful here.  The *_upper_bounds will be used to find the processor</span></div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;  <span class="comment">// a given object belongs to.  So, if a processor contains no objects (possible!)</span></div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;  <span class="comment">// then copy the bound from the lower processor id.</span></div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=1; p&lt;<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.size(); p++)</div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;    <span class="keywordflow">if</span> (!bin_sizes[p]) upper_bounds[p] = upper_bounds[p-1];</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;  <span class="comment">//-------------------------------------------------------------</span></div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;  <span class="comment">// (4) determine the position in the global ranking for</span></div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;  <span class="comment">//     each local object</span></div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;  {</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;    <span class="comment">//----------------------------------------------</span></div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;    <span class="comment">// all objects, not just local ones</span></div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;    <span class="comment">// Request sets to send to each processor</span></div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;    std::map&lt;processor_id_type, std::vector&lt;Parallel::DofObjectKey&gt;&gt;</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;      requested_ids;</div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;    <span class="comment">// Results to gather from each processor</span></div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;    std::map&lt;processor_id_type, std::vector&lt;dof_id_type&gt;&gt;</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;      filled_request;</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;    <span class="comment">// build up list of requests</span></div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;    std::vector&lt;Parallel::DofObjectKey&gt;::const_iterator hi =</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;      hilbert_keys.begin();</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;    <span class="keywordflow">for</span> (ForwardIterator it = begin; it != <a class="code" href="variant__filter__iterator_8h.html#a785f0bd261d7bd1918b031c5133da2b9">end</a>; ++it)</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;      {</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;        libmesh_assert (hi != hilbert_keys.end());</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;        std::vector&lt;Parallel::DofObjectKey&gt;::iterator lb =</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;          std::lower_bound(upper_bounds.begin(), upper_bounds.end(),</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;                           *hi);</div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;</div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> pid =</div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;          cast_int&lt;processor_id_type&gt;</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;          (std::distance (upper_bounds.begin(), lb));</div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;        libmesh_assert_less (pid, <a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.size());</div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;</div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;        requested_ids[pid].push_back(*hi);</div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;        ++hi;</div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;        <span class="comment">// go ahead and put pid in index_map, that way we</span></div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;        <span class="comment">// don&#39;t have to repeat the std::lower_bound()</span></div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;        index_map.push_back(pid);</div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;      }</div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;</div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;  <span class="keyword">auto</span> gather_functor =</div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;    [</div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;<span class="preprocessor">#ifndef NDEBUG</span></div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;     &amp; upper_bounds,</div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;     &amp; <a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>,</div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;     &amp; bbox,</div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;     &amp; my_bin,</div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;       my_offset</div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;    ]</div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;    (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a>, <span class="keyword">const</span> std::vector&lt;Parallel::DofObjectKey&gt; &amp; keys,</div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;     std::vector&lt;dof_id_type&gt; &amp; global_ids)</div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;    {</div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;      <span class="comment">// Ignore unused lambda capture warnings in devel mode</span></div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;      <a class="code" href="namespacelibMesh.html#a43f45640aab1af26176e69592c666432">libmesh_ignore</a>(bbox);</div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;</div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;      <span class="comment">// Fill the requests</span></div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;      <span class="keyword">const</span> std::size_t keys_size = keys.size();</div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;      global_ids.clear();</div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;      global_ids.reserve(keys_size);</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;      <span class="keywordflow">for</span> (std::size_t <a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a>=0; <a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a> != keys_size; <a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a>++)</div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;        {</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;          <span class="keyword">const</span> <a class="code" href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">Parallel::DofObjectKey</a> &amp; hilbert_indices = keys[<a class="code" href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">idx</a>];</div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;          libmesh_assert_less_equal (hilbert_indices, upper_bounds[<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.rank()]);</div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;</div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;          <span class="comment">// find the requested index in my node bin</span></div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;          std::vector&lt;Parallel::DofObjectKey&gt;::const_iterator pos =</div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;            std::lower_bound (my_bin.begin(), my_bin.end(), hilbert_indices);</div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;          libmesh_assert (pos != my_bin.end());</div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;          <span class="comment">// If we could not find the requested Hilbert index in</span></div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;          <span class="comment">// my_bin, something went terribly wrong, possibly the</span></div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;          <span class="comment">// Mesh was displaced differently on different processors,</span></div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;          <span class="comment">// and therefore the Hilbert indices don&#39;t agree.</span></div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;          <span class="keywordflow">if</span> (*pos != hilbert_indices)</div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;            {</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;              <span class="comment">// The input will be hilbert_indices.  We convert it</span></div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;              <span class="comment">// to BitVecType using the operator= provided by the</span></div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;              <span class="comment">// BitVecType class. BitVecType is a CBigBitVec!</span></div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;              Hilbert::BitVecType input;</div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;<span class="preprocessor">#ifdef LIBMESH_ENABLE_UNIQUE_ID</span></div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;              input = hilbert_indices.first;</div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;              input = hilbert_indices;</div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;              <span class="comment">// Get output in a vector of CBigBitVec</span></div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;              std::vector&lt;CBigBitVec&gt; output(3);</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;              <span class="comment">// Call the indexToCoords function</span></div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;              Hilbert::indexToCoords(output.data(), 8*<span class="keyword">sizeof</span>(Hilbert::inttype), 3, input);</div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;</div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;              <span class="comment">// The entries in the output racks are integers in the</span></div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;              <span class="comment">// range [0, Hilbert::inttype::max] which can be</span></div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;              <span class="comment">// converted to floating point values in [0,1] and</span></div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;              <span class="comment">// finally to actual values using the bounding box.</span></div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;              <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> max_int_as_real =</div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;                <span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a><span class="keyword">&gt;</span>(<a class="code" href="namespacestd.html#a6987c84b7beab8b2ebdee7e2549d698f">std::numeric_limits&lt;Hilbert::inttype&gt;::max</a>());</div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;</div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;              <span class="comment">// Get the points in [0,1]^3.  The zeroth rack of each entry in</span></div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;              <span class="comment">// &#39;output&#39; maps to the normalized x, y, and z locations,</span></div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;              <span class="comment">// respectively.</span></div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;              <a class="code" href="classlibMesh_1_1Point.html">Point</a> p_hat(static_cast&lt;Real&gt;(output[0].racks()[0]) / max_int_as_real,</div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;                          static_cast&lt;Real&gt;(output[1].racks()[0]) / max_int_as_real,</div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;                          static_cast&lt;Real&gt;(output[2].racks()[0]) / max_int_as_real);</div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;</div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;              <span class="comment">// Convert the points from [0,1]^3 to their actual (x,y,z) locations</span></div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;              <a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a></div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;                xmin = bbox.first(0),</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;                xmax = bbox.second(0),</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;                ymin = bbox.first(1),</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;                ymax = bbox.second(1),</div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;                zmin = bbox.first(2),</div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;                zmax = bbox.second(2);</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;</div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;              <span class="comment">// Convert the points from [0,1]^3 to their actual (x,y,z) locations</span></div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;              <a class="code" href="classlibMesh_1_1Point.html">Point</a> p(xmin + (xmax-xmin)*p_hat(0),</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;                      ymin + (ymax-ymin)*p_hat(1),</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;                      zmin + (zmax-zmin)*p_hat(2));</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;</div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;              libmesh_error_msg(<span class="stringliteral">&quot;Could not find hilbert indices: &quot;</span></div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;                                &lt;&lt; hilbert_indices</div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;                                &lt;&lt; <span class="stringliteral">&quot; corresponding to point &quot;</span> &lt;&lt; p);</div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;            }</div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;</div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;          <span class="comment">// Finally, assign the global index based off the position of the index</span></div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;          <span class="comment">// in my array, properly offset.</span></div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;          global_ids.push_back (cast_int&lt;dof_id_type&gt;(std::distance(my_bin.begin(), pos) + my_offset));</div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;        }</div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;    };</div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;</div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;  <span class="keyword">auto</span> action_functor =</div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;    [&amp;filled_request]</div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;    (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> pid,</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;     <span class="keyword">const</span> std::vector&lt;Parallel::DofObjectKey&gt; &amp;,</div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;     <span class="keyword">const</span> std::vector&lt;dof_id_type&gt; &amp; global_ids)</div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;    {</div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;      filled_request[pid] = global_ids;</div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;    };</div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;</div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> * ex = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#a21797734483c801c09fa26822455d989">Parallel::pull_parallel_vector_data</a></div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;    (<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>, requested_ids, gather_functor, action_functor, ex);</div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;</div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;    <span class="comment">// We now have all the filled requests, so we can loop through our</span></div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;    <span class="comment">// nodes once and assign the global index to each one.</span></div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;    {</div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;      std::vector&lt;std::vector&lt;dof_id_type&gt;::const_iterator&gt;</div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;        next_obj_on_proc; next_obj_on_proc.reserve(<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.size());</div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;      <span class="keywordflow">for</span> (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> pid=0; pid&lt;<a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.size(); pid++)</div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;        next_obj_on_proc.push_back(filled_request[pid].begin());</div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;</div><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cnt=0;</div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;      <span class="keywordflow">for</span> (ForwardIterator it = begin; it != <a class="code" href="variant__filter__iterator_8h.html#a785f0bd261d7bd1918b031c5133da2b9">end</a>; ++it, cnt++)</div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;        {</div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;          <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> pid = cast_int&lt;processor_id_type&gt;</div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;            (index_map[cnt]);</div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;</div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;          libmesh_assert_less (pid, <a class="code" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a>.size());</div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;          libmesh_assert (next_obj_on_proc[pid] != filled_request[pid].<a class="code" href="variant__filter__iterator_8h.html#a785f0bd261d7bd1918b031c5133da2b9">end</a>());</div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;</div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;          <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> global_index = *next_obj_on_proc[pid];</div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;          index_map[cnt] = global_index;</div><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;</div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;          ++next_obj_on_proc[pid];</div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;        }</div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;    }</div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;  }</div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;</div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;  libmesh_assert_equal_to(index_map.size(), n_objects);</div><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;}</div><div class="ttc" id="namespacelibMesh_1_1Parallel_html_aefbe7c94fa1895557e56fdc001710b16"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">libMesh::Parallel::DofObjectKey</a></div><div class="ttdeci">std::pair&lt; Hilbert::HilbertIndices, unique_id_type &gt; DofObjectKey</div><div class="ttdef"><b>Definition:</b> <a href="parallel__hilbert_8h_source.html#l00069">parallel_hilbert.h:69</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_a2cdfa6faf50f37586a86c57926bda43e"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">libMesh::Parallel::communicator</a></div><div class="ttdeci">MPI_Comm communicator</div><div class="ttdef"><b>Definition:</b> <a href="communicator_8h_source.html#l00057">communicator.h:57</a></div></div>
<div class="ttc" id="namespacelibMesh_html_afebcb3616f8c81cda531dec404f2420d"><div class="ttname"><a href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">libMesh::processor_id_type</a></div><div class="ttdeci">uint8_t processor_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00099">id_types.h:99</a></div></div>
<div class="ttc" id="variant__filter__iterator_8h_html_a785f0bd261d7bd1918b031c5133da2b9"><div class="ttname"><a href="variant__filter__iterator_8h.html#a785f0bd261d7bd1918b031c5133da2b9">end</a></div><div class="ttdeci">IterBase * end</div><div class="ttdef"><b>Definition:</b> <a href="variant__filter__iterator_8h_source.html#l00343">variant_filter_iterator.h:343</a></div></div>
<div class="ttc" id="namespacestd_html_a6987c84b7beab8b2ebdee7e2549d698f"><div class="ttname"><a href="namespacestd.html#a6987c84b7beab8b2ebdee7e2549d698f">std::max</a></div><div class="ttdeci">long double max(long double a, double b)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__augment__std__namespace_8h_source.html#l00027">libmesh_augment_std_namespace.h:27</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a43f45640aab1af26176e69592c666432"><div class="ttname"><a href="namespacelibMesh.html#a43f45640aab1af26176e69592c666432">libMesh::libmesh_ignore</a></div><div class="ttdeci">void libmesh_ignore(const Args &amp;...)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00461">libmesh_common.h:461</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_a21797734483c801c09fa26822455d989"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#a21797734483c801c09fa26822455d989">libMesh::Parallel::pull_parallel_vector_data</a></div><div class="ttdeci">void pull_parallel_vector_data(const Communicator &amp;comm, const MapToVectors &amp;queries, RequestContainer &amp;reqs, GatherFunctor &amp;gather_data, ActionFunctor &amp;act_on_data, const datum *example)</div><div class="ttdef"><b>Definition:</b> <a href="parallel__sync_8h_source.html#l00472">parallel_sync.h:472</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_aa65deab833c8b1802790cd43ab1b6ee4"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">libMesh::DofObject::invalid_processor_id</a></div><div class="ttdeci">static const processor_id_type invalid_processor_id</div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00358">dof_object.h:358</a></div></div>
<div class="ttc" id="namespacelibMesh_html_aef28359fb4851abec08fc99cfbac118d"><div class="ttname"><a href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">libMesh::Real</a></div><div class="ttdeci">DIE A HORRIBLE DEATH HERE typedef LIBMESH_DEFAULT_SCALAR_TYPE Real</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00131">libmesh_common.h:131</a></div></div>
<div class="ttc" id="classlibMesh_1_1Parallel_1_1Sort_html"><div class="ttname"><a href="classlibMesh_1_1Parallel_1_1Sort.html">libMesh::Parallel::Sort</a></div><div class="ttdoc">Object for performing parallel sorts using MPI. </div><div class="ttdef"><b>Definition:</b> <a href="parallel__sort_8h_source.html#l00053">parallel_sort.h:53</a></div></div>
<div class="ttc" id="classlibMesh_1_1Point_html"><div class="ttname"><a href="classlibMesh_1_1Point.html">libMesh::Point</a></div><div class="ttdoc">A geometric point in (x,y,z) space. </div><div class="ttdef"><b>Definition:</b> <a href="point_8h_source.html#l00038">point.h:38</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private_html_acd3e3226af58784e414a3c242a3ef740"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools_1_1Generation_1_1Private.html#acd3e3226af58784e414a3c242a3ef740">libMesh::MeshTools::Generation::Private::idx</a></div><div class="ttdeci">unsigned int idx(const ElemType type, const unsigned int nx, const unsigned int i, const unsigned int j)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__generation_8C_source.html#l00070">mesh_generation.C:70</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00064">id_types.h:64</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a562715b6bb00fc8e3d6c54cb0ffad446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562715b6bb00fc8e3d6c54cb0ffad446">&#9670;&nbsp;</a></span>find_local_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::find_local_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1BoundingBox.html">libMesh::BoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a>, <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method determines a locally unique, contiguous index for each object in the input range. </p>

<p class="definition">Definition at line <a class="el" href="mesh__communication__global__indices_8C_source.html#l00672">672</a> of file <a class="el" href="mesh__communication__global__indices_8C_source.html">mesh_communication_global_indices.C</a>.</p>

<p class="reference">References <a class="el" href="variant__filter__iterator_8h_source.html#l00343">end</a>.</p>

<p class="reference">Referenced by <a class="el" href="partitioner_8C_source.html#l00907">libMesh::Partitioner::_find_global_index_by_pid_map()</a>.</p>
<div class="fragment"><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;{</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;  LOG_SCOPE (<span class="stringliteral">&quot;find_local_indices()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;  <span class="comment">// This method determines id-agnostic local indices</span></div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;  <span class="comment">// for nodes and elements by sorting Hilbert keys.</span></div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;  index_map.clear();</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;  <span class="comment">//-------------------------------------------------------------</span></div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;  <span class="comment">// (1) compute Hilbert keys</span></div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;  <span class="comment">// These aren&#39;t trivial to compute, and we will need them again.</span></div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;  <span class="comment">// But the binsort will sort the input vector, trashing the order</span></div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;  <span class="comment">// that we&#39;d like to rely on.  So, two vectors...</span></div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;  std::map&lt;Parallel::DofObjectKey, dof_id_type&gt; hilbert_keys;</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;  {</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;    LOG_SCOPE(<span class="stringliteral">&quot;local_hilbert_indices&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;    <span class="keywordflow">for</span> (ForwardIterator it=begin; it!=<a class="code" href="variant__filter__iterator_8h.html#a785f0bd261d7bd1918b031c5133da2b9">end</a>; ++it)</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;      {</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">Parallel::DofObjectKey</a> hi(get_dofobject_key ((*it), bbox));</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;        hilbert_keys.emplace(hi, (*it)-&gt;id());</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;      }</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;  }</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;  {</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;    <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> cnt = 0;</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> key_val : hilbert_keys)</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;      index_map[key_val.second] = cnt++;</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;  }</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;}</div><div class="ttc" id="namespacelibMesh_1_1Parallel_html_aefbe7c94fa1895557e56fdc001710b16"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">libMesh::Parallel::DofObjectKey</a></div><div class="ttdeci">std::pair&lt; Hilbert::HilbertIndices, unique_id_type &gt; DofObjectKey</div><div class="ttdef"><b>Definition:</b> <a href="parallel__hilbert_8h_source.html#l00069">parallel_hilbert.h:69</a></div></div>
<div class="ttc" id="variant__filter__iterator_8h_html_a785f0bd261d7bd1918b031c5133da2b9"><div class="ttname"><a href="variant__filter__iterator_8h.html#a785f0bd261d7bd1918b031c5133da2b9">end</a></div><div class="ttdeci">IterBase * end</div><div class="ttdef"><b>Definition:</b> <a href="variant__filter__iterator_8h_source.html#l00343">variant_filter_iterator.h:343</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00064">id_types.h:64</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4415895c15cce32bdad9b3b23c0d119a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4415895c15cce32bdad9b3b23c0d119a">&#9670;&nbsp;</a></span>gather()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::gather </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a>&#160;</td>
          <td class="paramname"><em>root_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1DistributedMesh.html">DistributedMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method takes an input <code><a class="el" href="classlibMesh_1_1DistributedMesh.html" title="Mesh data structure which is distributed across all processors. ">DistributedMesh</a></code> which may be distributed among all the processors. Each processor then sends its local nodes and elements to processor <code>root_id</code>. The end result is that a previously distributed <code><a class="el" href="classlibMesh_1_1DistributedMesh.html" title="Mesh data structure which is distributed across all processors. ">DistributedMesh</a></code> will be serialized on processor <code>root_id</code>. Since this method is collective it must be called by all processors. For the special case of <code>root_id</code> equal to <code><a class="el" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a></code> this function performs an allgather. </p>

<p class="definition">Definition at line <a class="el" href="mesh__communication_8C_source.html#l01156">1156</a> of file <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a>.</p>

<p class="reference">Referenced by <a class="el" href="mesh__communication_8h_source.html#l00135">allgather()</a>, and <a class="el" href="distributed__mesh_8C_source.html#l01449">libMesh::DistributedMesh::gather_to_zero()</a>.</p>
<div class="fragment"><div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;{</div><div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;  <span class="comment">// no MPI == one processor, no need for this method...</span></div><div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;  <span class="keywordflow">return</span>;</div><div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="acde0fa5a9755f487ce193aeca053412e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde0fa5a9755f487ce193aeca053412e">&#9670;&nbsp;</a></span>gather_neighboring_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::gather_neighboring_elements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1DistributedMesh.html">DistributedMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mesh__communication_8C_source.html#l00540">540</a> of file <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a>.</p>

<p class="reference">Referenced by <a class="el" href="nemesis__io_8C_source.html#l00148">libMesh::Nemesis_IO::read()</a>.</p>
<div class="fragment"><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;{</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;  <span class="comment">// no MPI == one processor, no need for this method...</span></div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;  <span class="keywordflow">return</span>;</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a737da6ee13b781ac7aef37851a99af58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737da6ee13b781ac7aef37851a99af58">&#9670;&nbsp;</a></span>make_elems_parallel_consistent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::make_elems_parallel_consistent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy ids of ghost elements from their local processors. </p>

<p class="definition">Definition at line <a class="el" href="mesh__communication_8C_source.html#l01505">1505</a> of file <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a>.</p>

<p class="reference">References <a class="el" href="classlibMesh_1_1MeshBase.html#aefa4ded9eaf654a45ab593a0963ecbf3">libMesh::MeshBase::active_elements_begin()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#ae3f09f1b7556aef88919249861728e23">libMesh::MeshBase::active_elements_end()</a>, <a class="el" href="parallel__object_8h_source.html#l00089">libMesh::ParallelObject::comm()</a>, <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>, <a class="el" href="parallel__ghost__sync_8h_source.html#l00336">libMesh::Parallel::sync_dofobject_data_by_id()</a>, and <a class="el" href="parallel__ghost__sync_8h_source.html#l00429">libMesh::Parallel::sync_element_data_by_parent_id()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mesh__refinement_8C_source.html#l01461">libMesh::MeshRefinement::_refine_elements()</a>.</p>
<div class="fragment"><div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160;{</div><div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div><div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;  libmesh_parallel_only(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">comm</a>());</div><div class="line"><a name="l01509"></a><span class="lineno"> 1509</span>&#160;</div><div class="line"><a name="l01510"></a><span class="lineno"> 1510</span>&#160;  LOG_SCOPE (<span class="stringliteral">&quot;make_elems_parallel_consistent()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div><div class="line"><a name="l01511"></a><span class="lineno"> 1511</span>&#160;</div><div class="line"><a name="l01512"></a><span class="lineno"> 1512</span>&#160;  SyncIds syncids(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, &amp;<a class="code" href="classlibMesh_1_1MeshBase.html#a263b1727104cb46623b6e522cf90e6d4">MeshBase::renumber_elem</a>);</div><div class="line"><a name="l01513"></a><span class="lineno"> 1513</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#a29c79f0c66ce48d4b3801a77b139df3b">Parallel::sync_element_data_by_parent_id</a></div><div class="line"><a name="l01514"></a><span class="lineno"> 1514</span>&#160;    (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#aefa4ded9eaf654a45ab593a0963ecbf3">active_elements_begin</a>(),</div><div class="line"><a name="l01515"></a><span class="lineno"> 1515</span>&#160;     <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#ae3f09f1b7556aef88919249861728e23">active_elements_end</a>(), syncids);</div><div class="line"><a name="l01516"></a><span class="lineno"> 1516</span>&#160;</div><div class="line"><a name="l01517"></a><span class="lineno"> 1517</span>&#160;<span class="preprocessor">#ifdef LIBMESH_ENABLE_UNIQUE_ID</span></div><div class="line"><a name="l01518"></a><span class="lineno"> 1518</span>&#160;  SyncUniqueIds&lt;Elem&gt; syncuniqueids(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, &amp;<a class="code" href="classlibMesh_1_1MeshBase.html#a61954736112b225cf323b93f57cd70ed">MeshBase::query_elem_ptr</a>);</div><div class="line"><a name="l01519"></a><span class="lineno"> 1519</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#ac7d4f06bb34625465942e6b8d10f135e">Parallel::sync_dofobject_data_by_id</a></div><div class="line"><a name="l01520"></a><span class="lineno"> 1520</span>&#160;    (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">comm</a>(), <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#aefa4ded9eaf654a45ab593a0963ecbf3">active_elements_begin</a>(),</div><div class="line"><a name="l01521"></a><span class="lineno"> 1521</span>&#160;     <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#ae3f09f1b7556aef88919249861728e23">active_elements_end</a>(), syncuniqueids);</div><div class="line"><a name="l01522"></a><span class="lineno"> 1522</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l01523"></a><span class="lineno"> 1523</span>&#160;}</div><div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a4dfeba78f759a8e42683bb559ce1e9fa"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const</div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00089">parallel_object.h:89</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_ac7d4f06bb34625465942e6b8d10f135e"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#ac7d4f06bb34625465942e6b8d10f135e">libMesh::Parallel::sync_dofobject_data_by_id</a></div><div class="ttdeci">void sync_dofobject_data_by_id(const Communicator &amp;comm, const Iterator &amp;range_begin, const Iterator &amp;range_end, SyncFunctor &amp;sync)</div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00336">parallel_ghost_sync.h:336</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_aefa4ded9eaf654a45ab593a0963ecbf3"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#aefa4ded9eaf654a45ab593a0963ecbf3">libMesh::MeshBase::active_elements_begin</a></div><div class="ttdeci">virtual element_iterator active_elements_begin()=0</div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_ae3f09f1b7556aef88919249861728e23"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#ae3f09f1b7556aef88919249861728e23">libMesh::MeshBase::active_elements_end</a></div><div class="ttdeci">virtual element_iterator active_elements_end()=0</div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a61954736112b225cf323b93f57cd70ed"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a61954736112b225cf323b93f57cd70ed">libMesh::MeshBase::query_elem_ptr</a></div><div class="ttdeci">virtual const Elem * query_elem_ptr(const dof_id_type i) const =0</div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a263b1727104cb46623b6e522cf90e6d4"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a263b1727104cb46623b6e522cf90e6d4">libMesh::MeshBase::renumber_elem</a></div><div class="ttdeci">virtual void renumber_elem(dof_id_type old_id, dof_id_type new_id)=0</div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_a29c79f0c66ce48d4b3801a77b139df3b"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#a29c79f0c66ce48d4b3801a77b139df3b">libMesh::Parallel::sync_element_data_by_parent_id</a></div><div class="ttdeci">void sync_element_data_by_parent_id(MeshBase &amp;mesh, const Iterator &amp;range_begin, const Iterator &amp;range_end, SyncFunctor &amp;sync)</div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00429">parallel_ghost_sync.h:429</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae09a612b52ccb019c89165d3bfce5773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae09a612b52ccb019c89165d3bfce5773">&#9670;&nbsp;</a></span>make_new_node_proc_ids_parallel_consistent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::make_new_node_proc_ids_parallel_consistent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assuming all processor ids on nodes touching local elements are parallel consistent, this function makes processor ids on new nodes on other processors parallel consistent as well. </p>

<p class="definition">Definition at line <a class="el" href="mesh__communication_8C_source.html#l01685">1685</a> of file <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a>.</p>

<p class="reference">References <a class="el" href="parallel__object_8h_source.html#l00089">libMesh::ParallelObject::comm()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a5173d38b4db709085b1cde698137d042">libMesh::MeshBase::element_ptr_range()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#ac266e1f5eb6ac9566ccbd7e6add6c239">libMesh::MeshBase::elements_begin()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#ae94f1bce0dc50c489c6bae9ba64d06e8">libMesh::MeshBase::elements_end()</a>, <a class="el" href="mesh__tools_8C_source.html#l01877">libMesh::MeshTools::libmesh_assert_parallel_consistent_new_node_procids()</a>, <a class="el" href="mesh__tools_8C_source.html#l01915">libMesh::MeshTools::libmesh_assert_parallel_consistent_procids&lt; Node &gt;()</a>, <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>, <a class="el" href="libmesh__augment__std__namespace_8h_source.html#l00029">std::min()</a>, <a class="el" href="elem_8h_source.html#l01979">libMesh::Elem::node_ref()</a>, <a class="el" href="elem_8h_source.html#l02130">libMesh::Elem::node_ref_range()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a151e26d7ee601e24a57f4f18a1ddec2e">libMesh::MeshBase::not_local_elements_begin()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#aa7ba43cbc4025fc5629dad18485e019d">libMesh::MeshBase::not_local_elements_end()</a>, <a class="el" href="dof__object_8h_source.html#l00717">libMesh::DofObject::processor_id()</a>, <a class="el" href="parallel__ghost__sync_8h_source.html#l00752">libMesh::Parallel::sync_node_data_by_element_id()</a>, and <a class="el" href="parallel__ghost__sync_8h_source.html#l00546">libMesh::Parallel::sync_node_data_by_element_id_once()</a>.</p>
<div class="fragment"><div class="line"><a name="l01686"></a><span class="lineno"> 1686</span>&#160;{</div><div class="line"><a name="l01687"></a><span class="lineno"> 1687</span>&#160;  LOG_SCOPE (<span class="stringliteral">&quot;make_new_node_proc_ids_parallel_consistent()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div><div class="line"><a name="l01688"></a><span class="lineno"> 1688</span>&#160;</div><div class="line"><a name="l01689"></a><span class="lineno"> 1689</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div><div class="line"><a name="l01690"></a><span class="lineno"> 1690</span>&#160;  libmesh_parallel_only(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">comm</a>());</div><div class="line"><a name="l01691"></a><span class="lineno"> 1691</span>&#160;</div><div class="line"><a name="l01692"></a><span class="lineno"> 1692</span>&#160;  <span class="comment">// When this function is called, each section of a parallelized mesh</span></div><div class="line"><a name="l01693"></a><span class="lineno"> 1693</span>&#160;  <span class="comment">// should be in the following state:</span></div><div class="line"><a name="l01694"></a><span class="lineno"> 1694</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01695"></a><span class="lineno"> 1695</span>&#160;  <span class="comment">// Local nodes should have unique authoritative ids,</span></div><div class="line"><a name="l01696"></a><span class="lineno"> 1696</span>&#160;  <span class="comment">// and new nodes should be unpartitioned.</span></div><div class="line"><a name="l01697"></a><span class="lineno"> 1697</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01698"></a><span class="lineno"> 1698</span>&#160;  <span class="comment">// New ghost nodes touching local elements should be unpartitioned.</span></div><div class="line"><a name="l01699"></a><span class="lineno"> 1699</span>&#160;</div><div class="line"><a name="l01700"></a><span class="lineno"> 1700</span>&#160;  <span class="comment">// We may not have consistent processor ids for new nodes (because a</span></div><div class="line"><a name="l01701"></a><span class="lineno"> 1701</span>&#160;  <span class="comment">// node may be old and partitioned on one processor but new and</span></div><div class="line"><a name="l01702"></a><span class="lineno"> 1702</span>&#160;  <span class="comment">// unpartitioned on another) when we start</span></div><div class="line"><a name="l01703"></a><span class="lineno"> 1703</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div><div class="line"><a name="l01704"></a><span class="lineno"> 1704</span>&#160;  <a class="code" href="namespacelibMesh_1_1MeshTools.html#afa9230889a01ee0f9489a3d3eb4d70c2">MeshTools::libmesh_assert_parallel_consistent_procids&lt;Node&gt;</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div><div class="line"><a name="l01705"></a><span class="lineno"> 1705</span>&#160;  <span class="comment">// MeshTools::libmesh_assert_parallel_consistent_new_node_procids(mesh);</span></div><div class="line"><a name="l01706"></a><span class="lineno"> 1706</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l01707"></a><span class="lineno"> 1707</span>&#160;</div><div class="line"><a name="l01708"></a><span class="lineno"> 1708</span>&#160;  <span class="comment">// We have two kinds of new nodes.  *NEW* nodes are unpartitioned on</span></div><div class="line"><a name="l01709"></a><span class="lineno"> 1709</span>&#160;  <span class="comment">// all processors: we need to use a id-independent (i.e. dumb)</span></div><div class="line"><a name="l01710"></a><span class="lineno"> 1710</span>&#160;  <span class="comment">// heuristic to partition them.  But &quot;new&quot; nodes are newly created</span></div><div class="line"><a name="l01711"></a><span class="lineno"> 1711</span>&#160;  <span class="comment">// on some processors (when ghost elements are refined) yet</span></div><div class="line"><a name="l01712"></a><span class="lineno"> 1712</span>&#160;  <span class="comment">// correspond to existing nodes on other processors: we need to use</span></div><div class="line"><a name="l01713"></a><span class="lineno"> 1713</span>&#160;  <span class="comment">// the existing processor id for them.</span></div><div class="line"><a name="l01714"></a><span class="lineno"> 1714</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01715"></a><span class="lineno"> 1715</span>&#160;  <span class="comment">// A node which is &quot;new&quot; on one processor will be associated with at</span></div><div class="line"><a name="l01716"></a><span class="lineno"> 1716</span>&#160;  <span class="comment">// least one ghost element, and we can just query that ghost</span></div><div class="line"><a name="l01717"></a><span class="lineno"> 1717</span>&#160;  <span class="comment">// element&#39;s owner to find out the correct processor id.</span></div><div class="line"><a name="l01718"></a><span class="lineno"> 1718</span>&#160;</div><div class="line"><a name="l01719"></a><span class="lineno"> 1719</span>&#160;  <span class="keyword">auto</span> node_unpartitioned =</div><div class="line"><a name="l01720"></a><span class="lineno"> 1720</span>&#160;    [](<span class="keyword">const</span> <a class="code" href="classlibMesh_1_1Elem.html">Elem</a> * elem, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> local_node_num)</div><div class="line"><a name="l01721"></a><span class="lineno"> 1721</span>&#160;    { <span class="keywordflow">return</span> elem-&gt;<a class="code" href="classlibMesh_1_1Elem.html#a30f42f08e1695d2db051064346c2a654">node_ref</a>(local_node_num).<a class="code" href="classlibMesh_1_1DofObject.html#a754f2866ec9d8a49a02a68a32e7aa518">processor_id</a>() ==</div><div class="line"><a name="l01722"></a><span class="lineno"> 1722</span>&#160;        <a class="code" href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">DofObject::invalid_processor_id</a>; };</div><div class="line"><a name="l01723"></a><span class="lineno"> 1723</span>&#160;</div><div class="line"><a name="l01724"></a><span class="lineno"> 1724</span>&#160;  SyncProcIds sync(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div><div class="line"><a name="l01725"></a><span class="lineno"> 1725</span>&#160;</div><div class="line"><a name="l01726"></a><span class="lineno"> 1726</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#a690437fd4e60ad2cedf64948c3f21519">sync_node_data_by_element_id_once</a></div><div class="line"><a name="l01727"></a><span class="lineno"> 1727</span>&#160;    (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a151e26d7ee601e24a57f4f18a1ddec2e">not_local_elements_begin</a>(),</div><div class="line"><a name="l01728"></a><span class="lineno"> 1728</span>&#160;     <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#aa7ba43cbc4025fc5629dad18485e019d">not_local_elements_end</a>(), <a class="code" href="structlibMesh_1_1Parallel_1_1SyncEverything.html">Parallel::SyncEverything</a>(),</div><div class="line"><a name="l01729"></a><span class="lineno"> 1729</span>&#160;     node_unpartitioned, sync);</div><div class="line"><a name="l01730"></a><span class="lineno"> 1730</span>&#160;</div><div class="line"><a name="l01731"></a><span class="lineno"> 1731</span>&#160;  <span class="comment">// Nodes should now be unpartitioned iff they are truly new; those</span></div><div class="line"><a name="l01732"></a><span class="lineno"> 1732</span>&#160;  <span class="comment">// are the *only* nodes we will touch.</span></div><div class="line"><a name="l01733"></a><span class="lineno"> 1733</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div><div class="line"><a name="l01734"></a><span class="lineno"> 1734</span>&#160;  <a class="code" href="namespacelibMesh_1_1MeshTools.html#a2699035cfb89b82a96bac61ad9ae291f">MeshTools::libmesh_assert_parallel_consistent_new_node_procids</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div><div class="line"><a name="l01735"></a><span class="lineno"> 1735</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l01736"></a><span class="lineno"> 1736</span>&#160;</div><div class="line"><a name="l01737"></a><span class="lineno"> 1737</span>&#160;  NodeWasNew node_was_new(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div><div class="line"><a name="l01738"></a><span class="lineno"> 1738</span>&#160;</div><div class="line"><a name="l01739"></a><span class="lineno"> 1739</span>&#160;  <span class="comment">// Set the lowest processor id we can on truly new nodes</span></div><div class="line"><a name="l01740"></a><span class="lineno"> 1740</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a5173d38b4db709085b1cde698137d042">element_ptr_range</a>())</div><div class="line"><a name="l01741"></a><span class="lineno"> 1741</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; node : elem-&gt;<a class="code" href="classlibMesh_1_1Elem.html#a648b34a7475203667c75597913822fdf">node_ref_range</a>())</div><div class="line"><a name="l01742"></a><span class="lineno"> 1742</span>&#160;      <span class="keywordflow">if</span> (node_was_new.was_new.count(&amp;node))</div><div class="line"><a name="l01743"></a><span class="lineno"> 1743</span>&#160;        {</div><div class="line"><a name="l01744"></a><span class="lineno"> 1744</span>&#160;          <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> &amp; pid = node.processor_id();</div><div class="line"><a name="l01745"></a><span class="lineno"> 1745</span>&#160;          pid = <a class="code" href="namespacestd.html#a4444b32c7044d9b34125eaebd070a0e3">std::min</a>(pid, elem-&gt;<a class="code" href="classlibMesh_1_1DofObject.html#a754f2866ec9d8a49a02a68a32e7aa518">processor_id</a>());</div><div class="line"><a name="l01746"></a><span class="lineno"> 1746</span>&#160;        }</div><div class="line"><a name="l01747"></a><span class="lineno"> 1747</span>&#160;</div><div class="line"><a name="l01748"></a><span class="lineno"> 1748</span>&#160;  <span class="comment">// Then finally see if other processors have a lower option</span></div><div class="line"><a name="l01749"></a><span class="lineno"> 1749</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#a78a93cd4ce160f40c758f96e2cadbe25">Parallel::sync_node_data_by_element_id</a></div><div class="line"><a name="l01750"></a><span class="lineno"> 1750</span>&#160;    (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#ac266e1f5eb6ac9566ccbd7e6add6c239">elements_begin</a>(), <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#ae94f1bce0dc50c489c6bae9ba64d06e8">elements_end</a>(),</div><div class="line"><a name="l01751"></a><span class="lineno"> 1751</span>&#160;     ElemNodesMaybeNew(), node_was_new, sync);</div><div class="line"><a name="l01752"></a><span class="lineno"> 1752</span>&#160;</div><div class="line"><a name="l01753"></a><span class="lineno"> 1753</span>&#160;  <span class="comment">// We should have consistent processor ids when we&#39;re done.</span></div><div class="line"><a name="l01754"></a><span class="lineno"> 1754</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div><div class="line"><a name="l01755"></a><span class="lineno"> 1755</span>&#160;  <a class="code" href="namespacelibMesh_1_1MeshTools.html#afa9230889a01ee0f9489a3d3eb4d70c2">MeshTools::libmesh_assert_parallel_consistent_procids&lt;Node&gt;</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div><div class="line"><a name="l01756"></a><span class="lineno"> 1756</span>&#160;  <a class="code" href="namespacelibMesh_1_1MeshTools.html#a2699035cfb89b82a96bac61ad9ae291f">MeshTools::libmesh_assert_parallel_consistent_new_node_procids</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div><div class="line"><a name="l01757"></a><span class="lineno"> 1757</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l01758"></a><span class="lineno"> 1758</span>&#160;}</div><div class="ttc" id="classlibMesh_1_1MeshBase_html_aa7ba43cbc4025fc5629dad18485e019d"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#aa7ba43cbc4025fc5629dad18485e019d">libMesh::MeshBase::not_local_elements_end</a></div><div class="ttdeci">virtual element_iterator not_local_elements_end()=0</div></div>
<div class="ttc" id="classlibMesh_1_1Elem_html"><div class="ttname"><a href="classlibMesh_1_1Elem.html">libMesh::Elem</a></div><div class="ttdoc">The base class for all geometric element types. </div><div class="ttdef"><b>Definition:</b> <a href="elem_8h_source.html#l00100">elem.h:100</a></div></div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
<div class="ttc" id="namespacelibMesh_html_afebcb3616f8c81cda531dec404f2420d"><div class="ttname"><a href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">libMesh::processor_id_type</a></div><div class="ttdeci">uint8_t processor_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00099">id_types.h:99</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_a2699035cfb89b82a96bac61ad9ae291f"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#a2699035cfb89b82a96bac61ad9ae291f">libMesh::MeshTools::libmesh_assert_parallel_consistent_new_node_procids</a></div><div class="ttdeci">void libmesh_assert_parallel_consistent_new_node_procids(const MeshBase &amp;mesh)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l01877">mesh_tools.C:1877</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a4dfeba78f759a8e42683bb559ce1e9fa"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const</div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00089">parallel_object.h:89</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_ac266e1f5eb6ac9566ccbd7e6add6c239"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#ac266e1f5eb6ac9566ccbd7e6add6c239">libMesh::MeshBase::elements_begin</a></div><div class="ttdeci">virtual element_iterator elements_begin()=0</div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a5173d38b4db709085b1cde698137d042"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a5173d38b4db709085b1cde698137d042">libMesh::MeshBase::element_ptr_range</a></div><div class="ttdeci">virtual SimpleRange&lt; element_iterator &gt; element_ptr_range()=0</div></div>
<div class="ttc" id="classlibMesh_1_1Elem_html_a30f42f08e1695d2db051064346c2a654"><div class="ttname"><a href="classlibMesh_1_1Elem.html#a30f42f08e1695d2db051064346c2a654">libMesh::Elem::node_ref</a></div><div class="ttdeci">const Node &amp; node_ref(const unsigned int i) const</div><div class="ttdef"><b>Definition:</b> <a href="elem_8h_source.html#l01979">elem.h:1979</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_aa65deab833c8b1802790cd43ab1b6ee4"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#aa65deab833c8b1802790cd43ab1b6ee4">libMesh::DofObject::invalid_processor_id</a></div><div class="ttdeci">static const processor_id_type invalid_processor_id</div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00358">dof_object.h:358</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_a78a93cd4ce160f40c758f96e2cadbe25"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#a78a93cd4ce160f40c758f96e2cadbe25">libMesh::Parallel::sync_node_data_by_element_id</a></div><div class="ttdeci">void sync_node_data_by_element_id(MeshBase &amp;mesh, const MeshBase::const_element_iterator &amp;range_begin, const MeshBase::const_element_iterator &amp;range_end, const ElemCheckFunctor &amp;elem_check, const NodeCheckFunctor &amp;node_check, SyncFunctor &amp;sync)</div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00752">parallel_ghost_sync.h:752</a></div></div>
<div class="ttc" id="structlibMesh_1_1Parallel_1_1SyncEverything_html"><div class="ttname"><a href="structlibMesh_1_1Parallel_1_1SyncEverything.html">libMesh::Parallel::SyncEverything</a></div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00217">parallel_ghost_sync.h:217</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_ae94f1bce0dc50c489c6bae9ba64d06e8"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#ae94f1bce0dc50c489c6bae9ba64d06e8">libMesh::MeshBase::elements_end</a></div><div class="ttdeci">virtual element_iterator elements_end()=0</div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_afa9230889a01ee0f9489a3d3eb4d70c2"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#afa9230889a01ee0f9489a3d3eb4d70c2">libMesh::MeshTools::libmesh_assert_parallel_consistent_procids&lt; Node &gt;</a></div><div class="ttdeci">void libmesh_assert_parallel_consistent_procids&lt; Node &gt;(const MeshBase &amp;mesh)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l01915">mesh_tools.C:1915</a></div></div>
<div class="ttc" id="classlibMesh_1_1Elem_html_a648b34a7475203667c75597913822fdf"><div class="ttname"><a href="classlibMesh_1_1Elem.html#a648b34a7475203667c75597913822fdf">libMesh::Elem::node_ref_range</a></div><div class="ttdeci">SimpleRange&lt; NodeRefIter &gt; node_ref_range()</div><div class="ttdef"><b>Definition:</b> <a href="elem_8h_source.html#l02130">elem.h:2130</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_a690437fd4e60ad2cedf64948c3f21519"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#a690437fd4e60ad2cedf64948c3f21519">libMesh::Parallel::sync_node_data_by_element_id_once</a></div><div class="ttdeci">bool sync_node_data_by_element_id_once(MeshBase &amp;mesh, const MeshBase::const_element_iterator &amp;range_begin, const MeshBase::const_element_iterator &amp;range_end, const ElemCheckFunctor &amp;elem_check, const NodeCheckFunctor &amp;node_check, SyncFunctor &amp;sync)</div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00546">parallel_ghost_sync.h:546</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a151e26d7ee601e24a57f4f18a1ddec2e"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a151e26d7ee601e24a57f4f18a1ddec2e">libMesh::MeshBase::not_local_elements_begin</a></div><div class="ttdeci">virtual element_iterator not_local_elements_begin()=0</div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_a754f2866ec9d8a49a02a68a32e7aa518"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#a754f2866ec9d8a49a02a68a32e7aa518">libMesh::DofObject::processor_id</a></div><div class="ttdeci">processor_id_type processor_id() const</div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00717">dof_object.h:717</a></div></div>
<div class="ttc" id="namespacestd_html_a4444b32c7044d9b34125eaebd070a0e3"><div class="ttname"><a href="namespacestd.html#a4444b32c7044d9b34125eaebd070a0e3">std::min</a></div><div class="ttdeci">long double min(long double a, double b)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__augment__std__namespace_8h_source.html#l00029">libmesh_augment_std_namespace.h:29</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="afa47da82381f82ded5e3f0bedb0dbd5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa47da82381f82ded5e3f0bedb0dbd5b">&#9670;&nbsp;</a></span>make_new_nodes_parallel_consistent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::make_new_nodes_parallel_consistent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy processor_ids and ids on new nodes from their local processors. </p>

<p class="definition">Definition at line <a class="el" href="mesh__communication_8C_source.html#l01805">1805</a> of file <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a>.</p>

<p class="reference">References <a class="el" href="parallel__object_8h_source.html#l00089">libMesh::ParallelObject::comm()</a>, <a class="el" href="mesh__tools_8C_source.html#l02259">libMesh::MeshTools::correct_node_proc_ids()</a>, and <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>.</p>

<p class="reference">Referenced by <a class="el" href="mesh__refinement_8C_source.html#l01461">libMesh::MeshRefinement::_refine_elements()</a>.</p>
<div class="fragment"><div class="line"><a name="l01806"></a><span class="lineno"> 1806</span>&#160;{</div><div class="line"><a name="l01807"></a><span class="lineno"> 1807</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div><div class="line"><a name="l01808"></a><span class="lineno"> 1808</span>&#160;  libmesh_parallel_only(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">comm</a>());</div><div class="line"><a name="l01809"></a><span class="lineno"> 1809</span>&#160;</div><div class="line"><a name="l01810"></a><span class="lineno"> 1810</span>&#160;  <span class="comment">// When this function is called, each section of a parallelized mesh</span></div><div class="line"><a name="l01811"></a><span class="lineno"> 1811</span>&#160;  <span class="comment">// should be in the following state:</span></div><div class="line"><a name="l01812"></a><span class="lineno"> 1812</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01813"></a><span class="lineno"> 1813</span>&#160;  <span class="comment">// All nodes should have the exact same physical location on every</span></div><div class="line"><a name="l01814"></a><span class="lineno"> 1814</span>&#160;  <span class="comment">// processor where they exist.</span></div><div class="line"><a name="l01815"></a><span class="lineno"> 1815</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01816"></a><span class="lineno"> 1816</span>&#160;  <span class="comment">// Local nodes should have unique authoritative ids,</span></div><div class="line"><a name="l01817"></a><span class="lineno"> 1817</span>&#160;  <span class="comment">// and new nodes should be unpartitioned.</span></div><div class="line"><a name="l01818"></a><span class="lineno"> 1818</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01819"></a><span class="lineno"> 1819</span>&#160;  <span class="comment">// New ghost nodes touching local elements should be unpartitioned.</span></div><div class="line"><a name="l01820"></a><span class="lineno"> 1820</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01821"></a><span class="lineno"> 1821</span>&#160;  <span class="comment">// New ghost nodes should have ids which are either already correct</span></div><div class="line"><a name="l01822"></a><span class="lineno"> 1822</span>&#160;  <span class="comment">// or which are in the &quot;unpartitioned&quot; id space.</span></div><div class="line"><a name="l01823"></a><span class="lineno"> 1823</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01824"></a><span class="lineno"> 1824</span>&#160;  <span class="comment">// Non-new nodes should have correct ids and processor ids already.</span></div><div class="line"><a name="l01825"></a><span class="lineno"> 1825</span>&#160;</div><div class="line"><a name="l01826"></a><span class="lineno"> 1826</span>&#160;  <span class="comment">// First, let&#39;s sync up new nodes&#39; processor ids.</span></div><div class="line"><a name="l01827"></a><span class="lineno"> 1827</span>&#160;</div><div class="line"><a name="l01828"></a><span class="lineno"> 1828</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1MeshCommunication.html#ae09a612b52ccb019c89165d3bfce5773">make_new_node_proc_ids_parallel_consistent</a>(mesh);</div><div class="line"><a name="l01829"></a><span class="lineno"> 1829</span>&#160;</div><div class="line"><a name="l01830"></a><span class="lineno"> 1830</span>&#160;  <span class="comment">// Second, sync up dofobject ids.</span></div><div class="line"><a name="l01831"></a><span class="lineno"> 1831</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1MeshCommunication.html#ab0eae4e562c489db701776c3970e772b">make_node_ids_parallel_consistent</a>(mesh);</div><div class="line"><a name="l01832"></a><span class="lineno"> 1832</span>&#160;</div><div class="line"><a name="l01833"></a><span class="lineno"> 1833</span>&#160;  <span class="comment">// Third, sync up dofobject unique_ids if applicable.</span></div><div class="line"><a name="l01834"></a><span class="lineno"> 1834</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1MeshCommunication.html#a0e83bbe1c114c9de7be87927f7db9e85">make_node_unique_ids_parallel_consistent</a>(mesh);</div><div class="line"><a name="l01835"></a><span class="lineno"> 1835</span>&#160;</div><div class="line"><a name="l01836"></a><span class="lineno"> 1836</span>&#160;  <span class="comment">// Finally, correct the processor ids to make DofMap happy</span></div><div class="line"><a name="l01837"></a><span class="lineno"> 1837</span>&#160;  <a class="code" href="namespacelibMesh_1_1MeshTools.html#aca8746be5247c3f44a3b0797b5ed88f0">MeshTools::correct_node_proc_ids</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div><div class="line"><a name="l01838"></a><span class="lineno"> 1838</span>&#160;}</div><div class="ttc" id="classlibMesh_1_1MeshCommunication_html_a0e83bbe1c114c9de7be87927f7db9e85"><div class="ttname"><a href="classlibMesh_1_1MeshCommunication.html#a0e83bbe1c114c9de7be87927f7db9e85">libMesh::MeshCommunication::make_node_unique_ids_parallel_consistent</a></div><div class="ttdeci">void make_node_unique_ids_parallel_consistent(MeshBase &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01481">mesh_communication.C:1481</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_aca8746be5247c3f44a3b0797b5ed88f0"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#aca8746be5247c3f44a3b0797b5ed88f0">libMesh::MeshTools::correct_node_proc_ids</a></div><div class="ttdeci">void correct_node_proc_ids(MeshBase &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l02259">mesh_tools.C:2259</a></div></div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a4dfeba78f759a8e42683bb559ce1e9fa"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const</div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00089">parallel_object.h:89</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshCommunication_html_ae09a612b52ccb019c89165d3bfce5773"><div class="ttname"><a href="classlibMesh_1_1MeshCommunication.html#ae09a612b52ccb019c89165d3bfce5773">libMesh::MeshCommunication::make_new_node_proc_ids_parallel_consistent</a></div><div class="ttdeci">void make_new_node_proc_ids_parallel_consistent(MeshBase &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01685">mesh_communication.C:1685</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshCommunication_html_ab0eae4e562c489db701776c3970e772b"><div class="ttname"><a href="classlibMesh_1_1MeshCommunication.html#ab0eae4e562c489db701776c3970e772b">libMesh::MeshCommunication::make_node_ids_parallel_consistent</a></div><div class="ttdeci">void make_node_ids_parallel_consistent(MeshBase &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01452">mesh_communication.C:1452</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab0eae4e562c489db701776c3970e772b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0eae4e562c489db701776c3970e772b">&#9670;&nbsp;</a></span>make_node_ids_parallel_consistent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::make_node_ids_parallel_consistent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assuming all ids on local nodes are globally unique, and assuming all processor ids are parallel consistent, this function makes all other ids parallel consistent. </p>

<p class="definition">Definition at line <a class="el" href="mesh__communication_8C_source.html#l01452">1452</a> of file <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a>.</p>

<p class="reference">References <a class="el" href="parallel__object_8h_source.html#l00089">libMesh::ParallelObject::comm()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#ac266e1f5eb6ac9566ccbd7e6add6c239">libMesh::MeshBase::elements_begin()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#ae94f1bce0dc50c489c6bae9ba64d06e8">libMesh::MeshBase::elements_end()</a>, <a class="el" href="mesh__tools_8C_source.html#l01826">libMesh::MeshTools::libmesh_assert_topology_consistent_procids&lt; Node &gt;()</a>, <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>, and <a class="el" href="parallel__ghost__sync_8h_source.html#l00752">libMesh::Parallel::sync_node_data_by_element_id()</a>.</p>
<div class="fragment"><div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;{</div><div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div><div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160;  libmesh_parallel_only(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">comm</a>());</div><div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;</div><div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160;  <span class="comment">// We need to agree on which processor owns every node, but we can&#39;t</span></div><div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;  <span class="comment">// easily assert that here because we don&#39;t currently agree on which</span></div><div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;  <span class="comment">// id every node has, and some of our temporary ids on unrelated</span></div><div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;  <span class="comment">// nodes will &quot;overlap&quot;.</span></div><div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160;<span class="comment">//#ifdef DEBUG</span></div><div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;<span class="comment">//  MeshTools::libmesh_assert_parallel_consistent_procids&lt;Node&gt; (mesh);</span></div><div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;<span class="comment">//#endif // DEBUG</span></div><div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;</div><div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;  LOG_SCOPE (<span class="stringliteral">&quot;make_node_ids_parallel_consistent()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div><div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160;</div><div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;  SyncNodeIds syncids(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div><div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#a78a93cd4ce160f40c758f96e2cadbe25">Parallel::sync_node_data_by_element_id</a></div><div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;    (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#ac266e1f5eb6ac9566ccbd7e6add6c239">elements_begin</a>(), <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#ae94f1bce0dc50c489c6bae9ba64d06e8">elements_end</a>(),</div><div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;     <a class="code" href="structlibMesh_1_1Parallel_1_1SyncEverything.html">Parallel::SyncEverything</a>(), <a class="code" href="structlibMesh_1_1Parallel_1_1SyncEverything.html">Parallel::SyncEverything</a>(), syncids);</div><div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;</div><div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160;  <span class="comment">// At this point, with both ids and processor ids synced, we can</span></div><div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;  <span class="comment">// finally check for topological consistency of node processor ids.</span></div><div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div><div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;  <a class="code" href="namespacelibMesh_1_1MeshTools.html#ad7fa726589463cf24cee5f9f3c140ba0">MeshTools::libmesh_assert_topology_consistent_procids&lt;Node&gt;</a> (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div><div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;}</div><div class="ttc" id="namespacelibMesh_1_1MeshTools_html_ad7fa726589463cf24cee5f9f3c140ba0"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#ad7fa726589463cf24cee5f9f3c140ba0">libMesh::MeshTools::libmesh_assert_topology_consistent_procids&lt; Node &gt;</a></div><div class="ttdeci">void libmesh_assert_topology_consistent_procids&lt; Node &gt;(const MeshBase &amp;mesh)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l01826">mesh_tools.C:1826</a></div></div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a4dfeba78f759a8e42683bb559ce1e9fa"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const</div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00089">parallel_object.h:89</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_ac266e1f5eb6ac9566ccbd7e6add6c239"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#ac266e1f5eb6ac9566ccbd7e6add6c239">libMesh::MeshBase::elements_begin</a></div><div class="ttdeci">virtual element_iterator elements_begin()=0</div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_a78a93cd4ce160f40c758f96e2cadbe25"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#a78a93cd4ce160f40c758f96e2cadbe25">libMesh::Parallel::sync_node_data_by_element_id</a></div><div class="ttdeci">void sync_node_data_by_element_id(MeshBase &amp;mesh, const MeshBase::const_element_iterator &amp;range_begin, const MeshBase::const_element_iterator &amp;range_end, const ElemCheckFunctor &amp;elem_check, const NodeCheckFunctor &amp;node_check, SyncFunctor &amp;sync)</div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00752">parallel_ghost_sync.h:752</a></div></div>
<div class="ttc" id="structlibMesh_1_1Parallel_1_1SyncEverything_html"><div class="ttname"><a href="structlibMesh_1_1Parallel_1_1SyncEverything.html">libMesh::Parallel::SyncEverything</a></div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00217">parallel_ghost_sync.h:217</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_ae94f1bce0dc50c489c6bae9ba64d06e8"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#ae94f1bce0dc50c489c6bae9ba64d06e8">libMesh::MeshBase::elements_end</a></div><div class="ttdeci">virtual element_iterator elements_end()=0</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab67880939a7d98e9cb3e7a6425a4d7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67880939a7d98e9cb3e7a6425a4d7ec">&#9670;&nbsp;</a></span>make_node_proc_ids_parallel_consistent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::make_node_proc_ids_parallel_consistent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assuming all processor ids on nodes touching local elements are parallel consistent, this function makes all other processor ids parallel consistent as well. </p>

<p class="definition">Definition at line <a class="el" href="mesh__communication_8C_source.html#l01656">1656</a> of file <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a>.</p>

<p class="reference">References <a class="el" href="parallel__object_8h_source.html#l00089">libMesh::ParallelObject::comm()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#ac266e1f5eb6ac9566ccbd7e6add6c239">libMesh::MeshBase::elements_begin()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#ae94f1bce0dc50c489c6bae9ba64d06e8">libMesh::MeshBase::elements_end()</a>, <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>, and <a class="el" href="parallel__ghost__sync_8h_source.html#l00752">libMesh::Parallel::sync_node_data_by_element_id()</a>.</p>
<div class="fragment"><div class="line"><a name="l01657"></a><span class="lineno"> 1657</span>&#160;{</div><div class="line"><a name="l01658"></a><span class="lineno"> 1658</span>&#160;  LOG_SCOPE (<span class="stringliteral">&quot;make_node_proc_ids_parallel_consistent()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div><div class="line"><a name="l01659"></a><span class="lineno"> 1659</span>&#160;</div><div class="line"><a name="l01660"></a><span class="lineno"> 1660</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div><div class="line"><a name="l01661"></a><span class="lineno"> 1661</span>&#160;  libmesh_parallel_only(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">comm</a>());</div><div class="line"><a name="l01662"></a><span class="lineno"> 1662</span>&#160;</div><div class="line"><a name="l01663"></a><span class="lineno"> 1663</span>&#160;  <span class="comment">// When this function is called, each section of a parallelized mesh</span></div><div class="line"><a name="l01664"></a><span class="lineno"> 1664</span>&#160;  <span class="comment">// should be in the following state:</span></div><div class="line"><a name="l01665"></a><span class="lineno"> 1665</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01666"></a><span class="lineno"> 1666</span>&#160;  <span class="comment">// All nodes should have the exact same physical location on every</span></div><div class="line"><a name="l01667"></a><span class="lineno"> 1667</span>&#160;  <span class="comment">// processor where they exist.</span></div><div class="line"><a name="l01668"></a><span class="lineno"> 1668</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01669"></a><span class="lineno"> 1669</span>&#160;  <span class="comment">// Local nodes should have unique authoritative ids,</span></div><div class="line"><a name="l01670"></a><span class="lineno"> 1670</span>&#160;  <span class="comment">// and processor ids consistent with all processors which own</span></div><div class="line"><a name="l01671"></a><span class="lineno"> 1671</span>&#160;  <span class="comment">// an element touching them.</span></div><div class="line"><a name="l01672"></a><span class="lineno"> 1672</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01673"></a><span class="lineno"> 1673</span>&#160;  <span class="comment">// Ghost nodes touching local elements should have processor ids</span></div><div class="line"><a name="l01674"></a><span class="lineno"> 1674</span>&#160;  <span class="comment">// consistent with all processors which own an element touching</span></div><div class="line"><a name="l01675"></a><span class="lineno"> 1675</span>&#160;  <span class="comment">// them.</span></div><div class="line"><a name="l01676"></a><span class="lineno"> 1676</span>&#160;  SyncProcIds sync(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div><div class="line"><a name="l01677"></a><span class="lineno"> 1677</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#a78a93cd4ce160f40c758f96e2cadbe25">Parallel::sync_node_data_by_element_id</a></div><div class="line"><a name="l01678"></a><span class="lineno"> 1678</span>&#160;    (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#ac266e1f5eb6ac9566ccbd7e6add6c239">elements_begin</a>(), <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#ae94f1bce0dc50c489c6bae9ba64d06e8">elements_end</a>(),</div><div class="line"><a name="l01679"></a><span class="lineno"> 1679</span>&#160;     <a class="code" href="structlibMesh_1_1Parallel_1_1SyncEverything.html">Parallel::SyncEverything</a>(), <a class="code" href="structlibMesh_1_1Parallel_1_1SyncEverything.html">Parallel::SyncEverything</a>(), sync);</div><div class="line"><a name="l01680"></a><span class="lineno"> 1680</span>&#160;}</div><div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a4dfeba78f759a8e42683bb559ce1e9fa"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const</div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00089">parallel_object.h:89</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_ac266e1f5eb6ac9566ccbd7e6add6c239"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#ac266e1f5eb6ac9566ccbd7e6add6c239">libMesh::MeshBase::elements_begin</a></div><div class="ttdeci">virtual element_iterator elements_begin()=0</div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_a78a93cd4ce160f40c758f96e2cadbe25"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#a78a93cd4ce160f40c758f96e2cadbe25">libMesh::Parallel::sync_node_data_by_element_id</a></div><div class="ttdeci">void sync_node_data_by_element_id(MeshBase &amp;mesh, const MeshBase::const_element_iterator &amp;range_begin, const MeshBase::const_element_iterator &amp;range_end, const ElemCheckFunctor &amp;elem_check, const NodeCheckFunctor &amp;node_check, SyncFunctor &amp;sync)</div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00752">parallel_ghost_sync.h:752</a></div></div>
<div class="ttc" id="structlibMesh_1_1Parallel_1_1SyncEverything_html"><div class="ttname"><a href="structlibMesh_1_1Parallel_1_1SyncEverything.html">libMesh::Parallel::SyncEverything</a></div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00217">parallel_ghost_sync.h:217</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_ae94f1bce0dc50c489c6bae9ba64d06e8"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#ae94f1bce0dc50c489c6bae9ba64d06e8">libMesh::MeshBase::elements_end</a></div><div class="ttdeci">virtual element_iterator elements_end()=0</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0e83bbe1c114c9de7be87927f7db9e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e83bbe1c114c9de7be87927f7db9e85">&#9670;&nbsp;</a></span>make_node_unique_ids_parallel_consistent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::make_node_unique_ids_parallel_consistent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assuming all unique_ids on local nodes are globally unique, and assuming all processor ids are parallel consistent, this function makes all ghost unique_ids parallel consistent. </p>

<p class="definition">Definition at line <a class="el" href="mesh__communication_8C_source.html#l01481">1481</a> of file <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a>.</p>

<p class="reference">References <a class="el" href="parallel__object_8h_source.html#l00089">libMesh::ParallelObject::comm()</a>, <a class="el" href="libmesh__common_8h_source.html#l00461">libMesh::libmesh_ignore()</a>, <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a3ab1d28a6ea1e8028ce0c06e11cfb68d">libMesh::MeshBase::nodes_begin()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a47575077b6ad40d4f05292634f7615f8">libMesh::MeshBase::nodes_end()</a>, and <a class="el" href="parallel__ghost__sync_8h_source.html#l00336">libMesh::Parallel::sync_dofobject_data_by_id()</a>.</p>

<p class="reference">Referenced by <a class="el" href="boundary__info_8C_source.html#l00347">libMesh::BoundaryInfo::add_elements()</a>, and <a class="el" href="nemesis__io_8C_source.html#l00148">libMesh::Nemesis_IO::read()</a>.</p>
<div class="fragment"><div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;{</div><div class="line"><a name="l01483"></a><span class="lineno"> 1483</span>&#160;  <span class="comment">// Avoid unused variable warnings if unique ids aren&#39;t enabled.</span></div><div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160;  <a class="code" href="namespacelibMesh.html#a43f45640aab1af26176e69592c666432">libmesh_ignore</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div><div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160;</div><div class="line"><a name="l01486"></a><span class="lineno"> 1486</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div><div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;  libmesh_parallel_only(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">comm</a>());</div><div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;</div><div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160;<span class="preprocessor">#ifdef LIBMESH_ENABLE_UNIQUE_ID</span></div><div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;  LOG_SCOPE (<span class="stringliteral">&quot;make_node_unique_ids_parallel_consistent()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div><div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;</div><div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;  SyncUniqueIds&lt;Node&gt; syncuniqueids(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, &amp;<a class="code" href="classlibMesh_1_1MeshBase.html#a88d3228c36aa7b481f0f5d77f95bd021">MeshBase::query_node_ptr</a>);</div><div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#ac7d4f06bb34625465942e6b8d10f135e">Parallel::sync_dofobject_data_by_id</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">comm</a>(),</div><div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;                                      <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a3ab1d28a6ea1e8028ce0c06e11cfb68d">nodes_begin</a>(),</div><div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160;                                      <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a47575077b6ad40d4f05292634f7615f8">nodes_end</a>(),</div><div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160;                                      syncuniqueids);</div><div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160;</div><div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;}</div><div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a4dfeba78f759a8e42683bb559ce1e9fa"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const</div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00089">parallel_object.h:89</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a3ab1d28a6ea1e8028ce0c06e11cfb68d"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a3ab1d28a6ea1e8028ce0c06e11cfb68d">libMesh::MeshBase::nodes_begin</a></div><div class="ttdeci">virtual node_iterator nodes_begin()=0</div></div>
<div class="ttc" id="namespacelibMesh_html_a43f45640aab1af26176e69592c666432"><div class="ttname"><a href="namespacelibMesh.html#a43f45640aab1af26176e69592c666432">libMesh::libmesh_ignore</a></div><div class="ttdeci">void libmesh_ignore(const Args &amp;...)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00461">libmesh_common.h:461</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a88d3228c36aa7b481f0f5d77f95bd021"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a88d3228c36aa7b481f0f5d77f95bd021">libMesh::MeshBase::query_node_ptr</a></div><div class="ttdeci">virtual const Node * query_node_ptr(const dof_id_type i) const =0</div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_ac7d4f06bb34625465942e6b8d10f135e"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#ac7d4f06bb34625465942e6b8d10f135e">libMesh::Parallel::sync_dofobject_data_by_id</a></div><div class="ttdeci">void sync_dofobject_data_by_id(const Communicator &amp;comm, const Iterator &amp;range_begin, const Iterator &amp;range_end, SyncFunctor &amp;sync)</div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00336">parallel_ghost_sync.h:336</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a47575077b6ad40d4f05292634f7615f8"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a47575077b6ad40d4f05292634f7615f8">libMesh::MeshBase::nodes_end</a></div><div class="ttdeci">virtual node_iterator nodes_end()=0</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac76dd6bc5f023e8836591ca42a9caa94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76dd6bc5f023e8836591ca42a9caa94">&#9670;&nbsp;</a></span>make_nodes_parallel_consistent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::make_nodes_parallel_consistent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy processor_ids and ids on ghost nodes from their local processors. This is useful for code which wants to add nodes to a distributed mesh. </p>

<p class="definition">Definition at line <a class="el" href="mesh__communication_8C_source.html#l01763">1763</a> of file <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a>.</p>

<p class="reference">References <a class="el" href="parallel__object_8h_source.html#l00089">libMesh::ParallelObject::comm()</a>, <a class="el" href="mesh__tools_8C_source.html#l02259">libMesh::MeshTools::correct_node_proc_ids()</a>, and <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>.</p>

<p class="reference">Referenced by <a class="el" href="mesh__refinement_8C_source.html#l01335">libMesh::MeshRefinement::_coarsen_elements()</a>, <a class="el" href="unstructured__mesh_8C_source.html#l00969">libMesh::UnstructuredMesh::all_second_order()</a>, and <a class="el" href="mesh__modification_8C_source.html#l00271">libMesh::MeshTools::Modification::all_tri()</a>.</p>
<div class="fragment"><div class="line"><a name="l01764"></a><span class="lineno"> 1764</span>&#160;{</div><div class="line"><a name="l01765"></a><span class="lineno"> 1765</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div><div class="line"><a name="l01766"></a><span class="lineno"> 1766</span>&#160;  libmesh_parallel_only(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">comm</a>());</div><div class="line"><a name="l01767"></a><span class="lineno"> 1767</span>&#160;</div><div class="line"><a name="l01768"></a><span class="lineno"> 1768</span>&#160;  <span class="comment">// When this function is called, each section of a parallelized mesh</span></div><div class="line"><a name="l01769"></a><span class="lineno"> 1769</span>&#160;  <span class="comment">// should be in the following state:</span></div><div class="line"><a name="l01770"></a><span class="lineno"> 1770</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01771"></a><span class="lineno"> 1771</span>&#160;  <span class="comment">// All nodes should have the exact same physical location on every</span></div><div class="line"><a name="l01772"></a><span class="lineno"> 1772</span>&#160;  <span class="comment">// processor where they exist.</span></div><div class="line"><a name="l01773"></a><span class="lineno"> 1773</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01774"></a><span class="lineno"> 1774</span>&#160;  <span class="comment">// Local nodes should have unique authoritative ids,</span></div><div class="line"><a name="l01775"></a><span class="lineno"> 1775</span>&#160;  <span class="comment">// and processor ids consistent with all processors which own</span></div><div class="line"><a name="l01776"></a><span class="lineno"> 1776</span>&#160;  <span class="comment">// an element touching them.</span></div><div class="line"><a name="l01777"></a><span class="lineno"> 1777</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01778"></a><span class="lineno"> 1778</span>&#160;  <span class="comment">// Ghost nodes touching local elements should have processor ids</span></div><div class="line"><a name="l01779"></a><span class="lineno"> 1779</span>&#160;  <span class="comment">// consistent with all processors which own an element touching</span></div><div class="line"><a name="l01780"></a><span class="lineno"> 1780</span>&#160;  <span class="comment">// them.</span></div><div class="line"><a name="l01781"></a><span class="lineno"> 1781</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01782"></a><span class="lineno"> 1782</span>&#160;  <span class="comment">// Ghost nodes should have ids which are either already correct</span></div><div class="line"><a name="l01783"></a><span class="lineno"> 1783</span>&#160;  <span class="comment">// or which are in the &quot;unpartitioned&quot; id space.</span></div><div class="line"><a name="l01784"></a><span class="lineno"> 1784</span>&#160;</div><div class="line"><a name="l01785"></a><span class="lineno"> 1785</span>&#160;  <span class="comment">// First, let&#39;s sync up processor ids.  Some of these processor ids</span></div><div class="line"><a name="l01786"></a><span class="lineno"> 1786</span>&#160;  <span class="comment">// may be &quot;wrong&quot; from coarsening, but they&#39;re right in the sense</span></div><div class="line"><a name="l01787"></a><span class="lineno"> 1787</span>&#160;  <span class="comment">// that they&#39;ll tell us who has the authoritative dofobject ids for</span></div><div class="line"><a name="l01788"></a><span class="lineno"> 1788</span>&#160;  <span class="comment">// each node.</span></div><div class="line"><a name="l01789"></a><span class="lineno"> 1789</span>&#160;</div><div class="line"><a name="l01790"></a><span class="lineno"> 1790</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1MeshCommunication.html#ab67880939a7d98e9cb3e7a6425a4d7ec">make_node_proc_ids_parallel_consistent</a>(mesh);</div><div class="line"><a name="l01791"></a><span class="lineno"> 1791</span>&#160;</div><div class="line"><a name="l01792"></a><span class="lineno"> 1792</span>&#160;  <span class="comment">// Second, sync up dofobject ids.</span></div><div class="line"><a name="l01793"></a><span class="lineno"> 1793</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1MeshCommunication.html#ab0eae4e562c489db701776c3970e772b">make_node_ids_parallel_consistent</a>(mesh);</div><div class="line"><a name="l01794"></a><span class="lineno"> 1794</span>&#160;</div><div class="line"><a name="l01795"></a><span class="lineno"> 1795</span>&#160;  <span class="comment">// Third, sync up dofobject unique_ids if applicable.</span></div><div class="line"><a name="l01796"></a><span class="lineno"> 1796</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1MeshCommunication.html#a0e83bbe1c114c9de7be87927f7db9e85">make_node_unique_ids_parallel_consistent</a>(mesh);</div><div class="line"><a name="l01797"></a><span class="lineno"> 1797</span>&#160;</div><div class="line"><a name="l01798"></a><span class="lineno"> 1798</span>&#160;  <span class="comment">// Finally, correct the processor ids to make DofMap happy</span></div><div class="line"><a name="l01799"></a><span class="lineno"> 1799</span>&#160;  <a class="code" href="namespacelibMesh_1_1MeshTools.html#aca8746be5247c3f44a3b0797b5ed88f0">MeshTools::correct_node_proc_ids</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div><div class="line"><a name="l01800"></a><span class="lineno"> 1800</span>&#160;}</div><div class="ttc" id="classlibMesh_1_1MeshCommunication_html_a0e83bbe1c114c9de7be87927f7db9e85"><div class="ttname"><a href="classlibMesh_1_1MeshCommunication.html#a0e83bbe1c114c9de7be87927f7db9e85">libMesh::MeshCommunication::make_node_unique_ids_parallel_consistent</a></div><div class="ttdeci">void make_node_unique_ids_parallel_consistent(MeshBase &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01481">mesh_communication.C:1481</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_aca8746be5247c3f44a3b0797b5ed88f0"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#aca8746be5247c3f44a3b0797b5ed88f0">libMesh::MeshTools::correct_node_proc_ids</a></div><div class="ttdeci">void correct_node_proc_ids(MeshBase &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l02259">mesh_tools.C:2259</a></div></div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a4dfeba78f759a8e42683bb559ce1e9fa"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const</div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00089">parallel_object.h:89</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshCommunication_html_ab0eae4e562c489db701776c3970e772b"><div class="ttname"><a href="classlibMesh_1_1MeshCommunication.html#ab0eae4e562c489db701776c3970e772b">libMesh::MeshCommunication::make_node_ids_parallel_consistent</a></div><div class="ttdeci">void make_node_ids_parallel_consistent(MeshBase &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01452">mesh_communication.C:1452</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshCommunication_html_ab67880939a7d98e9cb3e7a6425a4d7ec"><div class="ttname"><a href="classlibMesh_1_1MeshCommunication.html#ab67880939a7d98e9cb3e7a6425a4d7ec">libMesh::MeshCommunication::make_node_proc_ids_parallel_consistent</a></div><div class="ttdeci">void make_node_proc_ids_parallel_consistent(MeshBase &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01656">mesh_communication.C:1656</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9eb166973b14e95ae36c14a39105907a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb166973b14e95ae36c14a39105907a">&#9670;&nbsp;</a></span>make_p_levels_parallel_consistent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::make_p_levels_parallel_consistent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy p levels of ghost elements from their local processors. </p>

<p class="definition">Definition at line <a class="el" href="mesh__communication_8C_source.html#l01529">1529</a> of file <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a>.</p>

<p class="reference">References <a class="el" href="parallel__object_8h_source.html#l00089">libMesh::ParallelObject::comm()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#ac266e1f5eb6ac9566ccbd7e6add6c239">libMesh::MeshBase::elements_begin()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#ae94f1bce0dc50c489c6bae9ba64d06e8">libMesh::MeshBase::elements_end()</a>, <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>, and <a class="el" href="parallel__ghost__sync_8h_source.html#l00336">libMesh::Parallel::sync_dofobject_data_by_id()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mesh__refinement_8C_source.html#l01335">libMesh::MeshRefinement::_coarsen_elements()</a>, and <a class="el" href="mesh__refinement_8C_source.html#l01461">libMesh::MeshRefinement::_refine_elements()</a>.</p>
<div class="fragment"><div class="line"><a name="l01530"></a><span class="lineno"> 1530</span>&#160;{</div><div class="line"><a name="l01531"></a><span class="lineno"> 1531</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div><div class="line"><a name="l01532"></a><span class="lineno"> 1532</span>&#160;  libmesh_parallel_only(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">comm</a>());</div><div class="line"><a name="l01533"></a><span class="lineno"> 1533</span>&#160;</div><div class="line"><a name="l01534"></a><span class="lineno"> 1534</span>&#160;  LOG_SCOPE (<span class="stringliteral">&quot;make_p_levels_parallel_consistent()&quot;</span>, <span class="stringliteral">&quot;MeshCommunication&quot;</span>);</div><div class="line"><a name="l01535"></a><span class="lineno"> 1535</span>&#160;</div><div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160;  SyncPLevels syncplevels(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div><div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#ac7d4f06bb34625465942e6b8d10f135e">Parallel::sync_dofobject_data_by_id</a></div><div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;    (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">comm</a>(), <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#ac266e1f5eb6ac9566ccbd7e6add6c239">elements_begin</a>(), <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#ae94f1bce0dc50c489c6bae9ba64d06e8">elements_end</a>(),</div><div class="line"><a name="l01539"></a><span class="lineno"> 1539</span>&#160;     syncplevels);</div><div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160;}</div><div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_a4dfeba78f759a8e42683bb559ce1e9fa"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#a4dfeba78f759a8e42683bb559ce1e9fa">libMesh::ParallelObject::comm</a></div><div class="ttdeci">const Parallel::Communicator &amp; comm() const</div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00089">parallel_object.h:89</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_ac266e1f5eb6ac9566ccbd7e6add6c239"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#ac266e1f5eb6ac9566ccbd7e6add6c239">libMesh::MeshBase::elements_begin</a></div><div class="ttdeci">virtual element_iterator elements_begin()=0</div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_ae94f1bce0dc50c489c6bae9ba64d06e8"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#ae94f1bce0dc50c489c6bae9ba64d06e8">libMesh::MeshBase::elements_end</a></div><div class="ttdeci">virtual element_iterator elements_end()=0</div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_ac7d4f06bb34625465942e6b8d10f135e"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#ac7d4f06bb34625465942e6b8d10f135e">libMesh::Parallel::sync_dofobject_data_by_id</a></div><div class="ttdeci">void sync_dofobject_data_by_id(const Communicator &amp;comm, const Iterator &amp;range_begin, const Iterator &amp;range_end, SyncFunctor &amp;sync)</div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00336">parallel_ghost_sync.h:336</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6df56ecdd0e08323cdcfcd0740572188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df56ecdd0e08323cdcfcd0740572188">&#9670;&nbsp;</a></span>redistribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::redistribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1DistributedMesh.html">DistributedMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newly_coarsened_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method takes a parallel distributed mesh and redistributes the elements. Specifically, any elements stored on a given processor are sent to the processor which "owns" them. Similarly, any elements assigned to the current processor but stored on another are received. Once this step is completed any required ghost elements are updated. The final result is that each processor stores only the elements it actually owns and any ghost elements required to satisfy data dependencies. This method can be invoked after a partitioning step to affect the new partitioning.</p>
<p>Redistribution can also be done with newly coarsened elements' neighbors only. </p>

<p class="definition">Definition at line <a class="el" href="mesh__communication_8C_source.html#l00284">284</a> of file <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a>.</p>

<p class="reference">Referenced by <a class="el" href="distributed__mesh_8C_source.html#l00803">libMesh::DistributedMesh::redistribute()</a>.</p>
<div class="fragment"><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;{</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;  <span class="comment">// no MPI == one processor, no redistribution</span></div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;  <span class="keywordflow">return</span>;</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a8fc471121e143376e28683be08230a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc471121e143376e28683be08230a53">&#9670;&nbsp;</a></span>send_coarse_ghosts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshCommunication::send_coarse_ghosts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Examine a just-coarsened mesh, and for any newly-coarsened elements, send the associated ghosted elements to the processor which needs them. </p>

<p class="definition">Definition at line <a class="el" href="mesh__communication_8C_source.html#l00915">915</a> of file <a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a>.</p>

<p class="reference">Referenced by <a class="el" href="mesh__refinement_8C_source.html#l01335">libMesh::MeshRefinement::_coarsen_elements()</a>.</p>
<div class="fragment"><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;{</div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;  <span class="comment">// no MPI == one processor, no need for this method...</span></div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;  <span class="keywordflow">return</span>;</div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="mesh__communication_8h_source.html">mesh_communication.h</a></li>
<li><a class="el" href="mesh__communication_8C_source.html">mesh_communication.C</a></li>
<li><a class="el" href="mesh__communication__global__indices_8C_source.html">mesh_communication_global_indices.C</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
generated by <a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a>
</small></address>
<!-- dynamic header stuff -->
<script type="text/javascript">
$(document).ready(function(){
  $(window).on('scroll',function() {
    var scrolltop = $(this).scrollTop();
    if(scrolltop >= 215) {
      $('#fixedbar').fadeIn(250);
    }
    else if(scrolltop <= 210) {
      $('#fixedbar').fadeOut(250);
    }
  });
});
</script>
<!-- Google Analytics stuff -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-24978333-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
