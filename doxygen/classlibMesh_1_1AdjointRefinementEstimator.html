<!-- HTML header for doxygen -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libMesh: libMesh::AdjointRefinementEstimator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="../styles.css" rel="stylesheet" type="text/css" />
<link href="doxygen_stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <nav id="fixedbar">
    <ul id="fixednav">
      <li><a href="../index.html">Home</a></li>
      <li><a href="../support.html">About Us</a></li>
      <li><a href="../publications.html">Publications</a></li>
      <li><a href="../developers.html">Developers</a></li>
      <li><a href="../installation.html">Installation</a></li>
      <li><a href="../examples.html">Examples</a></li>
      <li><a href="../doxygen/index.html">Documentation</a></li>
    </ul>
  </nav>
  <div id="w">
    <header id="logo"><a href="index.html"><span id="logobg">SomeWebsiteLogo</span></a></header>
    <nav id="navigation">
      <ul>
        <li><a href="../index.html">Home</a></li>
        <li><a href="../support.html">About Us</a></li>
        <li><a href="../publications.html">Publications</a></li>
        <li><a href="../developers.html">Developers</a></li>
        <li><a href="../installation.html">Installation</a></li>
        <li><a href="../examples.html">Examples</a></li>
        <li><a href="../doxygen/index.html">Documentation</a></li>
      </ul>
    </nav>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- <\!--BEGIN TITLEAREA-\-> -->
<!-- <div id="titlearea"> -->
<!-- <table cellspacing="0" cellpadding="0"> -->
<!--  <tbody> -->
<!--  <tr style="height: 56px;"> -->
<!--   <\!--BEGIN PROJECT_LOGO-\-> -->
<!--   <td id="projectlogo"><img alt="Logo" src=""/></td> -->
<!--   <\!--END PROJECT_LOGO-\-> -->
<!--   <\!--BEGIN PROJECT_NAME-\-> -->
<!--   <td style="padding-left: 0.5em;"> -->
<!--    <div id="projectname">libMesh -->
<!--    <\!--BEGIN PROJECT_NUMBER-\->&#160;<span id="projectnumber"></span><\!--END PROJECT_NUMBER-\-> -->
<!--    </div> -->
<!--    <\!--BEGIN PROJECT_BRIEF-\-><div id="projectbrief"></div><\!--END PROJECT_BRIEF-\-> -->
<!--   </td> -->
<!--   <\!--END PROJECT_NAME-\-> -->
<!--   <\!--BEGIN !PROJECT_NAME-\-> -->
<!--    <\!--BEGIN PROJECT_BRIEF-\-> -->
<!--     <td style="padding-left: 0.5em;"> -->
<!--     <div id="projectbrief"></div> -->
<!--     </td> -->
<!--    <\!--END PROJECT_BRIEF-\-> -->
<!--   <\!--END !PROJECT_NAME-\-> -->
<!--   <\!--BEGIN DISABLE_INDEX-\-> -->
<!--    <\!--BEGIN SEARCHENGINE-\-> -->
<!--    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td> -->
<!--    <\!--END SEARCHENGINE-\-> -->
<!--   <\!--END DISABLE_INDEX-\-> -->
<!--  </tr> -->
<!--  </tbody> -->
<!-- </table> -->
<!-- </div> -->
<!-- <\!--END TITLEAREA-\-> -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibMesh.html">libMesh</a></li><li class="navelem"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classlibMesh_1_1AdjointRefinementEstimator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libMesh::AdjointRefinementEstimator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for libMesh::AdjointRefinementEstimator:</div>
<div class="dyncontent">
<div class="center"><img src="classlibMesh_1_1AdjointRefinementEstimator__inherit__graph.png" border="0" usemap="#libMesh_1_1AdjointRefinementEstimator_inherit__map" alt="Inheritance graph"/></div>
<map name="libMesh_1_1AdjointRefinementEstimator_inherit__map" id="libMesh_1_1AdjointRefinementEstimator_inherit__map">
<area shape="rect" id="node2" href="classlibMesh_1_1ErrorEstimator.html" title="libMesh::ErrorEstimator" alt="" coords="17,5,178,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a662486f8192c2f70733efa723a9fb336"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::pair&lt; const <a class="el" href="classlibMesh_1_1System.html">System</a> *, unsigned int &gt;, <a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ErrorEstimator.html#a662486f8192c2f70733efa723a9fb336">ErrorMap</a></td></tr>
<tr class="separator:a662486f8192c2f70733efa723a9fb336"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afcdf4f028e2e69d7457d052cb8b27540"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#afcdf4f028e2e69d7457d052cb8b27540">AdjointRefinementEstimator</a> ()</td></tr>
<tr class="separator:afcdf4f028e2e69d7457d052cb8b27540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa49fea6d02efd39419a3ad98bf3390"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a5aa49fea6d02efd39419a3ad98bf3390">AdjointRefinementEstimator</a> (const <a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a> &amp;)=default</td></tr>
<tr class="separator:a5aa49fea6d02efd39419a3ad98bf3390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ce0c886941a8456615305163e3b374"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a57ce0c886941a8456615305163e3b374">AdjointRefinementEstimator</a> (<a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a57ce0c886941a8456615305163e3b374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afd6c830b8dddbfb1014edf18f8f69c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4afd6c830b8dddbfb1014edf18f8f69c">operator=</a> (const <a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a> &amp;)=default</td></tr>
<tr class="separator:a4afd6c830b8dddbfb1014edf18f8f69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a07208352932dfb91f3b7035729f137"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a6a07208352932dfb91f3b7035729f137">operator=</a> (<a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a6a07208352932dfb91f3b7035729f137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc84f858a58030455da251676901a494"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#afc84f858a58030455da251676901a494">~AdjointRefinementEstimator</a> ()=default</td></tr>
<tr class="separator:afc84f858a58030455da251676901a494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aca6ed2c5e83a66cbea3fb745d42bb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a0aca6ed2c5e83a66cbea3fb745d42bb6">qoi_set</a> ()</td></tr>
<tr class="separator:a0aca6ed2c5e83a66cbea3fb745d42bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa40e4da1ac4723fd613cbc51f68b61f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#afa40e4da1ac4723fd613cbc51f68b61f">qoi_set</a> () const</td></tr>
<tr class="separator:afa40e4da1ac4723fd613cbc51f68b61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22123d38f2ec64def98842a1da697db1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a22123d38f2ec64def98842a1da697db1">estimate_error</a> (const <a class="el" href="classlibMesh_1_1System.html">System</a> &amp;system, <a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a> &amp;error_per_cell, const <a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a>&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; *solution_vector=nullptr, bool estimate_parent_error=false)</td></tr>
<tr class="separator:a22123d38f2ec64def98842a1da697db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0143c56bd2fdc236700dd3b1262d7097"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a0143c56bd2fdc236700dd3b1262d7097">get_global_QoI_error_estimate</a> (unsigned int qoi_index)</td></tr>
<tr class="separator:a0143c56bd2fdc236700dd3b1262d7097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c321f3393a9efb5dda3c4b43926f4d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacelibMesh.html#a370493a82a7f09613a0fdc56fc7912b7">ErrorEstimatorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a69c321f3393a9efb5dda3c4b43926f4d">type</a> () const</td></tr>
<tr class="separator:a69c321f3393a9efb5dda3c4b43926f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d2e7401de04e31b0a1c81650ec72e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1DifferentiablePhysics.html">DifferentiablePhysics</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#ac4d2e7401de04e31b0a1c81650ec72e8">get_residual_evaluation_physics</a> ()</td></tr>
<tr class="separator:ac4d2e7401de04e31b0a1c81650ec72e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d69ad607bba49f333dd775ccdd7ca1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a13d69ad607bba49f333dd775ccdd7ca1">set_residual_evaluation_physics</a> (<a class="el" href="classlibMesh_1_1DifferentiablePhysics.html">DifferentiablePhysics</a> *set_physics)</td></tr>
<tr class="separator:a13d69ad607bba49f333dd775ccdd7ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513952f2b4a0b30834c04e1411cd030f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ErrorEstimator.html#a513952f2b4a0b30834c04e1411cd030f">estimate_errors</a> (const <a class="el" href="classlibMesh_1_1EquationSystems.html">EquationSystems</a> &amp;equation_systems, <a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a> &amp;error_per_cell, const std::map&lt; const <a class="el" href="classlibMesh_1_1System.html">System</a> *, <a class="el" href="classlibMesh_1_1SystemNorm.html">SystemNorm</a> &gt; &amp;error_norms, const std::map&lt; const <a class="el" href="classlibMesh_1_1System.html">System</a> *, const <a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a>&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; *&gt; *solution_vectors=nullptr, bool estimate_parent_error=false)</td></tr>
<tr class="separator:a513952f2b4a0b30834c04e1411cd030f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ddba9905e39aa89ed2aff7438b1b6e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ErrorEstimator.html#aa1ddba9905e39aa89ed2aff7438b1b6e">estimate_errors</a> (const <a class="el" href="classlibMesh_1_1EquationSystems.html">EquationSystems</a> &amp;equation_systems, <a class="el" href="classlibMesh_1_1ErrorEstimator.html#a662486f8192c2f70733efa723a9fb336">ErrorMap</a> &amp;errors_per_cell, const std::map&lt; const <a class="el" href="classlibMesh_1_1System.html">System</a> *, const <a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a>&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; *&gt; *solution_vectors=nullptr, bool estimate_parent_error=false)</td></tr>
<tr class="separator:aa1ddba9905e39aa89ed2aff7438b1b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4437c7888b7459952e06a9157bf61ffe"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a></td></tr>
<tr class="separator:a4437c7888b7459952e06a9157bf61ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff7ac97985f693cd3cc7a8311a24558"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">number_p_refinements</a></td></tr>
<tr class="separator:abff7ac97985f693cd3cc7a8311a24558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d626496b0b6f99f679c4ef4f0a5e46e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1SystemNorm.html">SystemNorm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a></td></tr>
<tr class="separator:a9d626496b0b6f99f679c4ef4f0a5e46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6a5807a86e0751edc399afa2ac44ae89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ErrorEstimator.html#a6a5807a86e0751edc399afa2ac44ae89">reduce_error</a> (std::vector&lt; <a class="el" href="namespacelibMesh.html#a26acf05f075521cbfb223db57e63d6d0">ErrorVectorReal</a> &gt; &amp;error_per_cell, const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Parallel::Communicator</a> &amp;comm) const</td></tr>
<tr class="separator:a6a5807a86e0751edc399afa2ac44ae89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af73f953ce5c33a52ea2b53364c1aff9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1DifferentiablePhysics.html">DifferentiablePhysics</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">_residual_evaluation_physics</a></td></tr>
<tr class="separator:af73f953ce5c33a52ea2b53364c1aff9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af635c66743cb57b7ffc0c16343055a8d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#af635c66743cb57b7ffc0c16343055a8d">computed_global_QoI_errors</a></td></tr>
<tr class="separator:af635c66743cb57b7ffc0c16343055a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51061a9299eba61c328edca03b0cd20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a></td></tr>
<tr class="separator:ad51061a9299eba61c328edca03b0cd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements a "brute force" goal-oriented error estimator which computes an estimate of error in a quantity of interest based on the residual of the current coarse grid primal solution as weighted against an adjoint solution on a uniformly refined (in h and/or p, for an arbitrary number of levels) grid.</p>
<dl class="section author"><dt>Author</dt><dd>Roy H. Stogner </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2009 </dd></dl>

<p class="definition">Definition at line <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00050">50</a> of file <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a662486f8192c2f70733efa723a9fb336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662486f8192c2f70733efa723a9fb336">&#9670;&nbsp;</a></span>ErrorMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::pair&lt;const <a class="el" href="classlibMesh_1_1System.html">System</a> *, unsigned int&gt;, <a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a> *&gt; <a class="el" href="classlibMesh_1_1ErrorEstimator.html#a662486f8192c2f70733efa723a9fb336">libMesh::ErrorEstimator::ErrorMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When calculating many error vectors at once, we need a data structure to hold them all </p>

<p class="definition">Definition at line <a class="el" href="error__estimator_8h_source.html#l00124">124</a> of file <a class="el" href="error__estimator_8h_source.html">error_estimator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afcdf4f028e2e69d7457d052cb8b27540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcdf4f028e2e69d7457d052cb8b27540">&#9670;&nbsp;</a></span>AdjointRefinementEstimator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::AdjointRefinementEstimator::AdjointRefinementEstimator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Sets the most common default parameter values. </p>

<p class="definition">Definition at line <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00073">73</a> of file <a class="el" href="adjoint__refinement__estimator_8C_source.html">adjoint_refinement_estimator.C</a>.</p>

<p class="reference">References <a class="el" href="error__estimator_8h_source.html#l00161">libMesh::ErrorEstimator::error_norm</a>, and <a class="el" href="enum__norm__type_8h_source.html#l00061">libMesh::INVALID_NORM</a>.</p>
<div class="fragment"><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;                                                       :</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  <a class="code" href="classlibMesh_1_1ErrorEstimator.html#abd4e67c1f8f49543f64859513208faa4">ErrorEstimator</a>(),</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a>(1),</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">number_p_refinements</a>(0),</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">_residual_evaluation_physics</a>(<span class="keyword">nullptr</span>),</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>(QoISet())</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;{</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;  <span class="comment">// We&#39;re not actually going to use error_norm; our norms are</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;  <span class="comment">// absolute values of QoI error.</span></div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  <a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a> = <a class="code" href="namespacelibMesh.html#a2fef831ba9c2670aafb97bcb7e597346ad57b0f1b145c48bd9cafec20cca415bc">INVALID_NORM</a>;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;}</div><div class="ttc" id="classlibMesh_1_1ErrorEstimator_html_a9d626496b0b6f99f679c4ef4f0a5e46e"><div class="ttname"><a href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">libMesh::ErrorEstimator::error_norm</a></div><div class="ttdeci">SystemNorm error_norm</div><div class="ttdef"><b>Definition:</b> <a href="error__estimator_8h_source.html#l00161">error_estimator.h:161</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_ad51061a9299eba61c328edca03b0cd20"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">libMesh::AdjointRefinementEstimator::_qoi_set</a></div><div class="ttdeci">QoISet _qoi_set</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00150">adjoint_refinement_estimator.h:150</a></div></div>
<div class="ttc" id="classlibMesh_1_1ErrorEstimator_html_abd4e67c1f8f49543f64859513208faa4"><div class="ttname"><a href="classlibMesh_1_1ErrorEstimator.html#abd4e67c1f8f49543f64859513208faa4">libMesh::ErrorEstimator::ErrorEstimator</a></div><div class="ttdeci">ErrorEstimator()=default</div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_af73f953ce5c33a52ea2b53364c1aff9c"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">libMesh::AdjointRefinementEstimator::_residual_evaluation_physics</a></div><div class="ttdeci">DifferentiablePhysics * _residual_evaluation_physics</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00142">adjoint_refinement_estimator.h:142</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_a4437c7888b7459952e06a9157bf61ffe"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">libMesh::AdjointRefinementEstimator::number_h_refinements</a></div><div class="ttdeci">unsigned char number_h_refinements</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00116">adjoint_refinement_estimator.h:116</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_abff7ac97985f693cd3cc7a8311a24558"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">libMesh::AdjointRefinementEstimator::number_p_refinements</a></div><div class="ttdeci">unsigned char number_p_refinements</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00121">adjoint_refinement_estimator.h:121</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a2fef831ba9c2670aafb97bcb7e597346ad57b0f1b145c48bd9cafec20cca415bc"><div class="ttname"><a href="namespacelibMesh.html#a2fef831ba9c2670aafb97bcb7e597346ad57b0f1b145c48bd9cafec20cca415bc">libMesh::INVALID_NORM</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__norm__type_8h_source.html#l00061">enum_norm_type.h:61</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5aa49fea6d02efd39419a3ad98bf3390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa49fea6d02efd39419a3ad98bf3390">&#9670;&nbsp;</a></span>AdjointRefinementEstimator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::AdjointRefinementEstimator::AdjointRefinementEstimator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy/move ctor, copy/move assignment operator, and destructor are all explicitly defaulted for this class. </p>

</div>
</div>
<a id="a57ce0c886941a8456615305163e3b374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ce0c886941a8456615305163e3b374">&#9670;&nbsp;</a></span>AdjointRefinementEstimator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::AdjointRefinementEstimator::AdjointRefinementEstimator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afc84f858a58030455da251676901a494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc84f858a58030455da251676901a494">&#9670;&nbsp;</a></span>~AdjointRefinementEstimator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual libMesh::AdjointRefinementEstimator::~AdjointRefinementEstimator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a22123d38f2ec64def98842a1da697db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22123d38f2ec64def98842a1da697db1">&#9670;&nbsp;</a></span>estimate_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::AdjointRefinementEstimator::estimate_error </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1System.html">System</a> &amp;&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a> &amp;&#160;</td>
          <td class="paramname"><em>error_per_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a>&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; *&#160;</td>
          <td class="paramname"><em>solution_vector</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>estimate_parent_error</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function does uniform refinements and an adjoint solve to get an adjoint solution on each cell, then estimates the error by finding the weighted residual of the coarse solution with the fine adjoint solution.</p>
<p>system.solve() and system.assembly() must be called, and so should have no side effects.</p>
<p>Only the provided system is solved on the refined mesh; we don't support adjoint solves on loosely coupled collections of Systems.</p>
<p>The estimated error is output in the vector <code>error_per_cell</code> </p>

<p>Implements <a class="el" href="classlibMesh_1_1ErrorEstimator.html#ab5ee8217ac35baaa00cc3b72e9815d93">libMesh::ErrorEstimator</a>.</p>

<p class="definition">Definition at line <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00090">90</a> of file <a class="el" href="adjoint__refinement__estimator_8C_source.html">adjoint_refinement_estimator.C</a>.</p>

<p class="reference">References <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00150">_qoi_set</a>, <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00142">_residual_evaluation_physics</a>, <a class="el" href="libmesh__augment__std__namespace_8h_source.html#l00059">std::abs()</a>, <a class="el" href="system_8C_source.html#l00661">libMesh::System::add_vector()</a>, <a class="el" href="system_8h_source.html#l02300">libMesh::System::adjoint_solve()</a>, <a class="el" href="simple__range_8h_source.html#l00057">libMesh::as_range()</a>, <a class="el" href="classlibMesh_1_1DifferentiableSystem.html#a3fa9e7df259b03e081afc9f42ccf059e">libMesh::DifferentiableSystem::assembly()</a>, <a class="el" href="numeric__vector_8C_source.html#l00048">libMesh::NumericVector&lt; T &gt;::build()</a>, <a class="el" href="numeric__vector_8h_source.html#l00796">libMesh::NumericVector&lt; T &gt;::clear()</a>, <a class="el" href="diff__system_8h_source.html#l00169">libMesh::DifferentiableSystem::clone()</a>, <a class="el" href="classlibMesh_1_1NumericVector.html#a42ea91bba70b3e7b27dad2a636ad31ae">libMesh::NumericVector&lt; T &gt;::close()</a>, <a class="el" href="parallel__object_8h_source.html#l00089">libMesh::ParallelObject::comm()</a>, <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00145">computed_global_QoI_errors</a>, <a class="el" href="system_8h_source.html#l01535">libMesh::System::current_local_solution</a>, <a class="el" href="dof__map_8C_source.html#l01930">libMesh::DofMap::dof_indices()</a>, <a class="el" href="classlibMesh_1_1NumericVector.html#a4efa46e6fd605dd2a4aef2cb1b4ca81a">libMesh::NumericVector&lt; T &gt;::dot()</a>, <a class="el" href="dof__map__constraints_8C_source.html#l02170">libMesh::DofMap::enforce_adjoint_constraints_exactly()</a>, <a class="el" href="libmesh__common_8h_source.html#l00202">libMesh::ErrorVectorReal</a>, <a class="el" href="numeric__vector_8h_source.html#l00806">libMesh::NumericVector&lt; T &gt;::get()</a>, <a class="el" href="system_8C_source.html#l00969">libMesh::System::get_adjoint_solution()</a>, <a class="el" href="system_8h_source.html#l02049">libMesh::System::get_dof_map()</a>, <a class="el" href="system_8h_source.html#l00712">libMesh::System::get_equation_systems()</a>, <a class="el" href="equation__systems_8h_source.html#l00622">libMesh::EquationSystems::get_mesh()</a>, <a class="el" href="dof__map_8h_source.html#l00450">libMesh::DofMap::get_send_list()</a>, <a class="el" href="system_8C_source.html#l00774">libMesh::System::get_vector()</a>, <a class="el" href="enum__parallel__type_8h_source.html#l00037">libMesh::GHOSTED</a>, <a class="el" href="dof__map__constraints_8C_source.html#l04292">libMesh::DofMap::has_adjoint_dirichlet_boundaries()</a>, <a class="el" href="qoi__set_8h_source.html#l00221">libMesh::QoISet::has_index()</a>, <a class="el" href="dof__object_8h_source.html#l00655">libMesh::DofObject::id()</a>, <a class="el" href="namespacelibMesh_1_1TriangleWrapper.html#ae06da07f4c64d00ebefa55ce7f5c5e6b">libMesh::TriangleWrapper::init()</a>, <a class="el" href="system_8h_source.html#l00388">libMesh::System::is_adjoint_already_solved()</a>, <a class="el" href="classlibMesh_1_1NumericVector.html#a7348b5b027adf716016354847e0df0b6">libMesh::NumericVector&lt; T &gt;::localize()</a>, <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>, <a class="el" href="system_8C_source.html#l00150">libMesh::System::n_dofs()</a>, <a class="el" href="system_8C_source.html#l00187">libMesh::System::n_local_dofs()</a>, <a class="el" href="system_8h_source.html#l02278">libMesh::System::n_qois()</a>, <a class="el" href="system_8h_source.html#l02025">libMesh::System::number()</a>, <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00116">number_h_refinements</a>, <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00121">number_p_refinements</a>, <a class="el" href="elem_8h_source.html#l02479">libMesh::Elem::parent()</a>, <a class="el" href="system_8h_source.html#l00794">libMesh::System::project_solution_on_reinit()</a>, <a class="el" href="libmesh__common_8h_source.html#l00131">libMesh::Real</a>, <a class="el" href="error__estimator_8C_source.html#l00032">libMesh::ErrorEstimator::reduce_error()</a>, <a class="el" href="equation__systems_8C_source.html#l00121">libMesh::EquationSystems::reinit()</a>, <a class="el" href="system_8h_source.html#l01523">libMesh::System::solution</a>, <a class="el" href="numeric__vector_8h_source.html#l00974">libMesh::NumericVector&lt; T &gt;::swap()</a>, <a class="el" href="mesh__refinement_8C_source.html#l01701">libMesh::MeshRefinement::uniformly_coarsen()</a>, <a class="el" href="mesh__refinement_8C_source.html#l01661">libMesh::MeshRefinement::uniformly_p_coarsen()</a>, <a class="el" href="mesh__refinement_8C_source.html#l01647">libMesh::MeshRefinement::uniformly_p_refine()</a>, <a class="el" href="mesh__refinement_8C_source.html#l01676">libMesh::MeshRefinement::uniformly_refine()</a>, <a class="el" href="system_8C_source.html#l00408">libMesh::System::update()</a>, <a class="el" href="system_8h_source.html#l02245">libMesh::System::vectors_begin()</a>, <a class="el" href="system_8h_source.html#l02257">libMesh::System::vectors_end()</a>, and <a class="el" href="qoi__set_8h_source.html#l00240">libMesh::QoISet::weight()</a>.</p>
<div class="fragment"><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;{</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;  <span class="comment">// We have to break the rules here, because we can&#39;t refine a const System</span></div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  System &amp; system = <span class="keyword">const_cast&lt;</span>System &amp;<span class="keyword">&gt;</span>(_system);</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;  <span class="comment">// An EquationSystems reference will be convenient.</span></div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  EquationSystems &amp; es = system.get_equation_systems();</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  <span class="comment">// The current mesh</span></div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  MeshBase &amp; <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a> = es.get_mesh();</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  <span class="comment">// Get coarse grid adjoint solutions.  This should be a relatively</span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;  <span class="comment">// quick (especially with preconditioner reuse) way to get a good</span></div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;  <span class="comment">// initial guess for the fine grid adjoint solutions.  More</span></div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  <span class="comment">// importantly, subtracting off a coarse adjoint approximation gives</span></div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;  <span class="comment">// us better local error indication, and subtracting off *some* lift</span></div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;  <span class="comment">// function is necessary for correctness if we have heterogeneous</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  <span class="comment">// adjoint Dirichlet conditions.</span></div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  <span class="comment">// Solve the adjoint problem(s) on the coarse FE space</span></div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  <span class="comment">// Only if the user didn&#39;t already solve it for us</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  <span class="keywordflow">if</span> (!system.is_adjoint_already_solved())</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    system.adjoint_solve(<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>);</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  <span class="comment">// Loop over all the adjoint problems and, if any have heterogenous</span></div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;  <span class="comment">// Dirichlet conditions, get the corresponding coarse lift</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  <span class="comment">// function(s)</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0,</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;       n_qois = system.n_qois(); j != n_qois; j++)</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    {</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;      <span class="comment">// Skip this QoI if it is not in the QoI Set or if there are no</span></div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;      <span class="comment">// heterogeneous Dirichlet boundaries for it</span></div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>.<a class="code" href="classlibMesh_1_1QoISet.html#afb2189ec653ed963db3754cc6949bc8b">has_index</a>(j) &amp;&amp;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;          system.get_dof_map().has_adjoint_dirichlet_boundaries(j))</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        {</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;          <span class="comment">// Next, we are going to build up the residual for evaluating the flux QoI</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;          NumericVector&lt;Number&gt; * coarse_residual = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;          <span class="comment">// The definition of a flux QoI is R(u^h, L) where R is the residual as defined</span></div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;          <span class="comment">// by a conservation law. Therefore, if we are using stabilization, the</span></div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;          <span class="comment">// R should be specified by the user via the residual_evaluation_physics</span></div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;          <span class="comment">// If the residual physics pointer is not null, use it when</span></div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;          <span class="comment">// evaluating here.</span></div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;          {</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">bool</span> swapping_physics = <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">_residual_evaluation_physics</a>;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;            <span class="keywordflow">if</span> (swapping_physics)</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;              <span class="keyword">dynamic_cast&lt;</span>DifferentiableSystem &amp;<span class="keyword">&gt;</span>(system).swap_physics(<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">_residual_evaluation_physics</a>);</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;            <span class="comment">// Assemble without applying constraints, to capture the solution values on the boundary</span></div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;            (<span class="keyword">dynamic_cast&lt;</span>ImplicitSystem &amp;<span class="keyword">&gt;</span>(system)).assembly(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;            <span class="comment">// Get the residual vector (no constraints applied on boundary, so we wont blow away the lift)</span></div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;            coarse_residual = &amp;(<span class="keyword">dynamic_cast&lt;</span>ExplicitSystem &amp;<span class="keyword">&gt;</span>(system)).get_vector(<span class="stringliteral">&quot;RHS Vector&quot;</span>);</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;            coarse_residual-&gt;close();</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;            <span class="comment">// Now build the lift function and add it to the system vectors</span></div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;            std::ostringstream liftfunc_name;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;            liftfunc_name &lt;&lt; <span class="stringliteral">&quot;adjoint_lift_function&quot;</span> &lt;&lt; j;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;            system.add_vector(liftfunc_name.str());</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;            <span class="comment">// Initialize lift with coarse adjoint solve associate with this flux QoI to begin with</span></div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;            system.get_vector(liftfunc_name.str()).<a class="code" href="namespacelibMesh_1_1TriangleWrapper.html#ae06da07f4c64d00ebefa55ce7f5c5e6b">init</a>(system.get_adjoint_solution(j), <span class="keyword">false</span>);</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;            <span class="comment">// Build the actual lift using adjoint dirichlet conditions</span></div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;            system.get_dof_map().enforce_adjoint_constraints_exactly</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;              (system.get_vector(liftfunc_name.str()), static_cast&lt;unsigned int&gt;(j));</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;            <span class="comment">// Compute the flux R(u^h, L)</span></div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;            std::cout&lt;&lt;<span class="stringliteral">&quot;The flux QoI &quot;</span>&lt;&lt;<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(j)&lt;&lt;<span class="stringliteral">&quot; is: &quot;</span>&lt;&lt;coarse_residual-&gt;dot(system.get_vector(liftfunc_name.str()))&lt;&lt;std::endl&lt;&lt;std::endl;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;            <span class="comment">// Swap back if needed</span></div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;            <span class="keywordflow">if</span> (swapping_physics)</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;              <span class="keyword">dynamic_cast&lt;</span>DifferentiableSystem &amp;<span class="keyword">&gt;</span>(system).swap_physics(<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">_residual_evaluation_physics</a>);</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;          }</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        } <span class="comment">// End if QoI in set and flux/dirichlet boundary QoI</span></div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    } <span class="comment">// End loop over QoIs</span></div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;  <span class="comment">// We&#39;ll want to back up all coarse grid vectors</span></div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;  std::map&lt;std::string, std::unique_ptr&lt;NumericVector&lt;Number&gt;&gt;&gt; coarse_vectors;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code" href="namespacelibMesh.html#a977361a82b7a9e7ad8e50ae1cae40d20">as_range</a>(system.vectors_begin(), system.vectors_end()))</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    {</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;      <span class="comment">// The (string) name of this vector</span></div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;      <span class="keyword">const</span> std::string &amp; var_name = pr.first;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;      coarse_vectors[var_name] = pr.second-&gt;clone();</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    }</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;  <span class="comment">// Back up the coarse solution and coarse local solution</span></div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;  std::unique_ptr&lt;NumericVector&lt;Number&gt;&gt; coarse_solution = system.solution-&gt;clone();</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;  std::unique_ptr&lt;NumericVector&lt;Number&gt;&gt; coarse_local_solution = system.current_local_solution-&gt;clone();</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;  <span class="comment">// And we&#39;ll need to temporarily change solution projection settings</span></div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;  <span class="keywordtype">bool</span> old_projection_setting;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;  old_projection_setting = system.project_solution_on_reinit();</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;  <span class="comment">// Make sure the solution is projected when we refine the mesh</span></div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;  system.project_solution_on_reinit() = <span class="keyword">true</span>;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;  <span class="comment">// And it&#39;ll be best to avoid any repartitioning</span></div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;  std::unique_ptr&lt;Partitioner&gt; old_partitioner(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.partitioner().release());</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;  <span class="comment">// And we can&#39;t allow any renumbering</span></div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">bool</span> old_renumbering_setting = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.allow_renumbering();</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;  <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.allow_renumbering(<span class="keyword">false</span>);</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;  <span class="comment">// Use a non-standard solution vector if necessary</span></div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;  <span class="keywordflow">if</span> (solution_vector &amp;&amp; solution_vector != system.solution.get())</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    {</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;      NumericVector&lt;Number&gt; * newsol =</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;        <span class="keyword">const_cast&lt;</span>NumericVector&lt;Number&gt; *<span class="keyword">&gt;</span> (solution_vector);</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;      newsol-&gt;swap(*system.solution);</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;      system.update();</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    }</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;  <span class="comment">// Resize the error_per_cell vector to be</span></div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;  <span class="comment">// the number of elements, initialized to 0.</span></div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;  error_per_cell.clear();</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;  error_per_cell.resize (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.max_elem_id(), 0.);</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;<span class="preprocessor">#ifndef NDEBUG</span></div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;  <span class="comment">// These variables are only used in assertions later so</span></div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;  <span class="comment">// avoid declaring them unless asserts are active.</span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> n_coarse_elem = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.n_active_elem();</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;  <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> local_dof_bearing_nodes = 0;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sysnum = system.number();</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> * node : <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.local_node_ptr_range())</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0, nvars = node-&gt;n_vars(sysnum);</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;         v != nvars; ++v)</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;      <span class="keywordflow">if</span> (node-&gt;n_comp(sysnum, v))</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;        {</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;          local_dof_bearing_nodes++;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;          <span class="keywordflow">break</span>;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        }</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="preprocessor">#endif // NDEBUG</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;  <span class="comment">// Uniformly refine the mesh</span></div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;  MeshRefinement mesh_refinement(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;  libmesh_assert (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a> &gt; 0 || <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">number_p_refinements</a> &gt; 0);</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;  <span class="comment">// FIXME: this may break if there is more than one System</span></div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;  <span class="comment">// on this mesh but estimate_error was still called instead of</span></div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;  <span class="comment">// estimate_errors</span></div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i != <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a>; ++i)</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    {</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;      mesh_refinement.uniformly_refine(1);</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;      es.reinit();</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    }</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i != <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">number_p_refinements</a>; ++i)</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    {</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;      mesh_refinement.uniformly_p_refine(1);</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;      es.reinit();</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    }</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;  <span class="comment">// Copy the projected coarse grid solutions, which will be</span></div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;  <span class="comment">// overwritten by solve()</span></div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;  std::vector&lt;std::unique_ptr&lt;NumericVector&lt;Number&gt;&gt;&gt; coarse_adjoints;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j != system.n_qois(); j++)</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;    {</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>.<a class="code" href="classlibMesh_1_1QoISet.html#afb2189ec653ed963db3754cc6949bc8b">has_index</a>(j))</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;        {</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;          <span class="keyword">auto</span> coarse_adjoint = <a class="code" href="classlibMesh_1_1NumericVector.html#adba4a30965537656bb3b0c6f924ff040">NumericVector&lt;Number&gt;::build</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.comm());</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;          <span class="comment">// Can do &quot;fast&quot; init since we&#39;re overwriting this in a sec</span></div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;          coarse_adjoint-&gt;init(system.get_adjoint_solution(j),</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;                               <span class="comment">/* fast = */</span> <span class="keyword">true</span>);</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;          *coarse_adjoint = system.get_adjoint_solution(j);</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;          coarse_adjoints.emplace_back(std::move(coarse_adjoint));</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;        }</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;        coarse_adjoints.emplace_back(<span class="keyword">nullptr</span>);</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    }</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;  <span class="comment">// Next, we are going to build up the residual for evaluating the</span></div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;  <span class="comment">// error estimate.</span></div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;  <span class="comment">// If the residual physics pointer is not null, use it when</span></div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;  <span class="comment">// evaluating here.</span></div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;  {</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">bool</span> swapping_physics = <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">_residual_evaluation_physics</a>;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;    <span class="keywordflow">if</span> (swapping_physics)</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;      <span class="keyword">dynamic_cast&lt;</span>DifferentiableSystem &amp;<span class="keyword">&gt;</span>(system).swap_physics(<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">_residual_evaluation_physics</a>);</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;    <span class="comment">// Rebuild the rhs with the projected primal solution, constraints</span></div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    <span class="comment">// have to be applied to get the correct error estimate since error</span></div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    <span class="comment">// on the Dirichlet boundary is zero</span></div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    (<span class="keyword">dynamic_cast&lt;</span>ImplicitSystem &amp;<span class="keyword">&gt;</span>(system)).assembly(<span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    <span class="comment">// Swap back if needed</span></div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    <span class="keywordflow">if</span> (swapping_physics)</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;      <span class="keyword">dynamic_cast&lt;</span>DifferentiableSystem &amp;<span class="keyword">&gt;</span>(system).swap_physics(<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">_residual_evaluation_physics</a>);</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;  }</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;  NumericVector&lt;Number&gt; &amp; projected_residual = (<span class="keyword">dynamic_cast&lt;</span>ExplicitSystem &amp;<span class="keyword">&gt;</span>(system)).get_vector(<span class="stringliteral">&quot;RHS Vector&quot;</span>);</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;  projected_residual.close();</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;  <span class="comment">// Solve the adjoint problem(s) on the refined FE space</span></div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;  system.adjoint_solve(<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>);</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;  <span class="comment">// Now that we have the refined adjoint solution and the projected primal solution,</span></div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;  <span class="comment">// we first compute the global QoI error estimate</span></div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;  <span class="comment">// Resize the computed_global_QoI_errors vector to hold the error estimates for each QoI</span></div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;  <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af635c66743cb57b7ffc0c16343055a8d">computed_global_QoI_errors</a>.resize(system.n_qois());</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;  <span class="comment">// Loop over all the adjoint solutions and get the QoI error</span></div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;  <span class="comment">// contributions from all of them.  While we&#39;re looping anyway we&#39;ll</span></div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;  <span class="comment">// pull off the coarse adjoints</span></div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j != system.n_qois(); j++)</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    {</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;      <span class="comment">// Skip this QoI if not in the QoI Set</span></div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>.<a class="code" href="classlibMesh_1_1QoISet.html#afb2189ec653ed963db3754cc6949bc8b">has_index</a>(j))</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;        {</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;          <span class="comment">// If the adjoint solution has heterogeneous dirichlet</span></div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;          <span class="comment">// values, then to get a proper error estimate here we need</span></div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;          <span class="comment">// to subtract off a coarse grid lift function.</span></div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;          <span class="comment">// |Q(u) - Q(u^h)| = |R([u^h]+, z^h+ - [L]+)| + HOT</span></div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;          <span class="keywordflow">if</span>(system.get_dof_map().has_adjoint_dirichlet_boundaries(j))</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;            {</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;              <span class="comment">// Need to create a string with current loop index to retrieve</span></div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;              <span class="comment">// the correct vector from the liftvectors map</span></div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;              std::ostringstream liftfunc_name;</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;              liftfunc_name &lt;&lt; <span class="stringliteral">&quot;adjoint_lift_function&quot;</span> &lt;&lt; j;</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;              <span class="comment">// Subtract off the corresponding lift vector from the adjoint solution</span></div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;              system.get_adjoint_solution(j) -= system.get_vector(liftfunc_name.str());</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;              <span class="comment">// Now evaluate R(u^h, z^h+ - lift)</span></div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;              <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af635c66743cb57b7ffc0c16343055a8d">computed_global_QoI_errors</a>[j] = projected_residual.dot(system.get_adjoint_solution(j));</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;              <span class="comment">// Add the lift back to get back the adjoint</span></div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;              system.get_adjoint_solution(j) += system.get_vector(liftfunc_name.str());</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;            }</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;          <span class="keywordflow">else</span></div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;            {</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;              <span class="comment">// Usual dual weighted residual error estimate</span></div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;              <span class="comment">// |Q(u) - Q(u^h)| = |R([u^h]+, z^h+)| + HOT</span></div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;              <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af635c66743cb57b7ffc0c16343055a8d">computed_global_QoI_errors</a>[j] = projected_residual.dot(system.get_adjoint_solution(j));</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;            }</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;        }</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    }</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;  <span class="comment">// Done with the global error estimates, now construct the element wise error indicators</span></div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;  <span class="comment">// To get a better element wise breakdown of the error estimate,</span></div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;  <span class="comment">// we subtract off a coarse representation of the adjoint solution.</span></div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;  <span class="comment">// |Q(u) - Q(u^h)| = |R([u^h]+, z^h+ - [z^h]+)|</span></div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;  <span class="comment">// This remains valid for all combinations of heterogenous adjoint bcs and</span></div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;  <span class="comment">// stabilized/non-stabilized formulations, except for the case where we not using a</span></div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;  <span class="comment">// heterogenous adjoint bc and have a stabilized formulation.</span></div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;  <span class="comment">// Then, R(u^h_s, z^h_s)  != 0 (no Galerkin orthogonality w.r.t the non-stabilized residual)</span></div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j != system.n_qois(); j++)</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;    {</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;      <span class="comment">// Skip this QoI if not in the QoI Set</span></div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>.<a class="code" href="classlibMesh_1_1QoISet.html#afb2189ec653ed963db3754cc6949bc8b">has_index</a>(j))</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;        {</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;          <span class="comment">// If we have a nullptr residual evaluation physics pointer, we</span></div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;          <span class="comment">// assume the user&#39;s formulation is consistent from mesh to</span></div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;          <span class="comment">// mesh, so we have Galerkin orthogonality and we can get</span></div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;          <span class="comment">// better indicator results by subtracting a coarse adjoint.</span></div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;          <span class="comment">// If we have a residual evaluation physics pointer, but we</span></div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;          <span class="comment">// also have heterogeneous adjoint dirichlet boundaries,</span></div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;          <span class="comment">// then we have to subtract off *some* lift function for</span></div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;          <span class="comment">// consistency, and we choose the coarse adjoint in lieu of</span></div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;          <span class="comment">// having any better ideas.</span></div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;          <span class="comment">// If we have a residual evaluation physics pointer and we</span></div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;          <span class="comment">// have homogeneous adjoint dirichlet boundaries, then we</span></div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;          <span class="comment">// don&#39;t have to subtract off anything, and with stabilized</span></div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;          <span class="comment">// formulations we get the best results if we don&#39;t.</span></div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;          <span class="keywordflow">if</span>(system.get_dof_map().has_adjoint_dirichlet_boundaries(j)</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;             || !<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">_residual_evaluation_physics</a>)</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;            {</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;              <span class="comment">// z^h+ -&gt; z^h+ - [z^h]+</span></div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;              system.get_adjoint_solution(j) -= *coarse_adjoints[j];</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;            }</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        }</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    }</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;  <span class="comment">// We ought to account for &#39;spill-over&#39; effects while computing the</span></div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;  <span class="comment">// element error indicators This happens because the same dof is</span></div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;  <span class="comment">// shared by multiple elements, one way of mitigating this is to</span></div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;  <span class="comment">// scale the contribution from each dof by the number of elements it</span></div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;  <span class="comment">// belongs to We first obtain the number of elements each node</span></div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;  <span class="comment">// belongs to</span></div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;  <span class="comment">// A map that relates a node id to an int that will tell us how many elements it is a node of</span></div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;  std::unordered_map&lt;dof_id_type, unsigned int&gt; shared_element_count;</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;  <span class="comment">// To fill this map, we will loop over elements, and then in each element, we will loop</span></div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;  <span class="comment">// over the nodes each element contains, and then query it for the number of coarse</span></div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;  <span class="comment">// grid elements it was a node of</span></div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;  <span class="comment">// Keep track of which nodes we have already dealt with</span></div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;  std::unordered_set&lt;dof_id_type&gt; processed_node_ids;</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;  <span class="comment">// We will be iterating over all the active elements in the fine mesh that live on</span></div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;  <span class="comment">// this processor.</span></div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; elem : <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.active_local_element_ptr_range())</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n=0; n != elem-&gt;n_nodes(); ++n)</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;      {</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;        <span class="comment">// Get a reference to the current node</span></div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;        <span class="keyword">const</span> Node &amp; node = elem-&gt;node_ref(n);</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;        <span class="comment">// Get the id of this node</span></div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;        <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> node_id = node.id();</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;        <span class="comment">// If we havent already processed this node, do so now</span></div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;        <span class="keywordflow">if</span> (processed_node_ids.find(node_id) == processed_node_ids.end())</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;          {</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;            <span class="comment">// Declare a neighbor_set to be filled by the find_point_neighbors</span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;            std::set&lt;const Elem *&gt; fine_grid_neighbor_set;</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;            <span class="comment">// Call find_point_neighbors to fill the neighbor_set</span></div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;            elem-&gt;find_point_neighbors(node, fine_grid_neighbor_set);</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;            <span class="comment">// A vector to hold the coarse grid parents neighbors</span></div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;            std::vector&lt;dof_id_type&gt; coarse_grid_neighbors;</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;            <span class="comment">// Loop over all the fine neighbors of this node</span></div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; fine_elem : fine_grid_neighbor_set)</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;              {</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;                <span class="comment">// Find the element id for the corresponding coarse grid element</span></div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;                <span class="keyword">const</span> Elem * coarse_elem = fine_elem;</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j != <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a>; ++j)</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;                  {</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;                    libmesh_assert (coarse_elem-&gt;parent());</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;                    coarse_elem = coarse_elem-&gt;parent();</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;                  }</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;                <span class="comment">// Loop over the existing coarse neighbors and check if this one is</span></div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;                <span class="comment">// already in there</span></div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;                <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> coarse_id = coarse_elem-&gt;id();</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;                std::size_t j = 0;</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;                <span class="comment">// If the set already contains this element break out of the loop</span></div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;                <span class="keywordflow">for</span> (; j != coarse_grid_neighbors.size(); j++)</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;                  <span class="keywordflow">if</span> (coarse_grid_neighbors[j] == coarse_id)</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;                    <span class="keywordflow">break</span>;</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;                <span class="comment">// If we didn&#39;t leave the loop even at the last element,</span></div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;                <span class="comment">// this is a new neighbour, put in the coarse_grid_neighbor_set</span></div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;                <span class="keywordflow">if</span> (j == coarse_grid_neighbors.size())</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;                  coarse_grid_neighbors.push_back(coarse_id);</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;              } <span class="comment">// End loop over fine neighbors</span></div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;            <span class="comment">// Set the shared_neighbour index for this node to the</span></div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;            <span class="comment">// size of the coarse grid neighbor set</span></div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;            shared_element_count[node_id] =</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;              cast_int&lt;unsigned int&gt;(coarse_grid_neighbors.size());</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;            <span class="comment">// Add this node to processed_node_ids vector</span></div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;            processed_node_ids.insert(node_id);</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;          } <span class="comment">// End if not processed node</span></div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;      } <span class="comment">// End loop over nodes</span></div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;  <span class="comment">// Get a DoF map, will be used to get the nodal dof_indices for each element</span></div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;  DofMap &amp; dof_map = system.get_dof_map();</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;  <span class="comment">// The global DOF indices, we will use these later on when we compute the element wise indicators</span></div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;  std::vector&lt;dof_id_type&gt; dof_indices;</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;  <span class="comment">// Localize the global rhs and adjoint solution vectors (which might be shared on multiple processors) onto a</span></div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;  <span class="comment">// local ghosted vector, this ensures each processor has all the dof_indices to compute an error indicator for</span></div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;  <span class="comment">// an element it owns</span></div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;  std::unique_ptr&lt;NumericVector&lt;Number&gt;&gt; localized_projected_residual = <a class="code" href="classlibMesh_1_1NumericVector.html#adba4a30965537656bb3b0c6f924ff040">NumericVector&lt;Number&gt;::build</a>(system.comm());</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;  localized_projected_residual-&gt;init(system.n_dofs(), system.n_local_dofs(), system.get_dof_map().get_send_list(), <span class="keyword">false</span>, <a class="code" href="namespacelibMesh.html#a2f87e215292aa3e352afd4f8f14c3d7fa7ad89a14059d5c662d16a35675f8370d">GHOSTED</a>);</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;  projected_residual.localize(*localized_projected_residual, system.get_dof_map().get_send_list());</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;  <span class="comment">// Each adjoint solution will also require ghosting; for efficiency we&#39;ll reuse the same memory</span></div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;  std::unique_ptr&lt;NumericVector&lt;Number&gt;&gt; localized_adjoint_solution = <a class="code" href="classlibMesh_1_1NumericVector.html#adba4a30965537656bb3b0c6f924ff040">NumericVector&lt;Number&gt;::build</a>(system.comm());</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;  localized_adjoint_solution-&gt;init(system.n_dofs(), system.n_local_dofs(), system.get_dof_map().get_send_list(), <span class="keyword">false</span>, <a class="code" href="namespacelibMesh.html#a2f87e215292aa3e352afd4f8f14c3d7fa7ad89a14059d5c662d16a35675f8370d">GHOSTED</a>);</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;  <span class="comment">// We will loop over each adjoint solution, localize that adjoint</span></div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;  <span class="comment">// solution and then loop over local elements</span></div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i != system.n_qois(); i++)</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;    {</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;      <span class="comment">// Skip this QoI if not in the QoI Set</span></div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>.<a class="code" href="classlibMesh_1_1QoISet.html#afb2189ec653ed963db3754cc6949bc8b">has_index</a>(i))</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;        {</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;          <span class="comment">// Get the weight for the current QoI</span></div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;          <a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> error_weight = <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>.<a class="code" href="classlibMesh_1_1QoISet.html#a3c4222c23feb8c3aab09b7589526f113">weight</a>(i);</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;          (system.get_adjoint_solution(i)).localize(*localized_adjoint_solution, system.get_dof_map().get_send_list());</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;          <span class="comment">// Loop over elements</span></div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; elem : <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.active_local_element_ptr_range())</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;            {</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;              <span class="comment">// Go up number_h_refinements levels up to find the coarse parent</span></div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;              <span class="keyword">const</span> Elem * coarse = elem;</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j != <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a>; ++j)</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;                {</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;                  libmesh_assert (coarse-&gt;parent());</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;                  coarse = coarse-&gt;parent();</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;                }</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;              <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> e_id = coarse-&gt;id();</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;              <span class="comment">// Get the local to global degree of freedom maps for this element</span></div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;              dof_map.dof_indices (elem, dof_indices);</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;              <span class="comment">// We will have to manually do the dot products.</span></div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;              <a class="code" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> local_contribution = 0.;</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;              <span class="comment">// Sum the contribution to the error indicator for each element from the current QoI</span></div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;              <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; dof : dof_indices)</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;                local_contribution += (*localized_projected_residual)(dof) * (*localized_adjoint_solution)(dof);</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;              <span class="comment">// Multiply by the error weight for this QoI</span></div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;              local_contribution *= error_weight;</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;              <span class="comment">// FIXME: we&#39;re throwing away information in the</span></div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;              <span class="comment">// --enable-complex case</span></div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;              error_per_cell[e_id] += <span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibMesh.html#a26acf05f075521cbfb223db57e63d6d0">ErrorVectorReal</a><span class="keyword">&gt;</span></div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;                (<a class="code" href="namespacestd.html#a267975f6c8fdf9f989e14d438036706a">std::abs</a>(local_contribution));</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;            } <span class="comment">// End loop over elements</span></div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;        } <span class="comment">// End if belong to QoI set</span></div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;    } <span class="comment">// End loop over QoIs</span></div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;  <span class="comment">// Don&#39;t bother projecting the solution; we&#39;ll restore from backup</span></div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;  <span class="comment">// after coarsening</span></div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;  system.project_solution_on_reinit() = <span class="keyword">false</span>;</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;  <span class="comment">// Uniformly coarsen the mesh, without projecting the solution</span></div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;  libmesh_assert (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a> &gt; 0 || <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">number_p_refinements</a> &gt; 0);</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i != <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a>; ++i)</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;    {</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;      mesh_refinement.uniformly_coarsen(1);</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;      <span class="comment">// FIXME - should the reinits here be necessary? - RHS</span></div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;      es.reinit();</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;    }</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i != <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">number_p_refinements</a>; ++i)</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;    {</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;      mesh_refinement.uniformly_p_coarsen(1);</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;      es.reinit();</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;    }</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;  <span class="comment">// We should have the same number of active elements as when we started,</span></div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;  <span class="comment">// but not necessarily the same number of elements since reinit() doesn&#39;t</span></div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;  <span class="comment">// always call contract()</span></div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;  libmesh_assert_equal_to (n_coarse_elem, <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.n_active_elem());</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;  <span class="comment">// We should have the same number of dof-bearing nodes as when we</span></div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;  <span class="comment">// started</span></div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;<span class="preprocessor">#ifndef NDEBUG</span></div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;  <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> final_local_dof_bearing_nodes = 0;</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> * node : <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.local_node_ptr_range())</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0, nvars = node-&gt;n_vars(sysnum);</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;         v != nvars; ++v)</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;      <span class="keywordflow">if</span> (node-&gt;n_comp(sysnum, v))</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;        {</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;          final_local_dof_bearing_nodes++;</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;          <span class="keywordflow">break</span>;</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;        }</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;  libmesh_assert_equal_to (local_dof_bearing_nodes,</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;                           final_local_dof_bearing_nodes);</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;<span class="preprocessor">#endif // NDEBUG</span></div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;  <span class="comment">// Restore old solutions and clean up the heap</span></div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;  system.project_solution_on_reinit() = old_projection_setting;</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;  <span class="comment">// Restore the coarse solution vectors and delete their copies</span></div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;  *system.solution = *coarse_solution;</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;  *system.current_local_solution = *coarse_local_solution;</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code" href="namespacelibMesh.html#a977361a82b7a9e7ad8e50ae1cae40d20">as_range</a>(system.vectors_begin(), system.vectors_end()))</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;    {</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;      <span class="comment">// The (string) name of this vector</span></div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;      <span class="keyword">const</span> std::string &amp; var_name = pr.first;</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;      <span class="comment">// If it&#39;s a vector we already had (and not a newly created</span></div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;      <span class="comment">// vector like an adjoint rhs), we need to restore it.</span></div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;      <span class="keyword">auto</span> it = coarse_vectors.find(var_name);</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;      <span class="keywordflow">if</span> (it != coarse_vectors.end())</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;        {</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;          NumericVector&lt;Number&gt; * coarsevec = it-&gt;second.get();</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;          system.get_vector(var_name) = *coarsevec;</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;          coarsevec-&gt;clear();</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;        }</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;    }</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;  <span class="comment">// Restore old partitioner and renumbering settings</span></div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;  <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.partitioner().reset(old_partitioner.release());</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;  <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.allow_renumbering(old_renumbering_setting);</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;  <span class="comment">// Finally sum the vector of estimated error values.</span></div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a6a5807a86e0751edc399afa2ac44ae89">reduce_error</a>(error_per_cell, system.comm());</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;  <span class="comment">// We don&#39;t take a square root here; this is a goal-oriented</span></div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;  <span class="comment">// estimate not a Hilbert norm estimate.</span></div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;} <span class="comment">// end estimate_error function</span></div><div class="ttc" id="namespacestd_html_a267975f6c8fdf9f989e14d438036706a"><div class="ttname"><a href="namespacestd.html#a267975f6c8fdf9f989e14d438036706a">std::abs</a></div><div class="ttdeci">double abs(double a)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__augment__std__namespace_8h_source.html#l00059">libmesh_augment_std_namespace.h:59</a></div></div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_ad51061a9299eba61c328edca03b0cd20"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">libMesh::AdjointRefinementEstimator::_qoi_set</a></div><div class="ttdeci">QoISet _qoi_set</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00150">adjoint_refinement_estimator.h:150</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a26acf05f075521cbfb223db57e63d6d0"><div class="ttname"><a href="namespacelibMesh.html#a26acf05f075521cbfb223db57e63d6d0">libMesh::ErrorVectorReal</a></div><div class="ttdeci">DIE A HORRIBLE DEATH HERE typedef float ErrorVectorReal</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00202">libmesh_common.h:202</a></div></div>
<div class="ttc" id="classlibMesh_1_1QoISet_html_afb2189ec653ed963db3754cc6949bc8b"><div class="ttname"><a href="classlibMesh_1_1QoISet.html#afb2189ec653ed963db3754cc6949bc8b">libMesh::QoISet::has_index</a></div><div class="ttdeci">bool has_index(std::size_t) const</div><div class="ttdef"><b>Definition:</b> <a href="qoi__set_8h_source.html#l00221">qoi_set.h:221</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a2f87e215292aa3e352afd4f8f14c3d7fa7ad89a14059d5c662d16a35675f8370d"><div class="ttname"><a href="namespacelibMesh.html#a2f87e215292aa3e352afd4f8f14c3d7fa7ad89a14059d5c662d16a35675f8370d">libMesh::GHOSTED</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__parallel__type_8h_source.html#l00037">enum_parallel_type.h:37</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1TriangleWrapper_html_ae06da07f4c64d00ebefa55ce7f5c5e6b"><div class="ttname"><a href="namespacelibMesh_1_1TriangleWrapper.html#ae06da07f4c64d00ebefa55ce7f5c5e6b">libMesh::TriangleWrapper::init</a></div><div class="ttdeci">void init(triangulateio &amp;t)</div></div>
<div class="ttc" id="namespacelibMesh_html_a977361a82b7a9e7ad8e50ae1cae40d20"><div class="ttname"><a href="namespacelibMesh.html#a977361a82b7a9e7ad8e50ae1cae40d20">libMesh::as_range</a></div><div class="ttdeci">SimpleRange&lt; I &gt; as_range(const std::pair&lt; I, I &gt; &amp;p)</div><div class="ttdef"><b>Definition:</b> <a href="simple__range_8h_source.html#l00057">simple_range.h:57</a></div></div>
<div class="ttc" id="classlibMesh_1_1ErrorEstimator_html_a6a5807a86e0751edc399afa2ac44ae89"><div class="ttname"><a href="classlibMesh_1_1ErrorEstimator.html#a6a5807a86e0751edc399afa2ac44ae89">libMesh::ErrorEstimator::reduce_error</a></div><div class="ttdeci">void reduce_error(std::vector&lt; ErrorVectorReal &gt; &amp;error_per_cell, const Parallel::Communicator &amp;comm) const</div><div class="ttdef"><b>Definition:</b> <a href="error__estimator_8C_source.html#l00032">error_estimator.C:32</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_af73f953ce5c33a52ea2b53364c1aff9c"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">libMesh::AdjointRefinementEstimator::_residual_evaluation_physics</a></div><div class="ttdeci">DifferentiablePhysics * _residual_evaluation_physics</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00142">adjoint_refinement_estimator.h:142</a></div></div>
<div class="ttc" id="classlibMesh_1_1NumericVector_html_adba4a30965537656bb3b0c6f924ff040"><div class="ttname"><a href="classlibMesh_1_1NumericVector.html#adba4a30965537656bb3b0c6f924ff040">libMesh::NumericVector::build</a></div><div class="ttdeci">static std::unique_ptr&lt; NumericVector&lt; T &gt; &gt; build(const Parallel::Communicator &amp;comm, const SolverPackage solver_package=libMesh::default_solver_package())</div><div class="ttdef"><b>Definition:</b> <a href="numeric__vector_8C_source.html#l00048">numeric_vector.C:48</a></div></div>
<div class="ttc" id="classlibMesh_1_1QoISet_html_a3c4222c23feb8c3aab09b7589526f113"><div class="ttname"><a href="classlibMesh_1_1QoISet.html#a3c4222c23feb8c3aab09b7589526f113">libMesh::QoISet::weight</a></div><div class="ttdeci">Real weight(std::size_t) const</div><div class="ttdef"><b>Definition:</b> <a href="qoi__set_8h_source.html#l00240">qoi_set.h:240</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_af635c66743cb57b7ffc0c16343055a8d"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#af635c66743cb57b7ffc0c16343055a8d">libMesh::AdjointRefinementEstimator::computed_global_QoI_errors</a></div><div class="ttdeci">std::vector&lt; Number &gt; computed_global_QoI_errors</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00145">adjoint_refinement_estimator.h:145</a></div></div>
<div class="ttc" id="namespacelibMesh_html_aef28359fb4851abec08fc99cfbac118d"><div class="ttname"><a href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">libMesh::Real</a></div><div class="ttdeci">DIE A HORRIBLE DEATH HERE typedef LIBMESH_DEFAULT_SCALAR_TYPE Real</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00131">libmesh_common.h:131</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a8b17bf24a15bc292850c3a3894e2e8f9"><div class="ttname"><a href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">libMesh::Number</a></div><div class="ttdeci">Real Number</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00191">libmesh_common.h:191</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_a4437c7888b7459952e06a9157bf61ffe"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">libMesh::AdjointRefinementEstimator::number_h_refinements</a></div><div class="ttdeci">unsigned char number_h_refinements</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00116">adjoint_refinement_estimator.h:116</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00064">id_types.h:64</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_abff7ac97985f693cd3cc7a8311a24558"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">libMesh::AdjointRefinementEstimator::number_p_refinements</a></div><div class="ttdeci">unsigned char number_p_refinements</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00121">adjoint_refinement_estimator.h:121</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a513952f2b4a0b30834c04e1411cd030f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513952f2b4a0b30834c04e1411cd030f">&#9670;&nbsp;</a></span>estimate_errors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::ErrorEstimator::estimate_errors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1EquationSystems.html">EquationSystems</a> &amp;&#160;</td>
          <td class="paramname"><em>equation_systems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a> &amp;&#160;</td>
          <td class="paramname"><em>error_per_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; const <a class="el" href="classlibMesh_1_1System.html">System</a> *, <a class="el" href="classlibMesh_1_1SystemNorm.html">SystemNorm</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>error_norms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; const <a class="el" href="classlibMesh_1_1System.html">System</a> *, const <a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a>&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; *&gt; *&#160;</td>
          <td class="paramname"><em>solution_vectors</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>estimate_parent_error</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This virtual function can be redefined in derived classes, but by default computes the sum of the error_per_cell for each system in the equation_systems.</p>
<p>Currently this function ignores the error_norm member variable, and uses the function argument error_norms instead.</p>
<p>This function is named estimate_errors instead of estimate_error because otherwise C++ can get confused. </p>

<p>Reimplemented in <a class="el" href="classlibMesh_1_1UniformRefinementEstimator.html#a8a8763fa2f4a7999a38bdc8afe7d2566">libMesh::UniformRefinementEstimator</a>.</p>

<p class="definition">Definition at line <a class="el" href="error__estimator_8C_source.html#l00047">47</a> of file <a class="el" href="error__estimator_8C_source.html">error_estimator.C</a>.</p>

<p class="reference">References <a class="el" href="error__estimator_8h_source.html#l00161">libMesh::ErrorEstimator::error_norm</a>, <a class="el" href="classlibMesh_1_1ErrorEstimator.html#ab5ee8217ac35baaa00cc3b72e9815d93">libMesh::ErrorEstimator::estimate_error()</a>, <a class="el" href="equation__systems_8h_source.html#l00742">libMesh::EquationSystems::get_system()</a>, <a class="el" href="int__range_8h_source.html#l00104">libMesh::index_range()</a>, and <a class="el" href="equation__systems_8h_source.html#l00637">libMesh::EquationSystems::n_systems()</a>.</p>
<div class="fragment"><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;{</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  SystemNorm old_error_norm = this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a>;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  <span class="comment">// Sum the error values from each system</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> s = 0; s != equation_systems.n_systems(); ++s)</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    {</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;      ErrorVector system_error_per_cell;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;      <span class="keyword">const</span> System &amp; sys = equation_systems.get_system(s);</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;      <span class="keywordflow">if</span> (error_norms.find(&amp;sys) == error_norms.end())</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a> = old_error_norm;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a> = error_norms.find(&amp;sys)-&gt;second;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;      <span class="keyword">const</span> NumericVector&lt;Number&gt; * solution_vector = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;      <span class="keywordflow">if</span> (solution_vectors &amp;&amp;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;          solution_vectors-&gt;find(&amp;sys) != solution_vectors-&gt;end())</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;        solution_vector = solution_vectors-&gt;find(&amp;sys)-&gt;second;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;      this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#ab5ee8217ac35baaa00cc3b72e9815d93">estimate_error</a>(sys, system_error_per_cell,</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;                           solution_vector, estimate_parent_error);</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;      <span class="keywordflow">if</span> (s)</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        {</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;          libmesh_assert_equal_to (error_per_cell.size(), system_error_per_cell.size());</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;          <span class="keywordflow">for</span> (<span class="keyword">auto</span> i : <a class="code" href="namespacelibMesh.html#ab64fa61b4505bc7554e508972dfaecd5">index_range</a>(error_per_cell))</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;            error_per_cell[i] += system_error_per_cell[i];</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        }</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        error_per_cell = system_error_per_cell;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    }</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <span class="comment">// Restore our old state before returning</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a> = old_error_norm;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;}</div><div class="ttc" id="classlibMesh_1_1ErrorEstimator_html_a9d626496b0b6f99f679c4ef4f0a5e46e"><div class="ttname"><a href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">libMesh::ErrorEstimator::error_norm</a></div><div class="ttdeci">SystemNorm error_norm</div><div class="ttdef"><b>Definition:</b> <a href="error__estimator_8h_source.html#l00161">error_estimator.h:161</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab64fa61b4505bc7554e508972dfaecd5"><div class="ttname"><a href="namespacelibMesh.html#ab64fa61b4505bc7554e508972dfaecd5">libMesh::index_range</a></div><div class="ttdeci">IntRange&lt; std::size_t &gt; index_range(const std::vector&lt; T &gt; &amp;vec)</div><div class="ttdef"><b>Definition:</b> <a href="int__range_8h_source.html#l00104">int_range.h:104</a></div></div>
<div class="ttc" id="classlibMesh_1_1ErrorEstimator_html_ab5ee8217ac35baaa00cc3b72e9815d93"><div class="ttname"><a href="classlibMesh_1_1ErrorEstimator.html#ab5ee8217ac35baaa00cc3b72e9815d93">libMesh::ErrorEstimator::estimate_error</a></div><div class="ttdeci">virtual void estimate_error(const System &amp;system, ErrorVector &amp;error_per_cell, const NumericVector&lt; Number &gt; *solution_vector=nullptr, bool estimate_parent_error=false)=0</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa1ddba9905e39aa89ed2aff7438b1b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ddba9905e39aa89ed2aff7438b1b6e">&#9670;&nbsp;</a></span>estimate_errors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::ErrorEstimator::estimate_errors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1EquationSystems.html">EquationSystems</a> &amp;&#160;</td>
          <td class="paramname"><em>equation_systems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1ErrorEstimator.html#a662486f8192c2f70733efa723a9fb336">ErrorMap</a> &amp;&#160;</td>
          <td class="paramname"><em>errors_per_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; const <a class="el" href="classlibMesh_1_1System.html">System</a> *, const <a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a>&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; *&gt; *&#160;</td>
          <td class="paramname"><em>solution_vectors</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>estimate_parent_error</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This virtual function can be redefined in derived classes, but by default it calls estimate_error repeatedly to calculate the requested error vectors.</p>
<p>Currently this function ignores the <a class="el" href="namespacelibMesh_1_1MeshTools.html#a0701de7f01fd5eced3da4a332ff5ae51">error_norm.weight()</a> values because it calculates each variable's error individually, unscaled.</p>
<p>The user selects which errors get computed by filling a map with error vectors: If errors_per_cell[&amp;system][v] exists, it will be filled with the error values in variable <code>v</code> of <code>system</code> </p>
<p>FIXME: This is a default implementation - derived classes should reimplement it for efficiency. </p>

<p>Reimplemented in <a class="el" href="classlibMesh_1_1UniformRefinementEstimator.html#a7a12902561609d903b2a0404bfe808f0">libMesh::UniformRefinementEstimator</a>.</p>

<p class="definition">Definition at line <a class="el" href="error__estimator_8C_source.html#l00093">93</a> of file <a class="el" href="error__estimator_8C_source.html">error_estimator.C</a>.</p>

<p class="reference">References <a class="el" href="error__estimator_8h_source.html#l00161">libMesh::ErrorEstimator::error_norm</a>, <a class="el" href="classlibMesh_1_1ErrorEstimator.html#ab5ee8217ac35baaa00cc3b72e9815d93">libMesh::ErrorEstimator::estimate_error()</a>, <a class="el" href="equation__systems_8h_source.html#l00742">libMesh::EquationSystems::get_system()</a>, <a class="el" href="equation__systems_8h_source.html#l00637">libMesh::EquationSystems::n_systems()</a>, <a class="el" href="tecplot__io_8C_source.html#l00069">n_vars</a>, <a class="el" href="system_8h_source.html#l02105">libMesh::System::n_vars()</a>, and <a class="el" href="system__norm_8C_source.html#l00110">libMesh::SystemNorm::type()</a>.</p>
<div class="fragment"><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;{</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;  SystemNorm old_error_norm = this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a>;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;  <span class="comment">// Find the requested error values from each system</span></div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> s = 0; s != equation_systems.n_systems(); ++s)</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    {</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;      <span class="keyword">const</span> System &amp; sys = equation_systems.get_system(s);</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="tecplot__io_8C.html#ac001e4247887b98c2aa5b8ec5107ca0d">n_vars</a> = sys.n_vars();</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0; v != <a class="code" href="tecplot__io_8C.html#ac001e4247887b98c2aa5b8ec5107ca0d">n_vars</a>; ++v)</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        {</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;          <span class="comment">// Only fill in ErrorVectors the user asks for</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;          <span class="keywordflow">if</span> (errors_per_cell.find(std::make_pair(&amp;sys, v)) ==</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;              errors_per_cell.end())</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;          <span class="comment">// Calculate error in only one variable</span></div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;          std::vector&lt;Real&gt; weights(<a class="code" href="tecplot__io_8C.html#ac001e4247887b98c2aa5b8ec5107ca0d">n_vars</a>, 0.0);</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;          weights[v] = 1.0;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;          this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a> =</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;            SystemNorm(std::vector&lt;FEMNormType&gt;(<a class="code" href="tecplot__io_8C.html#ac001e4247887b98c2aa5b8ec5107ca0d">n_vars</a>, old_error_norm.type(v)),</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;                       weights);</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;          <span class="keyword">const</span> NumericVector&lt;Number&gt; * solution_vector = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;          <span class="keywordflow">if</span> (solution_vectors &amp;&amp;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;              solution_vectors-&gt;find(&amp;sys) != solution_vectors-&gt;end())</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;            solution_vector = solution_vectors-&gt;find(&amp;sys)-&gt;second;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;          this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#ab5ee8217ac35baaa00cc3b72e9815d93">estimate_error</a></div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;            (sys, *errors_per_cell[std::make_pair(&amp;sys, v)],</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;             solution_vector, estimate_parent_error);</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        }</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    }</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;  <span class="comment">// Restore our old state before returning</span></div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a> = old_error_norm;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;}</div><div class="ttc" id="classlibMesh_1_1ErrorEstimator_html_a9d626496b0b6f99f679c4ef4f0a5e46e"><div class="ttname"><a href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">libMesh::ErrorEstimator::error_norm</a></div><div class="ttdeci">SystemNorm error_norm</div><div class="ttdef"><b>Definition:</b> <a href="error__estimator_8h_source.html#l00161">error_estimator.h:161</a></div></div>
<div class="ttc" id="classlibMesh_1_1ErrorEstimator_html_ab5ee8217ac35baaa00cc3b72e9815d93"><div class="ttname"><a href="classlibMesh_1_1ErrorEstimator.html#ab5ee8217ac35baaa00cc3b72e9815d93">libMesh::ErrorEstimator::estimate_error</a></div><div class="ttdeci">virtual void estimate_error(const System &amp;system, ErrorVector &amp;error_per_cell, const NumericVector&lt; Number &gt; *solution_vector=nullptr, bool estimate_parent_error=false)=0</div></div>
<div class="ttc" id="tecplot__io_8C_html_ac001e4247887b98c2aa5b8ec5107ca0d"><div class="ttname"><a href="tecplot__io_8C.html#ac001e4247887b98c2aa5b8ec5107ca0d">n_vars</a></div><div class="ttdeci">const unsigned int n_vars</div><div class="ttdef"><b>Definition:</b> <a href="tecplot__io_8C_source.html#l00069">tecplot_io.C:69</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0143c56bd2fdc236700dd3b1262d7097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0143c56bd2fdc236700dd3b1262d7097">&#9670;&nbsp;</a></span>get_global_QoI_error_estimate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a>&amp; libMesh::AdjointRefinementEstimator::get_global_QoI_error_estimate </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>qoi_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an accessor function to access the computed global QoI error estimates </p>

<p class="definition">Definition at line <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00106">106</a> of file <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>.</p>

<p class="reference">References <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00145">computed_global_QoI_errors</a>.</p>
<div class="fragment"><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  {</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af635c66743cb57b7ffc0c16343055a8d">computed_global_QoI_errors</a>[qoi_index];</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;  }</div><div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_af635c66743cb57b7ffc0c16343055a8d"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#af635c66743cb57b7ffc0c16343055a8d">libMesh::AdjointRefinementEstimator::computed_global_QoI_errors</a></div><div class="ttdeci">std::vector&lt; Number &gt; computed_global_QoI_errors</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00145">adjoint_refinement_estimator.h:145</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac4d2e7401de04e31b0a1c81650ec72e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d2e7401de04e31b0a1c81650ec72e8">&#9670;&nbsp;</a></span>get_residual_evaluation_physics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1DifferentiablePhysics.html">DifferentiablePhysics</a>* libMesh::AdjointRefinementEstimator::get_residual_evaluation_physics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="classlibMesh_1_1DifferentiablePhysics.html">DifferentiablePhysics</a> object or <code>nullptr</code> if no external Physics object is attached. </dd></dl>

<p class="definition">Definition at line <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00127">127</a> of file <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>.</p>

<p class="reference">References <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00142">_residual_evaluation_physics</a>.</p>
<div class="fragment"><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;  { <span class="keywordflow">return</span> this-&gt;<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">_residual_evaluation_physics</a>; }</div><div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_af73f953ce5c33a52ea2b53364c1aff9c"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">libMesh::AdjointRefinementEstimator::_residual_evaluation_physics</a></div><div class="ttdeci">DifferentiablePhysics * _residual_evaluation_physics</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00142">adjoint_refinement_estimator.h:142</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4afd6c830b8dddbfb1014edf18f8f69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4afd6c830b8dddbfb1014edf18f8f69c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a>&amp; libMesh::AdjointRefinementEstimator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a07208352932dfb91f3b7035729f137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a07208352932dfb91f3b7035729f137">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a>&amp; libMesh::AdjointRefinementEstimator::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0aca6ed2c5e83a66cbea3fb745d42bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aca6ed2c5e83a66cbea3fb745d42bb6">&#9670;&nbsp;</a></span>qoi_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a>&amp; libMesh::AdjointRefinementEstimator::qoi_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access to the <a class="el" href="classlibMesh_1_1QoISet.html" title="Used to specify quantities of interest in a simulation. ">QoISet</a> (default: weight all QoIs equally) to use when computing errors </p>

<p class="definition">Definition at line <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00073">73</a> of file <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>.</p>

<p class="reference">References <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00150">_qoi_set</a>.</p>
<div class="fragment"><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>; }</div><div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_ad51061a9299eba61c328edca03b0cd20"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">libMesh::AdjointRefinementEstimator::_qoi_set</a></div><div class="ttdeci">QoISet _qoi_set</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00150">adjoint_refinement_estimator.h:150</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="afa40e4da1ac4723fd613cbc51f68b61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa40e4da1ac4723fd613cbc51f68b61f">&#9670;&nbsp;</a></span>qoi_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a>&amp; libMesh::AdjointRefinementEstimator::qoi_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access to the <a class="el" href="classlibMesh_1_1QoISet.html" title="Used to specify quantities of interest in a simulation. ">QoISet</a> (default: weight all QoIs equally) to use when computing errors </p>

<p class="definition">Definition at line <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00079">79</a> of file <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>.</p>

<p class="reference">References <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00150">_qoi_set</a>.</p>
<div class="fragment"><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>; }</div><div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_ad51061a9299eba61c328edca03b0cd20"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">libMesh::AdjointRefinementEstimator::_qoi_set</a></div><div class="ttdeci">QoISet _qoi_set</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00150">adjoint_refinement_estimator.h:150</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6a5807a86e0751edc399afa2ac44ae89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5807a86e0751edc399afa2ac44ae89">&#9670;&nbsp;</a></span>reduce_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::ErrorEstimator::reduce_error </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacelibMesh.html#a26acf05f075521cbfb223db57e63d6d0">ErrorVectorReal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>error_per_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Parallel::Communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method takes the local error contributions in <code>error_per_cell</code> from each processor and combines them to get the global error vector. </p>

<p class="definition">Definition at line <a class="el" href="error__estimator_8C_source.html#l00032">32</a> of file <a class="el" href="error__estimator_8C_source.html">error_estimator.C</a>.</p>

<p class="reference">References <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html#a3f8b3675d745f7d586e93158aa951174">libMesh::Parallel::Communicator::sum()</a>.</p>

<p class="reference">Referenced by <a class="el" href="uniform__refinement__estimator_8C_source.html#l00117">libMesh::UniformRefinementEstimator::_estimate_error()</a>, <a class="el" href="weighted__patch__recovery__error__estimator_8C_source.html#l00055">libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error()</a>, <a class="el" href="patch__recovery__error__estimator_8C_source.html#l00153">libMesh::PatchRecoveryErrorEstimator::estimate_error()</a>, <a class="el" href="jump__error__estimator_8C_source.html#l00053">libMesh::JumpErrorEstimator::estimate_error()</a>, <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00090">estimate_error()</a>, and <a class="el" href="exact__error__estimator_8C_source.html#l00187">libMesh::ExactErrorEstimator::estimate_error()</a>.</p>
<div class="fragment"><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;{</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  <span class="comment">// parallel_object_only();</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  <span class="comment">// Each processor has now computed the error contributions</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  <span class="comment">// for its local elements.  We may need to sum the vector to</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  <span class="comment">// recover the error for each element.</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  comm.sum(error_per_cell);</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a13d69ad607bba49f333dd775ccdd7ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d69ad607bba49f333dd775ccdd7ca1">&#9670;&nbsp;</a></span>set_residual_evaluation_physics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::AdjointRefinementEstimator::set_residual_evaluation_physics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1DifferentiablePhysics.html">DifferentiablePhysics</a> *&#160;</td>
          <td class="paramname"><em>set_physics</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the _residual_evaluation_physics member to argument </p>

<p class="definition">Definition at line <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00133">133</a> of file <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>.</p>

<p class="reference">References <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00142">_residual_evaluation_physics</a>.</p>
<div class="fragment"><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;  { this-&gt;<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">_residual_evaluation_physics</a> = set_physics; }</div><div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_af73f953ce5c33a52ea2b53364c1aff9c"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#af73f953ce5c33a52ea2b53364c1aff9c">libMesh::AdjointRefinementEstimator::_residual_evaluation_physics</a></div><div class="ttdeci">DifferentiablePhysics * _residual_evaluation_physics</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00142">adjoint_refinement_estimator.h:142</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a69c321f3393a9efb5dda3c4b43926f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c321f3393a9efb5dda3c4b43926f4d">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibMesh.html#a370493a82a7f09613a0fdc56fc7912b7">ErrorEstimatorType</a> libMesh::AdjointRefinementEstimator::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The type for the <a class="el" href="classlibMesh_1_1ErrorEstimator.html">ErrorEstimator</a> subclass. </dd></dl>

<p>Implements <a class="el" href="classlibMesh_1_1ErrorEstimator.html#a8a3162f59ee5f231d73ab54252cfa8f1">libMesh::ErrorEstimator</a>.</p>

<p class="definition">Definition at line <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00085">85</a> of file <a class="el" href="adjoint__refinement__estimator_8C_source.html">adjoint_refinement_estimator.C</a>.</p>

<p class="reference">References <a class="el" href="enum__error__estimator__type_8h_source.html#l00035">libMesh::ADJOINT_REFINEMENT</a>.</p>
<div class="fragment"><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;{</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacelibMesh.html#a370493a82a7f09613a0fdc56fc7912b7a1edbba5ae493642ac736dc793aac4063">ADJOINT_REFINEMENT</a>;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;}</div><div class="ttc" id="namespacelibMesh_html_a370493a82a7f09613a0fdc56fc7912b7a1edbba5ae493642ac736dc793aac4063"><div class="ttname"><a href="namespacelibMesh.html#a370493a82a7f09613a0fdc56fc7912b7a1edbba5ae493642ac736dc793aac4063">libMesh::ADJOINT_REFINEMENT</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__error__estimator__type_8h_source.html#l00035">enum_error_estimator_type.h:35</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad51061a9299eba61c328edca03b0cd20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51061a9299eba61c328edca03b0cd20">&#9670;&nbsp;</a></span>_qoi_set</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a> libMesh::AdjointRefinementEstimator::_qoi_set</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A <a class="el" href="classlibMesh_1_1QoISet.html" title="Used to specify quantities of interest in a simulation. ">QoISet</a> to handle cases with multiple QoIs available </p>

<p class="definition">Definition at line <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00150">150</a> of file <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00090">estimate_error()</a>, and <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00073">qoi_set()</a>.</p>

</div>
</div>
<a id="af73f953ce5c33a52ea2b53364c1aff9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73f953ce5c33a52ea2b53364c1aff9c">&#9670;&nbsp;</a></span>_residual_evaluation_physics</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1DifferentiablePhysics.html">DifferentiablePhysics</a>* libMesh::AdjointRefinementEstimator::_residual_evaluation_physics</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to object to use for physics assembly evaluations. Defaults to nullptr for backwards compatibility. </p>

<p class="definition">Definition at line <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00142">142</a> of file <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00090">estimate_error()</a>, <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00127">get_residual_evaluation_physics()</a>, and <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00133">set_residual_evaluation_physics()</a>.</p>

</div>
</div>
<a id="af635c66743cb57b7ffc0c16343055a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af635c66743cb57b7ffc0c16343055a8d">&#9670;&nbsp;</a></span>computed_global_QoI_errors</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a>&gt; libMesh::AdjointRefinementEstimator::computed_global_QoI_errors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00145">145</a> of file <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00090">estimate_error()</a>, and <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00106">get_global_QoI_error_estimate()</a>.</p>

</div>
</div>
<a id="a9d626496b0b6f99f679c4ef4f0a5e46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d626496b0b6f99f679c4ef4f0a5e46e">&#9670;&nbsp;</a></span>error_norm</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1SystemNorm.html">SystemNorm</a> libMesh::ErrorEstimator::error_norm</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When estimating the error in a single system, the <code>error_norm</code> is used to control the scaling and norm choice for each variable. Not all estimators will support all norm choices. The default scaling is for all variables to be weighted equally. The default norm choice depends on the error estimator.</p>
<p>Part of this functionality was supported via component_scale and sobolev_order in older <a class="el" href="namespacelibMesh.html">libMesh</a> versions, and a small part was supported via component_mask in even older versions. Hopefully the encapsulation here will allow us to avoid changing this API again. </p>

<p class="definition">Definition at line <a class="el" href="error__estimator_8h_source.html#l00161">161</a> of file <a class="el" href="error__estimator_8h_source.html">error_estimator.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="uniform__refinement__estimator_8C_source.html#l00117">libMesh::UniformRefinementEstimator::_estimate_error()</a>, <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00073">AdjointRefinementEstimator()</a>, <a class="el" href="discontinuity__measure_8C_source.html#l00129">libMesh::DiscontinuityMeasure::boundary_side_integration()</a>, <a class="el" href="kelly__error__estimator_8C_source.html#l00135">libMesh::KellyErrorEstimator::boundary_side_integration()</a>, <a class="el" href="discontinuity__measure_8C_source.html#l00041">libMesh::DiscontinuityMeasure::DiscontinuityMeasure()</a>, <a class="el" href="jump__error__estimator_8C_source.html#l00053">libMesh::JumpErrorEstimator::estimate_error()</a>, <a class="el" href="adjoint__residual__error__estimator_8C_source.html#l00060">libMesh::AdjointResidualErrorEstimator::estimate_error()</a>, <a class="el" href="exact__error__estimator_8C_source.html#l00187">libMesh::ExactErrorEstimator::estimate_error()</a>, <a class="el" href="error__estimator_8C_source.html#l00047">libMesh::ErrorEstimator::estimate_errors()</a>, <a class="el" href="exact__error__estimator_8C_source.html#l00048">libMesh::ExactErrorEstimator::ExactErrorEstimator()</a>, <a class="el" href="exact__error__estimator_8C_source.html#l00401">libMesh::ExactErrorEstimator::find_squared_element_error()</a>, <a class="el" href="fourth__error__estimators_8C_source.html#l00063">libMesh::LaplacianErrorEstimator::init_context()</a>, <a class="el" href="discontinuity__measure_8C_source.html#l00059">libMesh::DiscontinuityMeasure::init_context()</a>, <a class="el" href="kelly__error__estimator_8C_source.html#l00059">libMesh::KellyErrorEstimator::init_context()</a>, <a class="el" href="fourth__error__estimators_8C_source.html#l00090">libMesh::LaplacianErrorEstimator::internal_side_integration()</a>, <a class="el" href="discontinuity__measure_8C_source.html#l00086">libMesh::DiscontinuityMeasure::internal_side_integration()</a>, <a class="el" href="kelly__error__estimator_8C_source.html#l00090">libMesh::KellyErrorEstimator::internal_side_integration()</a>, <a class="el" href="kelly__error__estimator_8C_source.html#l00041">libMesh::KellyErrorEstimator::KellyErrorEstimator()</a>, <a class="el" href="fourth__error__estimators_8C_source.html#l00046">libMesh::LaplacianErrorEstimator::LaplacianErrorEstimator()</a>, <a class="el" href="weighted__patch__recovery__error__estimator_8C_source.html#l00112">libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()()</a>, <a class="el" href="patch__recovery__error__estimator_8C_source.html#l00210">libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()()</a>, <a class="el" href="patch__recovery__error__estimator_8C_source.html#l00065">libMesh::PatchRecoveryErrorEstimator::PatchRecoveryErrorEstimator()</a>, <a class="el" href="jump__error__estimator_8C_source.html#l00424">libMesh::JumpErrorEstimator::reinit_sides()</a>, and <a class="el" href="uniform__refinement__estimator_8C_source.html#l00053">libMesh::UniformRefinementEstimator::UniformRefinementEstimator()</a>.</p>

</div>
</div>
<a id="a4437c7888b7459952e06a9157bf61ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4437c7888b7459952e06a9157bf61ffe">&#9670;&nbsp;</a></span>number_h_refinements</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char libMesh::AdjointRefinementEstimator::number_h_refinements</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>How many h refinements to perform to get the fine grid </p>

<p class="definition">Definition at line <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00116">116</a> of file <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00090">estimate_error()</a>.</p>

</div>
</div>
<a id="abff7ac97985f693cd3cc7a8311a24558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff7ac97985f693cd3cc7a8311a24558">&#9670;&nbsp;</a></span>number_p_refinements</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char libMesh::AdjointRefinementEstimator::number_p_refinements</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>How many p refinements to perform to get the fine grid </p>

<p class="definition">Definition at line <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00121">121</a> of file <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00090">estimate_error()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a></li>
<li><a class="el" href="adjoint__refinement__estimator_8C_source.html">adjoint_refinement_estimator.C</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
generated by <a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a>
</small></address>
<!-- dynamic header stuff -->
<script type="text/javascript">
$(document).ready(function(){
  $(window).on('scroll',function() {
    var scrolltop = $(this).scrollTop();
    if(scrolltop >= 215) {
      $('#fixedbar').fadeIn(250);
    }
    else if(scrolltop <= 210) {
      $('#fixedbar').fadeOut(250);
    }
  });
});
</script>
<!-- Google Analytics stuff -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-24978333-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
