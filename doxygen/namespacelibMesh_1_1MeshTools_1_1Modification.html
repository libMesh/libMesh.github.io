<!-- HTML header for doxygen -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libMesh: libMesh::MeshTools::Modification Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="../styles.css" rel="stylesheet" type="text/css" />
<link href="doxygen_stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <nav id="fixedbar">
    <ul id="fixednav">
      <li><a href="../index.html">Home</a></li>
      <li><a href="../support.html">About Us</a></li>
      <li><a href="../publications.html">Publications</a></li>
      <li><a href="../developers.html">Developers</a></li>
      <li><a href="../installation.html">Installation</a></li>
      <li><a href="../examples.html">Examples</a></li>
      <li><a href="../doxygen/index.html">Documentation</a></li>
    </ul>
  </nav>
  <div id="w">
    <header id="logo"><a href="index.html"><span id="logobg">SomeWebsiteLogo</span></a></header>
    <nav id="navigation">
      <ul>
        <li><a href="../index.html">Home</a></li>
        <li><a href="../support.html">About Us</a></li>
        <li><a href="../publications.html">Publications</a></li>
        <li><a href="../developers.html">Developers</a></li>
        <li><a href="../installation.html">Installation</a></li>
        <li><a href="../examples.html">Examples</a></li>
        <li><a href="../doxygen/index.html">Documentation</a></li>
      </ul>
    </nav>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- <\!--BEGIN TITLEAREA-\-> -->
<!-- <div id="titlearea"> -->
<!-- <table cellspacing="0" cellpadding="0"> -->
<!--  <tbody> -->
<!--  <tr style="height: 56px;"> -->
<!--   <\!--BEGIN PROJECT_LOGO-\-> -->
<!--   <td id="projectlogo"><img alt="Logo" src=""/></td> -->
<!--   <\!--END PROJECT_LOGO-\-> -->
<!--   <\!--BEGIN PROJECT_NAME-\-> -->
<!--   <td style="padding-left: 0.5em;"> -->
<!--    <div id="projectname">libMesh -->
<!--    <\!--BEGIN PROJECT_NUMBER-\->&#160;<span id="projectnumber"></span><\!--END PROJECT_NUMBER-\-> -->
<!--    </div> -->
<!--    <\!--BEGIN PROJECT_BRIEF-\-><div id="projectbrief"></div><\!--END PROJECT_BRIEF-\-> -->
<!--   </td> -->
<!--   <\!--END PROJECT_NAME-\-> -->
<!--   <\!--BEGIN !PROJECT_NAME-\-> -->
<!--    <\!--BEGIN PROJECT_BRIEF-\-> -->
<!--     <td style="padding-left: 0.5em;"> -->
<!--     <div id="projectbrief"></div> -->
<!--     </td> -->
<!--    <\!--END PROJECT_BRIEF-\-> -->
<!--   <\!--END !PROJECT_NAME-\-> -->
<!--   <\!--BEGIN DISABLE_INDEX-\-> -->
<!--    <\!--BEGIN SEARCHENGINE-\-> -->
<!--    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td> -->
<!--    <\!--END SEARCHENGINE-\-> -->
<!--   <\!--END DISABLE_INDEX-\-> -->
<!--  </tr> -->
<!--  </tbody> -->
<!-- </table> -->
<!-- </div> -->
<!-- <\!--END TITLEAREA-\-> -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibMesh.html">libMesh</a></li><li class="navelem"><a class="el" href="namespacelibMesh_1_1MeshTools.html">MeshTools</a></li><li class="navelem"><a class="el" href="namespacelibMesh_1_1MeshTools_1_1Modification.html">Modification</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">libMesh::MeshTools::Modification Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab3c34bd675ddf6c6675daa7fcc96d7cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1MeshTools_1_1Modification.html#ab3c34bd675ddf6c6675daa7fcc96d7cf">distort</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> factor, const bool perturb_boundary=false)</td></tr>
<tr class="separator:ab3c34bd675ddf6c6675daa7fcc96d7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb33f8faabadb6dbad5d5cf6c0efd9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1MeshTools_1_1Modification.html#a9bb33f8faabadb6dbad5d5cf6c0efd9f">redistribute</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, const <a class="el" href="classlibMesh_1_1FunctionBase.html">FunctionBase</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt; &amp;mapfunc)</td></tr>
<tr class="separator:a9bb33f8faabadb6dbad5d5cf6c0efd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add16d717dcc51dfd7d2bf671fe8e811b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1MeshTools_1_1Modification.html#add16d717dcc51dfd7d2bf671fe8e811b">translate</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> xt=0., const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> yt=0., const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> zt=0.)</td></tr>
<tr class="separator:add16d717dcc51dfd7d2bf671fe8e811b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b9487f3155857fbc4c4201a748bc09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1MeshTools_1_1Modification.html#ad1b9487f3155857fbc4c4201a748bc09">rotate</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> phi, const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> theta=0., const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> psi=0.)</td></tr>
<tr class="separator:ad1b9487f3155857fbc4c4201a748bc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c03ebd8ce97c6c8aef8e2a05a94a16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1MeshTools_1_1Modification.html#a48c03ebd8ce97c6c8aef8e2a05a94a16">scale</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> xs, const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> ys=0., const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> zs=0.)</td></tr>
<tr class="separator:a48c03ebd8ce97c6c8aef8e2a05a94a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249f04550c345984831d08e013155668"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1MeshTools_1_1Modification.html#a249f04550c345984831d08e013155668">all_tri</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>)</td></tr>
<tr class="separator:a249f04550c345984831d08e013155668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e817d4980341bde2cc3fba486d0d8e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1MeshTools_1_1Modification.html#a2e817d4980341bde2cc3fba486d0d8e6">smooth</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;, unsigned int, <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>)</td></tr>
<tr class="separator:a2e817d4980341bde2cc3fba486d0d8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ce3f7f69838b3326f9bcabae3f2cd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1MeshTools_1_1Modification.html#a31ce3f7f69838b3326f9bcabae3f2cd6">flatten</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>)</td></tr>
<tr class="separator:a31ce3f7f69838b3326f9bcabae3f2cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355d0c7c33b55d44e9e77946caadbef6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1MeshTools_1_1Modification.html#a355d0c7c33b55d44e9e77946caadbef6">change_boundary_id</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, const <a class="el" href="namespacelibMesh.html#a3f4d8a52b5ef6ff6156ca209e12b5564">boundary_id_type</a> old_id, const <a class="el" href="namespacelibMesh.html#a3f4d8a52b5ef6ff6156ca209e12b5564">boundary_id_type</a> new_id)</td></tr>
<tr class="separator:a355d0c7c33b55d44e9e77946caadbef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30caf6b7a7280e592b7c177ff85b97a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1MeshTools_1_1Modification.html#a30caf6b7a7280e592b7c177ff85b97a0">change_subdomain_id</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, const <a class="el" href="namespacelibMesh.html#a634d676f703fd1cf217d85d6794abcb3">subdomain_id_type</a> old_id, const <a class="el" href="namespacelibMesh.html#a634d676f703fd1cf217d85d6794abcb3">subdomain_id_type</a> new_id)</td></tr>
<tr class="separator:a30caf6b7a7280e592b7c177ff85b97a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Tools for <code><a class="el" href="classlibMesh_1_1Mesh.html" title="Manages a collection of Nodes and Elems. ">Mesh</a></code> modification.</p>
<dl class="section author"><dt>Author</dt><dd>Benjamin S. Kirk </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2004 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a249f04550c345984831d08e013155668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249f04550c345984831d08e013155668">&#9670;&nbsp;</a></span>all_tri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshTools::Modification::all_tri </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the 2D quadrilateral elements of a <a class="el" href="classlibMesh_1_1Mesh.html" title="Manages a collection of Nodes and Elems. ">Mesh</a> into triangular elements.</p>
<dl class="section note"><dt>Note</dt><dd>Only works for 2D elements! 3D elements are ignored. </dd>
<dd>
Probably won't do the right thing for meshes which have been refined previously. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mesh__modification_8C_source.html#l00271">271</a> of file <a class="el" href="mesh__modification_8C_source.html">mesh_modification.C</a>.</p>

<p class="reference">References <a class="el" href="classlibMesh_1_1MeshBase.html#a5ab834283fa6bc335ad623d2b737ec5e">libMesh::MeshBase::add_elem()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a9361e2879e37831f80afb43b762d651f">libMesh::MeshBase::add_point()</a>, <a class="el" href="boundary__info_8C_source.html#l00849">libMesh::BoundaryInfo::add_side()</a>, <a class="el" href="boundary__info_8C_source.html#l00948">libMesh::BoundaryInfo::boundary_ids()</a>, <a class="el" href="classlibMesh_1_1Elem.html#a16afe15346ebf8b6dd467de99aaf6522">libMesh::Elem::build_side_ptr()</a>, <a class="el" href="parallel__object_8h_source.html#l00089">libMesh::ParallelObject::comm()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a5c7824047ed759b5a4891a6936b546cc">libMesh::MeshBase::delete_elem()</a>, <a class="el" href="enum__elem__type_8h_source.html#l00035">libMesh::EDGE2</a>, <a class="el" href="enum__elem__type_8h_source.html#l00036">libMesh::EDGE3</a>, <a class="el" href="enum__elem__type_8h_source.html#l00037">libMesh::EDGE4</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a5173d38b4db709085b1cde698137d042">libMesh::MeshBase::element_ptr_range()</a>, <a class="el" href="variant__filter__iterator_8h_source.html#l00343">end</a>, <a class="el" href="libmesh__common_8h_source.html#l00229">libMesh::err</a>, <a class="el" href="mesh__base_8h_source.html#l00131">libMesh::MeshBase::get_boundary_info()</a>, <a class="el" href="dof__object_8h_source.html#l00655">libMesh::DofObject::id()</a>, <a class="el" href="enum__elem__type_8h_source.html#l00057">libMesh::INFEDGE2</a>, <a class="el" href="enum__elem__type_8h_source.html#l00064">libMesh::INFPRISM12</a>, <a class="el" href="enum__elem__type_8h_source.html#l00063">libMesh::INFPRISM6</a>, <a class="el" href="enum__elem__type_8h_source.html#l00058">libMesh::INFQUAD4</a>, <a class="el" href="enum__elem__type_8h_source.html#l00059">libMesh::INFQUAD6</a>, <a class="el" href="dof__object_8h_source.html#l00347">libMesh::DofObject::invalid_id</a>, <a class="el" href="boundary__info_8h_source.html#l00875">libMesh::BoundaryInfo::invalid_id</a>, <a class="el" href="mesh__base_8h_source.html#l00154">libMesh::MeshBase::is_serial()</a>, <a class="el" href="mesh__communication_8C_source.html#l01763">libMesh::MeshCommunication::make_nodes_parallel_consistent()</a>, <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html#ac82839410a5e87606482504ae269f31f">libMesh::Parallel::Communicator::max()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a807e5541b5e0608c8847daf6f3ffc1cf">libMesh::MeshBase::max_elem_id()</a>, <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>, <a class="el" href="mesh__base_8C_source.html#l00126">libMesh::MeshBase::mesh_dimension()</a>, <a class="el" href="boundary__info_8C_source.html#l01646">libMesh::BoundaryInfo::n_boundary_conds()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a190e556d3be87f5ccd8d4fc98d1779d3">libMesh::MeshBase::n_elem()</a>, <a class="el" href="elem_8h_source.html#l02050">libMesh::Elem::neighbor_ptr()</a>, <a class="el" href="elem_8h_source.html#l01914">libMesh::Elem::node_id()</a>, <a class="el" href="elem_8h_source.html#l01957">libMesh::Elem::node_ptr()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#afe850a1134d7cfb86c16387a7c5ad4f4">libMesh::MeshBase::parallel_max_unique_id()</a>, <a class="el" href="elem_8h_source.html#l02479">libMesh::Elem::parent()</a>, <a class="el" href="elem_8h_source.html#l01892">libMesh::Elem::point()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a00e863731129afaba604816c2db55aed">libMesh::MeshBase::point()</a>, <a class="el" href="mesh__base_8C_source.html#l00152">libMesh::MeshBase::prepare_for_use()</a>, <a class="el" href="enum__elem__type_8h_source.html#l00052">libMesh::PRISM18</a>, <a class="el" href="enum__elem__type_8h_source.html#l00050">libMesh::PRISM6</a>, <a class="el" href="parallel__object_8h_source.html#l00101">libMesh::ParallelObject::processor_id()</a>, <a class="el" href="dof__object_8h_source.html#l00717">libMesh::DofObject::processor_id()</a>, <a class="el" href="enum__elem__type_8h_source.html#l00041">libMesh::QUAD4</a>, <a class="el" href="enum__elem__type_8h_source.html#l00042">libMesh::QUAD8</a>, <a class="el" href="enum__elem__type_8h_source.html#l00043">libMesh::QUAD9</a>, <a class="el" href="remote__elem_8C_source.html#l00057">libMesh::remote_elem</a>, <a class="el" href="boundary__info_8C_source.html#l01321">libMesh::BoundaryInfo::remove()</a>, <a class="el" href="elem_8h_source.html#l02024">libMesh::Elem::set_node()</a>, <a class="el" href="elem_8h_source.html#l02166">libMesh::Elem::side_index_range()</a>, <a class="el" href="elem_8h_source.html#l02034">libMesh::Elem::subdomain_id()</a>, <a class="el" href="enum__elem__type_8h_source.html#l00046">libMesh::TET10</a>, <a class="el" href="enum__elem__type_8h_source.html#l00045">libMesh::TET4</a>, <a class="el" href="enum__elem__type_8h_source.html#l00039">libMesh::TRI3</a>, <a class="el" href="enum__elem__type_8h_source.html#l00040">libMesh::TRI6</a>, <a class="el" href="classlibMesh_1_1Elem.html#ad06f8ac22978144723179eed42d10bae">libMesh::Elem::type()</a>, and <a class="el" href="dof__object_8h_source.html#l00672">libMesh::DofObject::unique_id()</a>.</p>
<div class="fragment"><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;{</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;  <span class="comment">// The number of elements in the original mesh before any additions</span></div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;  <span class="comment">// or deletions.</span></div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> n_orig_elem = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.n_elem();</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> max_orig_id = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.max_elem_id();</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;  <span class="comment">// We store pointers to the newly created elements in a vector</span></div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;  <span class="comment">// until they are ready to be added to the mesh.  This is because</span></div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;  <span class="comment">// adding new elements on the fly can cause reallocation and invalidation</span></div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;  <span class="comment">// of existing mesh element_iterators.</span></div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;  std::vector&lt;Elem *&gt; new_elements;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_subelems = 1;  <span class="comment">// in 1D nothing needs to change</span></div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.mesh_dimension() == 2) <span class="comment">// in 2D quads can split into 2 tris</span></div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    max_subelems = 2;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.mesh_dimension() == 3) <span class="comment">// in 3D hexes can split into 6 tets</span></div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    max_subelems = 6;</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;  new_elements.reserve (max_subelems*n_orig_elem);</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;  <span class="comment">// If the original mesh has *side* boundary data, we carry that over</span></div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;  <span class="comment">// to the new mesh with triangular elements.  We currently only</span></div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;  <span class="comment">// support bringing over side-based BCs to the all-tri mesh, but</span></div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;  <span class="comment">// that could probably be extended to node and edge-based BCs as</span></div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;  <span class="comment">// well.</span></div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">bool</span> mesh_has_boundary_data = (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.get_boundary_info().n_boundary_conds() &gt; 0);</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;  <span class="comment">// Temporary vectors to store the new boundary element pointers, side numbers, and boundary ids</span></div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;  std::vector&lt;Elem *&gt; new_bndry_elements;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;  std::vector&lt;unsigned short int&gt; new_bndry_sides;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;  std::vector&lt;boundary_id_type&gt; new_bndry_ids;</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;  <span class="comment">// We may need to add new points if we run into a 1.5th order</span></div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;  <span class="comment">// element; if we do that on a DistributedMesh in a ghost element then</span></div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;  <span class="comment">// we will need to fix their ids / unique_ids</span></div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;  <span class="keywordtype">bool</span> added_new_ghost_point = <span class="keyword">false</span>;</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;  <span class="comment">// Iterate over the elements, splitting:</span></div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;  <span class="comment">// QUADs into pairs of conforming triangles</span></div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;  <span class="comment">// PYRAMIDs into pairs of conforming tets,</span></div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;  <span class="comment">// PRISMs into triplets of conforming tets, and</span></div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;  <span class="comment">// HEXs into quintets or sextets of conforming tets.</span></div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;  <span class="comment">// We split on the shortest diagonal to give us better</span></div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;  <span class="comment">// triangle quality in 2D, and we split based on node ids</span></div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;  <span class="comment">// to guarantee consistency in 3D.</span></div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;  <span class="comment">// FIXME: This algorithm does not work on refined grids!</span></div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;  {</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;<span class="preprocessor">#ifdef LIBMESH_ENABLE_UNIQUE_ID</span></div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    <a class="code" href="namespacelibMesh.html#a0c8246ed396fb6017ccc59711d9b9f7e">unique_id_type</a> max_unique_id = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.parallel_max_unique_id();</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.element_ptr_range())</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;      {</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967">ElemType</a> etype = elem-&gt;type();</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;        <span class="comment">// all_tri currently only works on coarse meshes</span></div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;        libmesh_assert (!elem-&gt;parent());</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;        <span class="comment">// The new elements we will split the quad into.</span></div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;        <span class="comment">// In 3D we may need as many as 6 tets per hex</span></div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;        Elem * subelem[6];</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i != max_subelems; ++i)</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;          subelem[i] = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;        <span class="keywordflow">switch</span> (etype)</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;          {</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;          <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967af4b68709f9e0a488822d3399de3508b1">QUAD4</a>:</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;            {</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;              subelem[0] = <span class="keyword">new</span> Tri3;</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;              subelem[1] = <span class="keyword">new</span> Tri3;</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;              <span class="comment">// Check for possible edge swap</span></div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;              <span class="keywordflow">if</span> ((elem-&gt;point(0) - elem-&gt;point(2)).norm() &lt;</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;                  (elem-&gt;point(1) - elem-&gt;point(3)).norm())</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;                {</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;                  subelem[0]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;                  subelem[0]-&gt;set_node(1) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;                  subelem[0]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;                  subelem[1]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;                  subelem[1]-&gt;set_node(1) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;                  subelem[1]-&gt;set_node(2) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;                }</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;              <span class="keywordflow">else</span></div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;                {</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;                  subelem[0]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;                  subelem[0]-&gt;set_node(1) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;                  subelem[0]-&gt;set_node(2) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;                  subelem[1]-&gt;set_node(0) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;                  subelem[1]-&gt;set_node(1) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;                  subelem[1]-&gt;set_node(2) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;                }</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;              <span class="keywordflow">break</span>;</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;            }</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;          <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967a850fa5218d8f69ab09f5bccaf40b615a">QUAD8</a>:</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;            {</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;              <span class="keywordflow">if</span> (elem-&gt;processor_id() != <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.processor_id())</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;                added_new_ghost_point = <span class="keyword">true</span>;</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;              subelem[0] = <span class="keyword">new</span> Tri6;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;              subelem[1] = <span class="keyword">new</span> Tri6;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;              <span class="comment">// Add a new node at the center (vertex average) of the element.</span></div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;              Node * new_node = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.add_point((<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.point(elem-&gt;node_id(0)) +</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;                                                <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.point(elem-&gt;node_id(1)) +</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;                                                <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.point(elem-&gt;node_id(2)) +</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;                                                <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.point(elem-&gt;node_id(3)))/4,</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;                                               DofObject::invalid_id,</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;                                               elem-&gt;processor_id());</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;              <span class="comment">// Check for possible edge swap</span></div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;              <span class="keywordflow">if</span> ((elem-&gt;point(0) - elem-&gt;point(2)).norm() &lt;</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;                  (elem-&gt;point(1) - elem-&gt;point(3)).norm())</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;                {</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;                  subelem[0]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;                  subelem[0]-&gt;set_node(1) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;                  subelem[0]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;                  subelem[0]-&gt;set_node(3) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;                  subelem[0]-&gt;set_node(4) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;                  subelem[0]-&gt;set_node(5) = new_node;</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;                  subelem[1]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;                  subelem[1]-&gt;set_node(1) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;                  subelem[1]-&gt;set_node(2) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;                  subelem[1]-&gt;set_node(3) = new_node;</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;                  subelem[1]-&gt;set_node(4) = elem-&gt;node_ptr(6);</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;                  subelem[1]-&gt;set_node(5) = elem-&gt;node_ptr(7);</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;                }</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;              <span class="keywordflow">else</span></div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;                {</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;                  subelem[0]-&gt;set_node(0) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;                  subelem[0]-&gt;set_node(1) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;                  subelem[0]-&gt;set_node(2) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;                  subelem[0]-&gt;set_node(3) = elem-&gt;node_ptr(7);</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;                  subelem[0]-&gt;set_node(4) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;                  subelem[0]-&gt;set_node(5) = new_node;</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;                  subelem[1]-&gt;set_node(0) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;                  subelem[1]-&gt;set_node(1) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;                  subelem[1]-&gt;set_node(2) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;                  subelem[1]-&gt;set_node(3) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;                  subelem[1]-&gt;set_node(4) = elem-&gt;node_ptr(6);</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;                  subelem[1]-&gt;set_node(5) = new_node;</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;                }</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;              <span class="keywordflow">break</span>;</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;            }</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;          <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967a2d7bef790b667ca2769e52ce6de8b9fd">QUAD9</a>:</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;            {</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;              subelem[0] = <span class="keyword">new</span> Tri6;</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;              subelem[1] = <span class="keyword">new</span> Tri6;</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;              <span class="comment">// Check for possible edge swap</span></div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;              <span class="keywordflow">if</span> ((elem-&gt;point(0) - elem-&gt;point(2)).norm() &lt;</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;                  (elem-&gt;point(1) - elem-&gt;point(3)).norm())</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;                {</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;                  subelem[0]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;                  subelem[0]-&gt;set_node(1) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;                  subelem[0]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;                  subelem[0]-&gt;set_node(3) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;                  subelem[0]-&gt;set_node(4) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;                  subelem[0]-&gt;set_node(5) = elem-&gt;node_ptr(8);</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;                  subelem[1]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;                  subelem[1]-&gt;set_node(1) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;                  subelem[1]-&gt;set_node(2) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;                  subelem[1]-&gt;set_node(3) = elem-&gt;node_ptr(8);</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;                  subelem[1]-&gt;set_node(4) = elem-&gt;node_ptr(6);</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;                  subelem[1]-&gt;set_node(5) = elem-&gt;node_ptr(7);</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;                }</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;              <span class="keywordflow">else</span></div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;                {</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;                  subelem[0]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;                  subelem[0]-&gt;set_node(1) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;                  subelem[0]-&gt;set_node(2) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;                  subelem[0]-&gt;set_node(3) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;                  subelem[0]-&gt;set_node(4) = elem-&gt;node_ptr(8);</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;                  subelem[0]-&gt;set_node(5) = elem-&gt;node_ptr(7);</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;                  subelem[1]-&gt;set_node(0) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;                  subelem[1]-&gt;set_node(1) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;                  subelem[1]-&gt;set_node(2) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;                  subelem[1]-&gt;set_node(3) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;                  subelem[1]-&gt;set_node(4) = elem-&gt;node_ptr(6);</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;                  subelem[1]-&gt;set_node(5) = elem-&gt;node_ptr(8);</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;                }</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;              <span class="keywordflow">break</span>;</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;            }</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;          <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967aa483bcc949d5b563a091996fb8b9ec3e">PRISM6</a>:</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;            {</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;              <span class="comment">// Prisms all split into three tetrahedra</span></div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;              subelem[0] = <span class="keyword">new</span> Tet4;</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;              subelem[1] = <span class="keyword">new</span> Tet4;</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;              subelem[2] = <span class="keyword">new</span> Tet4;</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;              <span class="comment">// Triangular faces are not split.</span></div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;              <span class="comment">// On quad faces, we choose the node with the highest</span></div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;              <span class="comment">// global id, and we split on the diagonal which</span></div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;              <span class="comment">// includes that node.  This ensures that (even in</span></div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;              <span class="comment">// parallel, even on distributed meshes) the same</span></div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;              <span class="comment">// diagonal split will be chosen for elements on either</span></div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;              <span class="comment">// side of the same quad face.  It also ensures that we</span></div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;              <span class="comment">// always have a mix of &quot;clockwise&quot; and</span></div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;              <span class="comment">// &quot;counterclockwise&quot; split faces (two of one and one</span></div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;              <span class="comment">// of the other on each prism; this is useful since the</span></div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;              <span class="comment">// alternative all-clockwise or all-counterclockwise</span></div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;              <span class="comment">// face splittings can&#39;t be turned into tets without</span></div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;              <span class="comment">// adding more nodes</span></div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;              <span class="comment">// Split on 0-4 diagonal</span></div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;              <span class="keywordflow">if</span> (split_first_diagonal(elem, 0,4, 1,3))</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;                {</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;                  <span class="comment">// Split on 0-5 diagonal</span></div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;                  <span class="keywordflow">if</span> (split_first_diagonal(elem, 0,5, 2,3))</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;                    {</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;                      <span class="comment">// Split on 1-5 diagonal</span></div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;                      <span class="keywordflow">if</span> (split_first_diagonal(elem, 1,5, 2,4))</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;                        {</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;                          subelem[0]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;                          subelem[0]-&gt;set_node(1) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;                          subelem[0]-&gt;set_node(2) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;                          subelem[0]-&gt;set_node(3) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;                          subelem[1]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;                          subelem[1]-&gt;set_node(1) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;                          subelem[1]-&gt;set_node(2) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;                          subelem[1]-&gt;set_node(3) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;                          subelem[2]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;                          subelem[2]-&gt;set_node(1) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;                          subelem[2]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;                          subelem[2]-&gt;set_node(3) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;                        }</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;                      <span class="keywordflow">else</span> <span class="comment">// Split on 2-4 diagonal</span></div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;                        {</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;                          libmesh_assert (split_first_diagonal(elem, 2,4, 1,5));</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;                          subelem[0]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;                          subelem[0]-&gt;set_node(1) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;                          subelem[0]-&gt;set_node(2) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;                          subelem[0]-&gt;set_node(3) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;                          subelem[1]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;                          subelem[1]-&gt;set_node(1) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;                          subelem[1]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;                          subelem[1]-&gt;set_node(3) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;                          subelem[2]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;                          subelem[2]-&gt;set_node(1) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;                          subelem[2]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;                          subelem[2]-&gt;set_node(3) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;                        }</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;                    }</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;                  <span class="keywordflow">else</span> <span class="comment">// Split on 2-3 diagonal</span></div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;                    {</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;                      libmesh_assert (split_first_diagonal(elem, 2,3, 0,5));</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;                      <span class="comment">// 0-4 and 2-3 split implies 2-4 split</span></div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;                      libmesh_assert (split_first_diagonal(elem, 2,4, 1,5));</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;                      subelem[0]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;                      subelem[0]-&gt;set_node(1) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;                      subelem[0]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;                      subelem[0]-&gt;set_node(3) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;                      subelem[1]-&gt;set_node(0) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;                      subelem[1]-&gt;set_node(1) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;                      subelem[1]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;                      subelem[1]-&gt;set_node(3) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;                      subelem[2]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;                      subelem[2]-&gt;set_node(1) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;                      subelem[2]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;                      subelem[2]-&gt;set_node(3) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;                    }</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;                }</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;              <span class="keywordflow">else</span> <span class="comment">// Split on 1-3 diagonal</span></div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;                {</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;                  libmesh_assert (split_first_diagonal(elem, 1,3, 0,4));</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;                  <span class="comment">// Split on 0-5 diagonal</span></div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;                  <span class="keywordflow">if</span> (split_first_diagonal(elem, 0,5, 2,3))</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;                    {</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;                      <span class="comment">// 1-3 and 0-5 split implies 1-5 split</span></div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;                      libmesh_assert (split_first_diagonal(elem, 1,5, 2,4));</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;                      subelem[0]-&gt;set_node(0) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;                      subelem[0]-&gt;set_node(1) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;                      subelem[0]-&gt;set_node(2) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;                      subelem[0]-&gt;set_node(3) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;                      subelem[1]-&gt;set_node(0) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;                      subelem[1]-&gt;set_node(1) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;                      subelem[1]-&gt;set_node(2) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;                      subelem[1]-&gt;set_node(3) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;                      subelem[2]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;                      subelem[2]-&gt;set_node(1) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;                      subelem[2]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;                      subelem[2]-&gt;set_node(3) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;                    }</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;                  <span class="keywordflow">else</span> <span class="comment">// Split on 2-3 diagonal</span></div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;                    {</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;                      libmesh_assert (split_first_diagonal(elem, 2,3, 0,5));</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;                      <span class="comment">// Split on 1-5 diagonal</span></div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;                      <span class="keywordflow">if</span> (split_first_diagonal(elem, 1,5, 2,4))</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;                        {</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;                          subelem[0]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;                          subelem[0]-&gt;set_node(1) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;                          subelem[0]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;                          subelem[0]-&gt;set_node(3) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;                          subelem[1]-&gt;set_node(0) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;                          subelem[1]-&gt;set_node(1) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;                          subelem[1]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;                          subelem[1]-&gt;set_node(3) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;                          subelem[2]-&gt;set_node(0) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;                          subelem[2]-&gt;set_node(1) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;                          subelem[2]-&gt;set_node(2) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;                          subelem[2]-&gt;set_node(3) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;                        }</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;                      <span class="keywordflow">else</span> <span class="comment">// Split on 2-4 diagonal</span></div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;                        {</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;                          libmesh_assert (split_first_diagonal(elem, 2,4, 1,5));</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;                          subelem[0]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;                          subelem[0]-&gt;set_node(1) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;                          subelem[0]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;                          subelem[0]-&gt;set_node(3) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;                          subelem[1]-&gt;set_node(0) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;                          subelem[1]-&gt;set_node(1) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;                          subelem[1]-&gt;set_node(2) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;                          subelem[1]-&gt;set_node(3) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;                          subelem[2]-&gt;set_node(0) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;                          subelem[2]-&gt;set_node(1) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;                          subelem[2]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;                          subelem[2]-&gt;set_node(3) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;                        }</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;                    }</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;                }</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;              <span class="keywordflow">break</span>;</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;            }</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;          <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967a7994064d3565a0a07f0c02fc99ea6068">PRISM18</a>:</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;            {</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;              subelem[0] = <span class="keyword">new</span> Tet10;</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;              subelem[1] = <span class="keyword">new</span> Tet10;</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;              subelem[2] = <span class="keyword">new</span> Tet10;</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;              <span class="comment">// Split on 0-4 diagonal</span></div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;              <span class="keywordflow">if</span> (split_first_diagonal(elem, 0,4, 1,3))</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;                {</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;                  <span class="comment">// Split on 0-5 diagonal</span></div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;                  <span class="keywordflow">if</span> (split_first_diagonal(elem, 0,5, 2,3))</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;                    {</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;                      <span class="comment">// Split on 1-5 diagonal</span></div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;                      <span class="keywordflow">if</span> (split_first_diagonal(elem, 1,5, 2,4))</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;                        {</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;                          subelem[0]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;                          subelem[0]-&gt;set_node(1) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;                          subelem[0]-&gt;set_node(2) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;                          subelem[0]-&gt;set_node(3) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;                          subelem[0]-&gt;set_node(4) = elem-&gt;node_ptr(15);</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;                          subelem[0]-&gt;set_node(5) = elem-&gt;node_ptr(13);</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;                          subelem[0]-&gt;set_node(6) = elem-&gt;node_ptr(17);</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;                          subelem[0]-&gt;set_node(7) = elem-&gt;node_ptr(9);</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;                          subelem[0]-&gt;set_node(8) = elem-&gt;node_ptr(12);</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;                          subelem[0]-&gt;set_node(9) = elem-&gt;node_ptr(14);</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;                          subelem[1]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;                          subelem[1]-&gt;set_node(1) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;                          subelem[1]-&gt;set_node(2) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;                          subelem[1]-&gt;set_node(3) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;                          subelem[1]-&gt;set_node(4) = elem-&gt;node_ptr(15);</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;                          subelem[1]-&gt;set_node(5) = elem-&gt;node_ptr(10);</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;                          subelem[1]-&gt;set_node(6) = elem-&gt;node_ptr(6);</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;                          subelem[1]-&gt;set_node(7) = elem-&gt;node_ptr(17);</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;                          subelem[1]-&gt;set_node(8) = elem-&gt;node_ptr(13);</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;                          subelem[1]-&gt;set_node(9) = elem-&gt;node_ptr(16);</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;                          subelem[2]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;                          subelem[2]-&gt;set_node(1) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;                          subelem[2]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;                          subelem[2]-&gt;set_node(3) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;                          subelem[2]-&gt;set_node(4) = elem-&gt;node_ptr(6);</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;                          subelem[2]-&gt;set_node(5) = elem-&gt;node_ptr(7);</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;                          subelem[2]-&gt;set_node(6) = elem-&gt;node_ptr(8);</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;                          subelem[2]-&gt;set_node(7) = elem-&gt;node_ptr(17);</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;                          subelem[2]-&gt;set_node(8) = elem-&gt;node_ptr(16);</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;                          subelem[2]-&gt;set_node(9) = elem-&gt;node_ptr(11);</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;                        }</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;                      <span class="keywordflow">else</span> <span class="comment">// Split on 2-4 diagonal</span></div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;                        {</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;                          libmesh_assert (split_first_diagonal(elem, 2,4, 1,5));</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;                          subelem[0]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;                          subelem[0]-&gt;set_node(1) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;                          subelem[0]-&gt;set_node(2) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;                          subelem[0]-&gt;set_node(3) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;                          subelem[0]-&gt;set_node(4) = elem-&gt;node_ptr(15);</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;                          subelem[0]-&gt;set_node(5) = elem-&gt;node_ptr(13);</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;                          subelem[0]-&gt;set_node(6) = elem-&gt;node_ptr(17);</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;                          subelem[0]-&gt;set_node(7) = elem-&gt;node_ptr(9);</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;                          subelem[0]-&gt;set_node(8) = elem-&gt;node_ptr(12);</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;                          subelem[0]-&gt;set_node(9) = elem-&gt;node_ptr(14);</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;                          subelem[1]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;                          subelem[1]-&gt;set_node(1) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;                          subelem[1]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;                          subelem[1]-&gt;set_node(3) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;                          subelem[1]-&gt;set_node(4) = elem-&gt;node_ptr(15);</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;                          subelem[1]-&gt;set_node(5) = elem-&gt;node_ptr(16);</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;                          subelem[1]-&gt;set_node(6) = elem-&gt;node_ptr(8);</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;                          subelem[1]-&gt;set_node(7) = elem-&gt;node_ptr(17);</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;                          subelem[1]-&gt;set_node(8) = elem-&gt;node_ptr(13);</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;                          subelem[1]-&gt;set_node(9) = elem-&gt;node_ptr(11);</div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;                          subelem[2]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;                          subelem[2]-&gt;set_node(1) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;                          subelem[2]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;                          subelem[2]-&gt;set_node(3) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;                          subelem[2]-&gt;set_node(4) = elem-&gt;node_ptr(6);</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;                          subelem[2]-&gt;set_node(5) = elem-&gt;node_ptr(7);</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;                          subelem[2]-&gt;set_node(6) = elem-&gt;node_ptr(8);</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;                          subelem[2]-&gt;set_node(7) = elem-&gt;node_ptr(15);</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;                          subelem[2]-&gt;set_node(8) = elem-&gt;node_ptr(10);</div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;                          subelem[2]-&gt;set_node(9) = elem-&gt;node_ptr(16);</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;                        }</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;                    }</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;                  <span class="keywordflow">else</span> <span class="comment">// Split on 2-3 diagonal</span></div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;                    {</div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;                      libmesh_assert (split_first_diagonal(elem, 2,3, 0,5));</div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;                      <span class="comment">// 0-4 and 2-3 split implies 2-4 split</span></div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;                      libmesh_assert (split_first_diagonal(elem, 2,4, 1,5));</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;                      subelem[0]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;                      subelem[0]-&gt;set_node(1) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;                      subelem[0]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;                      subelem[0]-&gt;set_node(3) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;                      subelem[0]-&gt;set_node(4) = elem-&gt;node_ptr(15);</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;                      subelem[0]-&gt;set_node(5) = elem-&gt;node_ptr(16);</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;                      subelem[0]-&gt;set_node(6) = elem-&gt;node_ptr(8);</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;                      subelem[0]-&gt;set_node(7) = elem-&gt;node_ptr(9);</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;                      subelem[0]-&gt;set_node(8) = elem-&gt;node_ptr(12);</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;                      subelem[0]-&gt;set_node(9) = elem-&gt;node_ptr(17);</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;                      subelem[1]-&gt;set_node(0) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;                      subelem[1]-&gt;set_node(1) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;                      subelem[1]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;                      subelem[1]-&gt;set_node(3) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;                      subelem[1]-&gt;set_node(4) = elem-&gt;node_ptr(12);</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;                      subelem[1]-&gt;set_node(5) = elem-&gt;node_ptr(16);</div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;                      subelem[1]-&gt;set_node(6) = elem-&gt;node_ptr(17);</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;                      subelem[1]-&gt;set_node(7) = elem-&gt;node_ptr(14);</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;                      subelem[1]-&gt;set_node(8) = elem-&gt;node_ptr(13);</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;                      subelem[1]-&gt;set_node(9) = elem-&gt;node_ptr(11);</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;                      subelem[2]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;                      subelem[2]-&gt;set_node(1) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;                      subelem[2]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;                      subelem[2]-&gt;set_node(3) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;                      subelem[2]-&gt;set_node(4) = elem-&gt;node_ptr(6);</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;                      subelem[2]-&gt;set_node(5) = elem-&gt;node_ptr(7);</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;                      subelem[2]-&gt;set_node(6) = elem-&gt;node_ptr(8);</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;                      subelem[2]-&gt;set_node(7) = elem-&gt;node_ptr(15);</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;                      subelem[2]-&gt;set_node(8) = elem-&gt;node_ptr(10);</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;                      subelem[2]-&gt;set_node(9) = elem-&gt;node_ptr(16);</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;                    }</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;                }</div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;              <span class="keywordflow">else</span> <span class="comment">// Split on 1-3 diagonal</span></div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;                {</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;                  libmesh_assert (split_first_diagonal(elem, 1,3, 0,4));</div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;                  <span class="comment">// Split on 0-5 diagonal</span></div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;                  <span class="keywordflow">if</span> (split_first_diagonal(elem, 0,5, 2,3))</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;                    {</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;                      <span class="comment">// 1-3 and 0-5 split implies 1-5 split</span></div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;                      libmesh_assert (split_first_diagonal(elem, 1,5, 2,4));</div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;</div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;                      subelem[0]-&gt;set_node(0) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;                      subelem[0]-&gt;set_node(1) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;                      subelem[0]-&gt;set_node(2) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;                      subelem[0]-&gt;set_node(3) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;                      subelem[0]-&gt;set_node(4) = elem-&gt;node_ptr(15);</div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;                      subelem[0]-&gt;set_node(5) = elem-&gt;node_ptr(12);</div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;                      subelem[0]-&gt;set_node(6) = elem-&gt;node_ptr(10);</div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;                      subelem[0]-&gt;set_node(7) = elem-&gt;node_ptr(16);</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;                      subelem[0]-&gt;set_node(8) = elem-&gt;node_ptr(14);</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;                      subelem[0]-&gt;set_node(9) = elem-&gt;node_ptr(13);</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;                      subelem[1]-&gt;set_node(0) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;                      subelem[1]-&gt;set_node(1) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;                      subelem[1]-&gt;set_node(2) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;                      subelem[1]-&gt;set_node(3) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;</div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;                      subelem[1]-&gt;set_node(4) = elem-&gt;node_ptr(6);</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;                      subelem[1]-&gt;set_node(5) = elem-&gt;node_ptr(9);</div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;                      subelem[1]-&gt;set_node(6) = elem-&gt;node_ptr(15);</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;                      subelem[1]-&gt;set_node(7) = elem-&gt;node_ptr(16);</div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;                      subelem[1]-&gt;set_node(8) = elem-&gt;node_ptr(17);</div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;                      subelem[1]-&gt;set_node(9) = elem-&gt;node_ptr(14);</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;                      subelem[2]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;                      subelem[2]-&gt;set_node(1) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;                      subelem[2]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;                      subelem[2]-&gt;set_node(3) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;                      subelem[2]-&gt;set_node(4) = elem-&gt;node_ptr(6);</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;                      subelem[2]-&gt;set_node(5) = elem-&gt;node_ptr(7);</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;                      subelem[2]-&gt;set_node(6) = elem-&gt;node_ptr(8);</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;                      subelem[2]-&gt;set_node(7) = elem-&gt;node_ptr(17);</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;                      subelem[2]-&gt;set_node(8) = elem-&gt;node_ptr(16);</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;                      subelem[2]-&gt;set_node(9) = elem-&gt;node_ptr(11);</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;                    }</div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;                  <span class="keywordflow">else</span> <span class="comment">// Split on 2-3 diagonal</span></div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;                    {</div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;                      libmesh_assert (split_first_diagonal(elem, 2,3, 0,5));</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;</div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;                      <span class="comment">// Split on 1-5 diagonal</span></div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;                      <span class="keywordflow">if</span> (split_first_diagonal(elem, 1,5, 2,4))</div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;                        {</div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;                          subelem[0]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;                          subelem[0]-&gt;set_node(1) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;                          subelem[0]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;                          subelem[0]-&gt;set_node(3) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;</div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;                          subelem[0]-&gt;set_node(4) = elem-&gt;node_ptr(6);</div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;                          subelem[0]-&gt;set_node(5) = elem-&gt;node_ptr(7);</div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;                          subelem[0]-&gt;set_node(6) = elem-&gt;node_ptr(8);</div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;                          subelem[0]-&gt;set_node(7) = elem-&gt;node_ptr(9);</div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;                          subelem[0]-&gt;set_node(8) = elem-&gt;node_ptr(15);</div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;                          subelem[0]-&gt;set_node(9) = elem-&gt;node_ptr(17);</div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;</div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;                          subelem[1]-&gt;set_node(0) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;                          subelem[1]-&gt;set_node(1) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;                          subelem[1]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;                          subelem[1]-&gt;set_node(3) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;</div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;                          subelem[1]-&gt;set_node(4) = elem-&gt;node_ptr(15);</div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;                          subelem[1]-&gt;set_node(5) = elem-&gt;node_ptr(7);</div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;                          subelem[1]-&gt;set_node(6) = elem-&gt;node_ptr(17);</div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;                          subelem[1]-&gt;set_node(7) = elem-&gt;node_ptr(14);</div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;                          subelem[1]-&gt;set_node(8) = elem-&gt;node_ptr(16);</div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;                          subelem[1]-&gt;set_node(9) = elem-&gt;node_ptr(11);</div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;</div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;                          subelem[2]-&gt;set_node(0) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;                          subelem[2]-&gt;set_node(1) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;                          subelem[2]-&gt;set_node(2) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;                          subelem[2]-&gt;set_node(3) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;</div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;                          subelem[2]-&gt;set_node(4) = elem-&gt;node_ptr(15);</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;                          subelem[2]-&gt;set_node(5) = elem-&gt;node_ptr(12);</div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;                          subelem[2]-&gt;set_node(6) = elem-&gt;node_ptr(10);</div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;                          subelem[2]-&gt;set_node(7) = elem-&gt;node_ptr(16);</div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;                          subelem[2]-&gt;set_node(8) = elem-&gt;node_ptr(14);</div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;                          subelem[2]-&gt;set_node(9) = elem-&gt;node_ptr(13);</div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;                        }</div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;                      <span class="keywordflow">else</span> <span class="comment">// Split on 2-4 diagonal</span></div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;                        {</div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;                          libmesh_assert (split_first_diagonal(elem, 2,4, 1,5));</div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;</div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;                          subelem[0]-&gt;set_node(0) = elem-&gt;node_ptr(0);</div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;                          subelem[0]-&gt;set_node(1) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;                          subelem[0]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;                          subelem[0]-&gt;set_node(3) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;</div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;                          subelem[0]-&gt;set_node(4) = elem-&gt;node_ptr(6);</div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;                          subelem[0]-&gt;set_node(5) = elem-&gt;node_ptr(7);</div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;                          subelem[0]-&gt;set_node(6) = elem-&gt;node_ptr(8);</div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;                          subelem[0]-&gt;set_node(7) = elem-&gt;node_ptr(9);</div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;                          subelem[0]-&gt;set_node(8) = elem-&gt;node_ptr(15);</div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;                          subelem[0]-&gt;set_node(9) = elem-&gt;node_ptr(17);</div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;</div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;                          subelem[1]-&gt;set_node(0) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;                          subelem[1]-&gt;set_node(1) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;                          subelem[1]-&gt;set_node(2) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;                          subelem[1]-&gt;set_node(3) = elem-&gt;node_ptr(5);</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;                          subelem[1]-&gt;set_node(4) = elem-&gt;node_ptr(17);</div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;                          subelem[1]-&gt;set_node(5) = elem-&gt;node_ptr(12);</div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;                          subelem[1]-&gt;set_node(6) = elem-&gt;node_ptr(16);</div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;                          subelem[1]-&gt;set_node(7) = elem-&gt;node_ptr(11);</div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;                          subelem[1]-&gt;set_node(8) = elem-&gt;node_ptr(14);</div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;                          subelem[1]-&gt;set_node(9) = elem-&gt;node_ptr(13);</div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;</div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;                          subelem[2]-&gt;set_node(0) = elem-&gt;node_ptr(3);</div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;                          subelem[2]-&gt;set_node(1) = elem-&gt;node_ptr(1);</div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;                          subelem[2]-&gt;set_node(2) = elem-&gt;node_ptr(2);</div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;                          subelem[2]-&gt;set_node(3) = elem-&gt;node_ptr(4);</div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;</div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;                          subelem[2]-&gt;set_node(4) = elem-&gt;node_ptr(15);</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;                          subelem[2]-&gt;set_node(5) = elem-&gt;node_ptr(7);</div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;                          subelem[2]-&gt;set_node(6) = elem-&gt;node_ptr(17);</div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;                          subelem[2]-&gt;set_node(7) = elem-&gt;node_ptr(12);</div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;                          subelem[2]-&gt;set_node(8) = elem-&gt;node_ptr(10);</div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;                          subelem[2]-&gt;set_node(9) = elem-&gt;node_ptr(16);</div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;                        }</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;                    }</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;                }</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;              <span class="keywordflow">break</span>;</div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;            }</div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;            <span class="comment">// No need to split elements that are already simplicial:</span></div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;          <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967aa656f2b4aa8cff7ff974765c83a76820">EDGE2</a>:</div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;          <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967a3251dc5224670944ad87d1b9ab397c59">EDGE3</a>:</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;          <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967a981ce1f0fa792d7701b14e102b00d569">EDGE4</a>:</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;          <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967acccb9e40eddc1b28768f2128fe1a8f08">TRI3</a>:</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;          <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967aad2d0656d7cf0f061899c655560c1e55">TRI6</a>:</div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;          <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967aa05775ffcc750504160cfe0113308cb9">TET4</a>:</div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;          <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967ad2d41a1a3e6858d350ab42e16fccf43b">TET10</a>:</div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;          <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967aa33084719a3fb5ecc72a02917efb81d1">INFEDGE2</a>:</div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;            <span class="comment">// No way to split infinite quad/prism elements, so</span></div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;            <span class="comment">// hopefully no need to</span></div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;          <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967a7d5e155bd4ed469d374f3893fdc80084">INFQUAD4</a>:</div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;          <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967a22110502dcd368586afad8a0a40f4f07">INFQUAD6</a>:</div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;          <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967ac6c81ee0d1fa09307be4b13a3982252b">INFPRISM6</a>:</div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;          <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967abcb630ebd46df2f7f02ed36d71bb46ac">INFPRISM12</a>:</div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;            <span class="comment">// If we&#39;re left with an unimplemented hex we&#39;re probably</span></div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;            <span class="comment">// out of luck.  TODO: implement hexes</span></div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;          <span class="keywordflow">default</span>:</div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;            {</div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;              <a class="code" href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a> &lt;&lt; <span class="stringliteral">&quot;Error, encountered unimplemented element &quot;</span></div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;                           &lt;&lt; Utility::enum_to_string&lt;ElemType&gt;(etype)</div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;                           &lt;&lt; <span class="stringliteral">&quot; in MeshTools::Modification::all_tri()...&quot;</span></div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;                           &lt;&lt; std::endl;</div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;              libmesh_not_implemented();</div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;            }</div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;          } <span class="comment">// end switch (etype)</span></div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;</div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;</div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;</div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;        <span class="comment">// Be sure the correct IDs are also set for all subelems.</span></div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i != max_subelems; ++i)</div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;          <span class="keywordflow">if</span> (subelem[i]) {</div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;            subelem[i]-&gt;processor_id() = elem-&gt;processor_id();</div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;            subelem[i]-&gt;subdomain_id() = elem-&gt;subdomain_id();</div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;          }</div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;</div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;        <span class="comment">// On a mesh with boundary data, we need to move that data to</span></div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;        <span class="comment">// the new elements.</span></div><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;</div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;        <span class="comment">// On a mesh which is distributed, we need to move</span></div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;        <span class="comment">// remote_elem links to the new elements.</span></div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;        <span class="keywordtype">bool</span> mesh_is_serial = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.is_serial();</div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;</div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;        <span class="keywordflow">if</span> (mesh_has_boundary_data || mesh_is_serial)</div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;          {</div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;            <span class="comment">// Container to key boundary IDs handed back by the BoundaryInfo object.</span></div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;            std::vector&lt;boundary_id_type&gt; bc_ids;</div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;</div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> sn : elem-&gt;side_index_range())</div><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;              {</div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;                <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.get_boundary_info().boundary_ids(elem, sn, bc_ids);</div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; b_id : bc_ids)</div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;                  {</div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;                    <span class="keywordflow">if</span> (mesh_is_serial &amp;&amp; b_id == BoundaryInfo::invalid_id)</div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;                      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;</div><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;                    <span class="comment">// Make a sorted list of node ids for elem-&gt;side(sn)</span></div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;                    std::unique_ptr&lt;Elem&gt; elem_side = elem-&gt;build_side_ptr(sn);</div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;                    std::vector&lt;dof_id_type&gt; elem_side_nodes(elem_side-&gt;n_nodes());</div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> esn=0,</div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;                         n_esn = cast_int&lt;unsigned int&gt;(elem_side_nodes.size());</div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;                         esn != n_esn; ++esn)</div><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;                      elem_side_nodes[esn] = elem_side-&gt;node_id(esn);</div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;                    std::sort(elem_side_nodes.begin(), elem_side_nodes.end());</div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;</div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i != max_subelems; ++i)</div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;                      <span class="keywordflow">if</span> (subelem[i])</div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;                        {</div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;                          <span class="keywordflow">for</span> (<span class="keyword">auto</span> subside : subelem[i]-&gt;side_index_range())</div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;                            {</div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;                              std::unique_ptr&lt;Elem&gt; subside_elem = subelem[i]-&gt;build_side_ptr(subside);</div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;</div><div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;                              <span class="comment">// Make a list of *vertex* node ids for this subside, see if they are all present</span></div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;                              <span class="comment">// in elem-&gt;side(sn).  Note 1: we can&#39;t just compare elem-&gt;key(sn) to</span></div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;                              <span class="comment">// subelem[i]-&gt;key(subside) in the Prism cases, since the new side is</span></div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;                              <span class="comment">// a different type.  Note 2: we only use vertex nodes since, in the future,</span></div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;                              <span class="comment">// a Hex20 or Prism15&#39;s QUAD8 face may be split into two Tri6 faces, and the</span></div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;                              <span class="comment">// original face will not contain the mid-edge node.</span></div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;                              std::vector&lt;dof_id_type&gt; subside_nodes(subside_elem-&gt;n_vertices());</div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;                              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ssn=0,</div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;                                   n_ssn = cast_int&lt;unsigned int&gt;(subside_nodes.size());</div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;                                   ssn != n_ssn; ++ssn)</div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;                                subside_nodes[ssn] = subside_elem-&gt;node_id(ssn);</div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;                              std::sort(subside_nodes.begin(), subside_nodes.end());</div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;</div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;                              <span class="comment">// std::includes returns true if every element of the second sorted range is</span></div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;                              <span class="comment">// contained in the first sorted range.</span></div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;                              <span class="keywordflow">if</span> (std::includes(elem_side_nodes.begin(), elem_side_nodes.end(),</div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;                                                subside_nodes.begin(), subside_nodes.end()))</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;                                {</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;                                  <span class="keywordflow">if</span> (b_id != BoundaryInfo::invalid_id)</div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;                                    {</div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;                                      new_bndry_ids.push_back(b_id);</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;                                      new_bndry_elements.push_back(subelem[i]);</div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;                                      new_bndry_sides.push_back(subside);</div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;                                    }</div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;</div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;                                  <span class="comment">// If the original element had a RemoteElem neighbor on side &#39;sn&#39;,</span></div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;                                  <span class="comment">// then the subelem has one on side &#39;subside&#39;.</span></div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;                                  <span class="keywordflow">if</span> (elem-&gt;neighbor_ptr(sn) == <a class="code" href="namespacelibMesh.html#a903992f631b52b5ba05ad96a51e7b383">remote_elem</a>)</div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;                                    subelem[i]-&gt;set_neighbor(subside, const_cast&lt;RemoteElem*&gt;(<a class="code" href="namespacelibMesh.html#a903992f631b52b5ba05ad96a51e7b383">remote_elem</a>));</div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;                                }</div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;                            }</div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;                        }</div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;                  } <span class="comment">// end for loop over boundary IDs</span></div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;              } <span class="comment">// end for loop over sides</span></div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;</div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;            <span class="comment">// Remove the original element from the BoundaryInfo structure.</span></div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;            <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.get_boundary_info().remove(elem);</div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;</div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;          } <span class="comment">// end if (mesh_has_boundary_data)</span></div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;</div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;        <span class="comment">// Determine new IDs for the split elements which will be</span></div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;        <span class="comment">// the same on all processors, therefore keeping the Mesh</span></div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;        <span class="comment">// in sync.  Note: we offset the new IDs by max_orig_id to</span></div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;        <span class="comment">// avoid overwriting any of the original IDs.</span></div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i != max_subelems; ++i)</div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;          <span class="keywordflow">if</span> (subelem[i])</div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;            {</div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;              <span class="comment">// Determine new IDs for the split elements which will be</span></div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;              <span class="comment">// the same on all processors, therefore keeping the Mesh</span></div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;              <span class="comment">// in sync.  Note: we offset the new IDs by the max of the</span></div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;              <span class="comment">// pre-existing ids to avoid conflicting with originals.</span></div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;              subelem[i]-&gt;set_id( max_orig_id + 6*elem-&gt;id() + i );</div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;</div><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;<span class="preprocessor">#ifdef LIBMESH_ENABLE_UNIQUE_ID</span></div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;              subelem[i]-&gt;set_unique_id() = max_unique_id + 2*elem-&gt;unique_id() + i;</div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;</div><div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;              <span class="comment">// Prepare to add the newly-created simplices</span></div><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;              new_elements.push_back(subelem[i]);</div><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;            }</div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;</div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;        <span class="comment">// Delete the original element</span></div><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;        <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.delete_elem(elem);</div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;      } <span class="comment">// End for loop over elements</span></div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;  } <span class="comment">// end scope</span></div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;</div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;</div><div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;  <span class="comment">// Now, iterate over the new elements vector, and add them each to</span></div><div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;  <span class="comment">// the Mesh.</span></div><div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;  {</div><div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;    std::vector&lt;Elem *&gt;::iterator el        = new_elements.begin();</div><div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;    <span class="keyword">const</span> std::vector&lt;Elem *&gt;::iterator <a class="code" href="variant__filter__iterator_8h.html#a785f0bd261d7bd1918b031c5133da2b9">end</a> = new_elements.end();</div><div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;    <span class="keywordflow">for</span> (; el != <a class="code" href="variant__filter__iterator_8h.html#a785f0bd261d7bd1918b031c5133da2b9">end</a>; ++el)</div><div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;      <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.add_elem(*el);</div><div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;  }</div><div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;</div><div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;  <span class="keywordflow">if</span> (mesh_has_boundary_data)</div><div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;    {</div><div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;      <span class="comment">// If the old mesh had boundary data, the new mesh better have</span></div><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;      <span class="comment">// some.  However, we can&#39;t assert that the size of</span></div><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;      <span class="comment">// new_bndry_elements vector is &gt; 0, since we may not have split</span></div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;      <span class="comment">// any elements actually on the boundary.  We also can&#39;t assert</span></div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;      <span class="comment">// that the original number of boundary sides is equal to the</span></div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;      <span class="comment">// sum of the boundary sides currently in the mesh and the</span></div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;      <span class="comment">// newly-added boundary sides, since in 3D, we may have split a</span></div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;      <span class="comment">// boundary QUAD into two boundary TRIs.  Therefore, we won&#39;t be</span></div><div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;      <span class="comment">// too picky about the actual number of BCs, and just assert that</span></div><div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;      <span class="comment">// there are some, somewhere.</span></div><div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;<span class="preprocessor">#ifndef NDEBUG</span></div><div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;      <span class="keywordtype">bool</span> nbe_nonempty = new_bndry_elements.size();</div><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;      <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.comm().max(nbe_nonempty);</div><div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;      libmesh_assert(nbe_nonempty ||</div><div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;                     <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.get_boundary_info().n_boundary_conds()&gt;0);</div><div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;</div><div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;      <span class="comment">// We should also be sure that the lengths of the new boundary data vectors</span></div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;      <span class="comment">// are all the same.</span></div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;      libmesh_assert_equal_to (new_bndry_elements.size(), new_bndry_sides.size());</div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;      libmesh_assert_equal_to (new_bndry_sides.size(), new_bndry_ids.size());</div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;</div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;      <span class="comment">// Add the new boundary info to the mesh</span></div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;      <span class="keywordflow">for</span> (std::size_t s=0; s&lt;new_bndry_elements.size(); ++s)</div><div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;        <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.get_boundary_info().add_side(new_bndry_elements[s],</div><div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;                                          new_bndry_sides[s],</div><div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;                                          new_bndry_ids[s]);</div><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;    }</div><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;</div><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;  <span class="comment">// In a DistributedMesh any newly added ghost node ids may be</span></div><div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;  <span class="comment">// inconsistent, and unique_ids of newly added ghost nodes remain</span></div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;  <span class="comment">// unset.</span></div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;  <span class="comment">// make_nodes_parallel_consistent() will fix all this.</span></div><div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.is_serial())</div><div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;    {</div><div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;      <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.comm().max(added_new_ghost_point);</div><div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;</div><div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;      <span class="keywordflow">if</span> (added_new_ghost_point)</div><div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;        MeshCommunication().make_nodes_parallel_consistent (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div><div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;    }</div><div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;</div><div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;</div><div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;</div><div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;  <span class="comment">// Prepare the newly created mesh for use.</span></div><div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;  <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.prepare_for_use(<span class="comment">/*skip_renumber =*/</span> <span class="keyword">false</span>);</div><div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;</div><div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;  <span class="comment">// Let the new_elements and new_bndry_elements vectors go out of scope.</span></div><div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;}</div><div class="ttc" id="namespacelibMesh_html_a3f482b3acb4beb528f0ce89f161ff967"><div class="ttname"><a href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967">libMesh::ElemType</a></div><div class="ttdeci">ElemType</div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00033">enum_elem_type.h:33</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a3f482b3acb4beb528f0ce89f161ff967a850fa5218d8f69ab09f5bccaf40b615a"><div class="ttname"><a href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967a850fa5218d8f69ab09f5bccaf40b615a">libMesh::QUAD8</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00042">enum_elem_type.h:42</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a3f482b3acb4beb528f0ce89f161ff967aa33084719a3fb5ecc72a02917efb81d1"><div class="ttname"><a href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967aa33084719a3fb5ecc72a02917efb81d1">libMesh::INFEDGE2</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00057">enum_elem_type.h:57</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a3f482b3acb4beb528f0ce89f161ff967a981ce1f0fa792d7701b14e102b00d569"><div class="ttname"><a href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967a981ce1f0fa792d7701b14e102b00d569">libMesh::EDGE4</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00037">enum_elem_type.h:37</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a3f482b3acb4beb528f0ce89f161ff967ad2d41a1a3e6858d350ab42e16fccf43b"><div class="ttname"><a href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967ad2d41a1a3e6858d350ab42e16fccf43b">libMesh::TET10</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00046">enum_elem_type.h:46</a></div></div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
<div class="ttc" id="variant__filter__iterator_8h_html_a785f0bd261d7bd1918b031c5133da2b9"><div class="ttname"><a href="variant__filter__iterator_8h.html#a785f0bd261d7bd1918b031c5133da2b9">end</a></div><div class="ttdeci">IterBase * end</div><div class="ttdef"><b>Definition:</b> <a href="variant__filter__iterator_8h_source.html#l00343">variant_filter_iterator.h:343</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a3f482b3acb4beb528f0ce89f161ff967a7d5e155bd4ed469d374f3893fdc80084"><div class="ttname"><a href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967a7d5e155bd4ed469d374f3893fdc80084">libMesh::INFQUAD4</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00058">enum_elem_type.h:58</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a3f482b3acb4beb528f0ce89f161ff967acccb9e40eddc1b28768f2128fe1a8f08"><div class="ttname"><a href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967acccb9e40eddc1b28768f2128fe1a8f08">libMesh::TRI3</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00039">enum_elem_type.h:39</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a3f482b3acb4beb528f0ce89f161ff967af4b68709f9e0a488822d3399de3508b1"><div class="ttname"><a href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967af4b68709f9e0a488822d3399de3508b1">libMesh::QUAD4</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00041">enum_elem_type.h:41</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a3f482b3acb4beb528f0ce89f161ff967abcb630ebd46df2f7f02ed36d71bb46ac"><div class="ttname"><a href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967abcb630ebd46df2f7f02ed36d71bb46ac">libMesh::INFPRISM12</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00064">enum_elem_type.h:64</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a3f482b3acb4beb528f0ce89f161ff967aa05775ffcc750504160cfe0113308cb9"><div class="ttname"><a href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967aa05775ffcc750504160cfe0113308cb9">libMesh::TET4</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00045">enum_elem_type.h:45</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a3f482b3acb4beb528f0ce89f161ff967aad2d0656d7cf0f061899c655560c1e55"><div class="ttname"><a href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967aad2d0656d7cf0f061899c655560c1e55">libMesh::TRI6</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00040">enum_elem_type.h:40</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a3f482b3acb4beb528f0ce89f161ff967ac6c81ee0d1fa09307be4b13a3982252b"><div class="ttname"><a href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967ac6c81ee0d1fa09307be4b13a3982252b">libMesh::INFPRISM6</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00063">enum_elem_type.h:63</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a74e5bc8a72d210b3d87b0221b1f69db1"><div class="ttname"><a href="namespacelibMesh.html#a74e5bc8a72d210b3d87b0221b1f69db1">libMesh::err</a></div><div class="ttdeci">OStreamProxy err(std::cerr)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00229">libmesh_common.h:229</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a3f482b3acb4beb528f0ce89f161ff967a22110502dcd368586afad8a0a40f4f07"><div class="ttname"><a href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967a22110502dcd368586afad8a0a40f4f07">libMesh::INFQUAD6</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00059">enum_elem_type.h:59</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a3f482b3acb4beb528f0ce89f161ff967aa656f2b4aa8cff7ff974765c83a76820"><div class="ttname"><a href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967aa656f2b4aa8cff7ff974765c83a76820">libMesh::EDGE2</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00035">enum_elem_type.h:35</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a3f482b3acb4beb528f0ce89f161ff967a2d7bef790b667ca2769e52ce6de8b9fd"><div class="ttname"><a href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967a2d7bef790b667ca2769e52ce6de8b9fd">libMesh::QUAD9</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00043">enum_elem_type.h:43</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a3f482b3acb4beb528f0ce89f161ff967aa483bcc949d5b563a091996fb8b9ec3e"><div class="ttname"><a href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967aa483bcc949d5b563a091996fb8b9ec3e">libMesh::PRISM6</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00050">enum_elem_type.h:50</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a3f482b3acb4beb528f0ce89f161ff967a7994064d3565a0a07f0c02fc99ea6068"><div class="ttname"><a href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967a7994064d3565a0a07f0c02fc99ea6068">libMesh::PRISM18</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00052">enum_elem_type.h:52</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a3f482b3acb4beb528f0ce89f161ff967a3251dc5224670944ad87d1b9ab397c59"><div class="ttname"><a href="namespacelibMesh.html#a3f482b3acb4beb528f0ce89f161ff967a3251dc5224670944ad87d1b9ab397c59">libMesh::EDGE3</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00036">enum_elem_type.h:36</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a0c8246ed396fb6017ccc59711d9b9f7e"><div class="ttname"><a href="namespacelibMesh.html#a0c8246ed396fb6017ccc59711d9b9f7e">libMesh::unique_id_type</a></div><div class="ttdeci">uint8_t unique_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00079">id_types.h:79</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00064">id_types.h:64</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a903992f631b52b5ba05ad96a51e7b383"><div class="ttname"><a href="namespacelibMesh.html#a903992f631b52b5ba05ad96a51e7b383">libMesh::remote_elem</a></div><div class="ttdeci">const RemoteElem * remote_elem</div><div class="ttdef"><b>Definition:</b> <a href="remote__elem_8C_source.html#l00057">remote_elem.C:57</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a355d0c7c33b55d44e9e77946caadbef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355d0c7c33b55d44e9e77946caadbef6">&#9670;&nbsp;</a></span>change_boundary_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshTools::Modification::change_boundary_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelibMesh.html#a3f4d8a52b5ef6ff6156ca209e12b5564">boundary_id_type</a>&#160;</td>
          <td class="paramname"><em>old_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelibMesh.html#a3f4d8a52b5ef6ff6156ca209e12b5564">boundary_id_type</a>&#160;</td>
          <td class="paramname"><em>new_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds any boundary ids that are currently old_id, changes them to new_id </p>

<p class="definition">Definition at line <a class="el" href="mesh__modification_8C_source.html#l01374">1374</a> of file <a class="el" href="mesh__modification_8C_source.html">mesh_modification.C</a>.</p>

<p class="reference">References <a class="el" href="boundary__info_8C_source.html#l00670">libMesh::BoundaryInfo::add_edge()</a>, <a class="el" href="boundary__info_8C_source.html#l00599">libMesh::BoundaryInfo::add_node()</a>, <a class="el" href="boundary__info_8C_source.html#l00757">libMesh::BoundaryInfo::add_shellface()</a>, <a class="el" href="boundary__info_8C_source.html#l00849">libMesh::BoundaryInfo::add_side()</a>, <a class="el" href="boundary__info_8C_source.html#l00948">libMesh::BoundaryInfo::boundary_ids()</a>, <a class="el" href="boundary__info_8C_source.html#l02122">libMesh::BoundaryInfo::build_edge_list()</a>, <a class="el" href="boundary__info_8C_source.html#l01735">libMesh::BoundaryInfo::build_node_list()</a>, <a class="el" href="boundary__info_8C_source.html#l02170">libMesh::BoundaryInfo::build_shellface_list()</a>, <a class="el" href="boundary__info_8C_source.html#l02007">libMesh::BoundaryInfo::build_side_list()</a>, <a class="el" href="boundary__info_8C_source.html#l00981">libMesh::BoundaryInfo::edge_boundary_ids()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a429c4ffe9f54dbb58c38fa7f73800abd">libMesh::MeshBase::elem_ptr()</a>, <a class="el" href="mesh__base_8h_source.html#l00131">libMesh::MeshBase::get_boundary_info()</a>, <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#abc2fd76e7bf6c200f5e8849dfca9cd03">libMesh::MeshBase::node_ptr()</a>, <a class="el" href="boundary__info_8C_source.html#l01321">libMesh::BoundaryInfo::remove()</a>, <a class="el" href="boundary__info_8C_source.html#l01343">libMesh::BoundaryInfo::remove_edge()</a>, <a class="el" href="boundary__info_8C_source.html#l01511">libMesh::BoundaryInfo::remove_id()</a>, <a class="el" href="boundary__info_8C_source.html#l01397">libMesh::BoundaryInfo::remove_shellface()</a>, <a class="el" href="boundary__info_8C_source.html#l01460">libMesh::BoundaryInfo::remove_side()</a>, <a class="el" href="boundary__info_8C_source.html#l01096">libMesh::BoundaryInfo::shellface_boundary_ids()</a>, and <a class="el" href="xdr__io_8C_source.html#l00050">side</a>.</p>
<div class="fragment"><div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;{</div><div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;  <span class="keywordflow">if</span> (old_id == new_id)</div><div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;    {</div><div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;      <span class="comment">// If the IDs are the same, this is a no-op.</span></div><div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;      <span class="keywordflow">return</span>;</div><div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;    }</div><div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;</div><div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;  <span class="comment">// A reference to the Mesh&#39;s BoundaryInfo object, for convenience.</span></div><div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;  BoundaryInfo &amp; bi = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.get_boundary_info();</div><div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;</div><div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;  {</div><div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;    <span class="comment">// Temporary vector to hold ids</span></div><div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;    std::vector&lt;boundary_id_type&gt; bndry_ids;</div><div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;</div><div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;    <span class="comment">// build_node_list returns a vector of (node, bc) tuples.</span></div><div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; t : bi.build_node_list())</div><div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;      <span class="keywordflow">if</span> (std::get&lt;1&gt;(t) == old_id)</div><div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;        {</div><div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;          <span class="comment">// Get the node in question</span></div><div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;          <span class="keyword">const</span> Node * node = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.node_ptr(std::get&lt;0&gt;(t));</div><div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;</div><div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;          <span class="comment">// Get all the current IDs for this node.</span></div><div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;          bi.boundary_ids(node, bndry_ids);</div><div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;</div><div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;          <span class="comment">// Update the IDs accordingly</span></div><div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;          std::replace(bndry_ids.begin(), bndry_ids.end(), old_id, new_id);</div><div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;</div><div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;          <span class="comment">// Remove all traces of that node from the BoundaryInfo object</span></div><div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;          bi.remove(node);</div><div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;</div><div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;          <span class="comment">// Add it back with the updated IDs</span></div><div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;          bi.add_node(node, bndry_ids);</div><div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;        }</div><div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;  }</div><div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;</div><div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;  {</div><div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;    <span class="comment">// Temporary vector to hold ids</span></div><div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;    std::vector&lt;boundary_id_type&gt; bndry_ids;</div><div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;</div><div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;    <span class="comment">// build_edge_list returns a vector of (elem, side, bc) tuples.</span></div><div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; t : bi.build_edge_list())</div><div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;      <span class="keywordflow">if</span> (std::get&lt;2&gt;(t) == old_id)</div><div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;        {</div><div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;          <span class="comment">// Get the elem in question</span></div><div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;          <span class="keyword">const</span> Elem * elem = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.elem_ptr(std::get&lt;0&gt;(t));</div><div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;</div><div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;          <span class="comment">// The edge of the elem in question</span></div><div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;          <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <span class="keywordtype">int</span> edge = std::get&lt;1&gt;(t);</div><div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;</div><div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;          <span class="comment">// Get all the current IDs for the edge in question.</span></div><div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;          bi.edge_boundary_ids(elem, edge, bndry_ids);</div><div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;</div><div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;          <span class="comment">// Update the IDs accordingly</span></div><div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;          std::replace(bndry_ids.begin(), bndry_ids.end(), old_id, new_id);</div><div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;</div><div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160;          <span class="comment">// Remove all traces of that edge from the BoundaryInfo object</span></div><div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;          bi.remove_edge(elem, edge);</div><div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;</div><div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160;          <span class="comment">// Add it back with the updated IDs</span></div><div class="line"><a name="l01436"></a><span class="lineno"> 1436</span>&#160;          bi.add_edge(elem, edge, bndry_ids);</div><div class="line"><a name="l01437"></a><span class="lineno"> 1437</span>&#160;        }</div><div class="line"><a name="l01438"></a><span class="lineno"> 1438</span>&#160;  }</div><div class="line"><a name="l01439"></a><span class="lineno"> 1439</span>&#160;</div><div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160;  {</div><div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;    <span class="comment">// Temporary vector to hold ids</span></div><div class="line"><a name="l01442"></a><span class="lineno"> 1442</span>&#160;    std::vector&lt;boundary_id_type&gt; bndry_ids;</div><div class="line"><a name="l01443"></a><span class="lineno"> 1443</span>&#160;</div><div class="line"><a name="l01444"></a><span class="lineno"> 1444</span>&#160;    <span class="comment">// build_shellface_list returns a vector of (elem, side, bc) tuples.</span></div><div class="line"><a name="l01445"></a><span class="lineno"> 1445</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; t : bi.build_shellface_list())</div><div class="line"><a name="l01446"></a><span class="lineno"> 1446</span>&#160;      <span class="keywordflow">if</span> (std::get&lt;2&gt;(t) == old_id)</div><div class="line"><a name="l01447"></a><span class="lineno"> 1447</span>&#160;        {</div><div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;          <span class="comment">// Get the elem in question</span></div><div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;          <span class="keyword">const</span> Elem * elem = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.elem_ptr(std::get&lt;0&gt;(t));</div><div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160;</div><div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;          <span class="comment">// The shellface of the elem in question</span></div><div class="line"><a name="l01452"></a><span class="lineno"> 1452</span>&#160;          <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <span class="keywordtype">int</span> shellface = std::get&lt;1&gt;(t);</div><div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;</div><div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160;          <span class="comment">// Get all the current IDs for the shellface in question.</span></div><div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160;          bi.shellface_boundary_ids(elem, shellface, bndry_ids);</div><div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;</div><div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160;          <span class="comment">// Update the IDs accordingly</span></div><div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;          std::replace(bndry_ids.begin(), bndry_ids.end(), old_id, new_id);</div><div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;</div><div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;          <span class="comment">// Remove all traces of that shellface from the BoundaryInfo object</span></div><div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160;          bi.remove_shellface(elem, shellface);</div><div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;</div><div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;          <span class="comment">// Add it back with the updated IDs</span></div><div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;          bi.add_shellface(elem, shellface, bndry_ids);</div><div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;        }</div><div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160;  }</div><div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;</div><div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;  {</div><div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;    <span class="comment">// Temporary vector to hold ids</span></div><div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;    std::vector&lt;boundary_id_type&gt; bndry_ids;</div><div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;</div><div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160;    <span class="comment">// build_side_list returns a vector of (elem, side, bc) tuples.</span></div><div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; t : bi.build_side_list())</div><div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;      <span class="keywordflow">if</span> (std::get&lt;2&gt;(t) == old_id)</div><div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;        {</div><div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;          <span class="comment">// Get the elem in question</span></div><div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;          <span class="keyword">const</span> Elem * elem = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.elem_ptr(std::get&lt;0&gt;(t));</div><div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;</div><div class="line"><a name="l01479"></a><span class="lineno"> 1479</span>&#160;          <span class="comment">// The side of the elem in question</span></div><div class="line"><a name="l01480"></a><span class="lineno"> 1480</span>&#160;          <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <span class="keywordtype">int</span> <a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a> = std::get&lt;1&gt;(t);</div><div class="line"><a name="l01481"></a><span class="lineno"> 1481</span>&#160;</div><div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;          <span class="comment">// Get all the current IDs for the side in question.</span></div><div class="line"><a name="l01483"></a><span class="lineno"> 1483</span>&#160;          bi.boundary_ids(elem, <a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>, bndry_ids);</div><div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160;</div><div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160;          <span class="comment">// Update the IDs accordingly</span></div><div class="line"><a name="l01486"></a><span class="lineno"> 1486</span>&#160;          std::replace(bndry_ids.begin(), bndry_ids.end(), old_id, new_id);</div><div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;</div><div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;          <span class="comment">// Remove all traces of that side from the BoundaryInfo object</span></div><div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160;          bi.remove_side(elem, <a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>);</div><div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;</div><div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;          <span class="comment">// Add it back with the updated IDs</span></div><div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;          bi.add_side(elem, <a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>, bndry_ids);</div><div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;        }</div><div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;  }</div><div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160;</div><div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160;  <span class="comment">// Remove any remaining references to the old_id so it does not show</span></div><div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160;  <span class="comment">// up in lists of boundary ids, etc.</span></div><div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160;  bi.remove_id(old_id);</div><div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;}</div><div class="ttc" id="xdr__io_8C_html_a538c9c249908c84b07be8ce1400b82c9"><div class="ttname"><a href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a></div><div class="ttdeci">unsigned short int side</div><div class="ttdef"><b>Definition:</b> <a href="xdr__io_8C_source.html#l00050">xdr_io.C:50</a></div></div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a30caf6b7a7280e592b7c177ff85b97a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30caf6b7a7280e592b7c177ff85b97a0">&#9670;&nbsp;</a></span>change_subdomain_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshTools::Modification::change_subdomain_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelibMesh.html#a634d676f703fd1cf217d85d6794abcb3">subdomain_id_type</a>&#160;</td>
          <td class="paramname"><em>old_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelibMesh.html#a634d676f703fd1cf217d85d6794abcb3">subdomain_id_type</a>&#160;</td>
          <td class="paramname"><em>new_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds any subdomain ids that are currently old_id, changes them to new_id </p>

<p class="definition">Definition at line <a class="el" href="mesh__modification_8C_source.html#l01503">1503</a> of file <a class="el" href="mesh__modification_8C_source.html">mesh_modification.C</a>.</p>

<p class="reference">References <a class="el" href="classlibMesh_1_1MeshBase.html#a5173d38b4db709085b1cde698137d042">libMesh::MeshBase::element_ptr_range()</a>, <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>, and <a class="el" href="elem_8h_source.html#l02034">libMesh::Elem::subdomain_id()</a>.</p>
<div class="fragment"><div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160;{</div><div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160;  <span class="keywordflow">if</span> (old_id == new_id)</div><div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;    {</div><div class="line"><a name="l01509"></a><span class="lineno"> 1509</span>&#160;      <span class="comment">// If the IDs are the same, this is a no-op.</span></div><div class="line"><a name="l01510"></a><span class="lineno"> 1510</span>&#160;      <span class="keywordflow">return</span>;</div><div class="line"><a name="l01511"></a><span class="lineno"> 1511</span>&#160;    }</div><div class="line"><a name="l01512"></a><span class="lineno"> 1512</span>&#160;</div><div class="line"><a name="l01513"></a><span class="lineno"> 1513</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.element_ptr_range())</div><div class="line"><a name="l01514"></a><span class="lineno"> 1514</span>&#160;    {</div><div class="line"><a name="l01515"></a><span class="lineno"> 1515</span>&#160;      <span class="keywordflow">if</span> (elem-&gt;subdomain_id() == old_id)</div><div class="line"><a name="l01516"></a><span class="lineno"> 1516</span>&#160;        elem-&gt;subdomain_id() = new_id;</div><div class="line"><a name="l01517"></a><span class="lineno"> 1517</span>&#160;    }</div><div class="line"><a name="l01518"></a><span class="lineno"> 1518</span>&#160;}</div><div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab3c34bd675ddf6c6675daa7fcc96d7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c34bd675ddf6c6675daa7fcc96d7cf">&#9670;&nbsp;</a></span>distort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshTools::Modification::distort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>perturb_boundary</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Randomly perturb the nodal locations. This function will move each node <code>factor</code> fraction of its minimum neighboring node separation distance. Nodes on the boundary are not moved by default, however they may be by setting the flag <code>perturb_boundary</code> true. </p>

<p class="definition">Definition at line <a class="el" href="mesh__modification_8C_source.html#l00065">65</a> of file <a class="el" href="mesh__modification_8C_source.html">mesh_modification.C</a>.</p>

<p class="reference">References <a class="el" href="classlibMesh_1_1MeshBase.html#af744c644dfa9b7912eda9cf4f55db03a">libMesh::MeshBase::active_element_ptr_range()</a>, <a class="el" href="mesh__tools_8C_source.html#l00303">libMesh::MeshTools::find_boundary_nodes()</a>, <a class="el" href="elem_8C_source.html#l00356">libMesh::Elem::hmin()</a>, <a class="el" href="libmesh__augment__std__namespace_8h_source.html#l00027">std::max()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a613704304440df6ceafa622096befe68">libMesh::MeshBase::max_node_id()</a>, <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>, <a class="el" href="mesh__base_8C_source.html#l00126">libMesh::MeshBase::mesh_dimension()</a>, <a class="el" href="libmesh__augment__std__namespace_8h_source.html#l00029">std::min()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a190e556d3be87f5ccd8d4fc98d1779d3">libMesh::MeshBase::n_elem()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a5b76b109bc6bd087c981774897aa6167">libMesh::MeshBase::n_nodes()</a>, <a class="el" href="elem_8h_source.html#l02130">libMesh::Elem::node_ref_range()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a88d3228c36aa7b481f0f5d77f95bd021">libMesh::MeshBase::query_node_ptr()</a>, and <a class="el" href="type__vector_8C_source.html#l00037">libMesh::TypeVector&lt; T &gt;::unit()</a>.</p>
<div class="fragment"><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;{</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  libmesh_assert (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.n_nodes());</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  libmesh_assert (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.n_elem());</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  libmesh_assert ((factor &gt;= 0.) &amp;&amp; (factor &lt;= 1.));</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  LOG_SCOPE(<span class="stringliteral">&quot;distort()&quot;</span>, <span class="stringliteral">&quot;MeshTools::Modification&quot;</span>);</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  <span class="comment">// If we are not perturbing boundary nodes, make a</span></div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  <span class="comment">// quickly-searchable list of node ids we can check against.</span></div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  std::unordered_set&lt;dof_id_type&gt; boundary_node_ids;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  <span class="keywordflow">if</span> (!perturb_boundary)</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    boundary_node_ids = <a class="code" href="namespacelibMesh_1_1MeshTools.html#a0fd39d630f54c93571ee6449e8b15550">MeshTools::find_boundary_nodes</a> (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;  <span class="comment">// Now calculate the minimum distance to</span></div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  <span class="comment">// neighboring nodes for each node.</span></div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <span class="comment">// hmin holds these distances.</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  std::vector&lt;float&gt; hmin (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.max_node_id(),</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;                           <a class="code" href="namespacestd.html#a6987c84b7beab8b2ebdee7e2549d698f">std::numeric_limits&lt;float&gt;::max</a>());</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; elem : <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.active_element_ptr_range())</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; n : elem-&gt;node_ref_range())</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;      hmin[n.id()] = <a class="code" href="namespacestd.html#a4444b32c7044d9b34125eaebd070a0e3">std::min</a>(hmin[n.id()],</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;                              <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(elem-&gt;hmin()));</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;  <span class="comment">// Now actually move the nodes</span></div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;  {</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> seed = 123456;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    <span class="comment">// seed the random number generator.</span></div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    <span class="comment">// We&#39;ll loop from 1 to n_nodes on every processor, even those</span></div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    <span class="comment">// that don&#39;t have a particular node, so that the pseudorandom</span></div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="comment">// numbers will be the same everywhere.</span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    std::srand(seed);</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    <span class="comment">// If the node is on the boundary or</span></div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    <span class="comment">// the node is not used by any element (hmin[n]&lt;1.e20)</span></div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    <span class="comment">// then we should not move it.</span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    <span class="comment">// [Note: Testing for (in)equality might be wrong</span></div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    <span class="comment">// (different types, namely float and double)]</span></div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n=0; n&lt;<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.max_node_id(); n++)</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;      <span class="keywordflow">if</span> ((perturb_boundary || !boundary_node_ids.count(n)) &amp;&amp; hmin[n] &lt; 1.e20)</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        {</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;          <span class="comment">// the direction, random but unit normalized</span></div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;          Point dir (static_cast&lt;Real&gt;(std::rand())/static_cast&lt;Real&gt;(RAND_MAX),</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;                     (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.mesh_dimension() &gt; 1) ? static_cast&lt;Real&gt;(std::rand())/static_cast&lt;Real&gt;(RAND_MAX) : 0.,</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;                     ((<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.mesh_dimension() == 3) ? static_cast&lt;<a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&gt;(<a class="code" href="namespacestd.html">std</a>::rand())/static_cast&lt;<a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&gt;(RAND_MAX) : 0.));</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;          dir(0) = (dir(0)-.5)*2.;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;          <span class="keywordflow">if</span> (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.mesh_dimension() &gt; 1)</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;            dir(1) = (dir(1)-.5)*2.;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;          <span class="keywordflow">if</span> (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.mesh_dimension() == 3)</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;            dir(2) = (dir(2)-.5)*2.;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;          dir = dir.unit();</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;          Node * node = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.query_node_ptr(n);</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;          <span class="keywordflow">if</span> (!node)</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;          (*node)(0) += dir(0)*factor*hmin[n];</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;          <span class="keywordflow">if</span> (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.mesh_dimension() &gt; 1)</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;            (*node)(1) += dir(1)*factor*hmin[n];</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;          <span class="keywordflow">if</span> (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.mesh_dimension() == 3)</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;            (*node)(2) += dir(2)*factor*hmin[n];</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        }</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;  }</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;}</div><div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
<div class="ttc" id="namespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdef"><b>Definition:</b> <a href="libmesh__augment__std__namespace_8h_source.html#l00026">libmesh_augment_std_namespace.h:26</a></div></div>
<div class="ttc" id="namespacestd_html_a6987c84b7beab8b2ebdee7e2549d698f"><div class="ttname"><a href="namespacestd.html#a6987c84b7beab8b2ebdee7e2549d698f">std::max</a></div><div class="ttdeci">long double max(long double a, double b)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__augment__std__namespace_8h_source.html#l00027">libmesh_augment_std_namespace.h:27</a></div></div>
<div class="ttc" id="namespacelibMesh_html_aef28359fb4851abec08fc99cfbac118d"><div class="ttname"><a href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">libMesh::Real</a></div><div class="ttdeci">DIE A HORRIBLE DEATH HERE typedef LIBMESH_DEFAULT_SCALAR_TYPE Real</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00131">libmesh_common.h:131</a></div></div>
<div class="ttc" id="namespacestd_html_a4444b32c7044d9b34125eaebd070a0e3"><div class="ttname"><a href="namespacestd.html#a4444b32c7044d9b34125eaebd070a0e3">std::min</a></div><div class="ttdeci">long double min(long double a, double b)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__augment__std__namespace_8h_source.html#l00029">libmesh_augment_std_namespace.h:29</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_a0fd39d630f54c93571ee6449e8b15550"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#a0fd39d630f54c93571ee6449e8b15550">libMesh::MeshTools::find_boundary_nodes</a></div><div class="ttdeci">void find_boundary_nodes(const MeshBase &amp;mesh, std::vector&lt; bool &gt; &amp;on_boundary)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00303">mesh_tools.C:303</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a31ce3f7f69838b3326f9bcabae3f2cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ce3f7f69838b3326f9bcabae3f2cd6">&#9670;&nbsp;</a></span>flatten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshTools::Modification::flatten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all the refinement tree structure of <a class="el" href="classlibMesh_1_1Mesh.html" title="Manages a collection of Nodes and Elems. ">Mesh</a>, leaving only the highest-level (most-refined) elements. This is useful when you want to write out a uniformly-refined grid to be treated later as an initial mesh.</p>
<dl class="section note"><dt>Note</dt><dd>Many functions in LibMesh assume a conforming (with no hanging nodes) grid exists at some level, so you probably only want to do this on meshes which have been uniformly refined. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mesh__modification_8C_source.html#l01260">1260</a> of file <a class="el" href="mesh__modification_8C_source.html">mesh_modification.C</a>.</p>

<p class="reference">References <a class="el" href="classlibMesh_1_1MeshBase.html#af744c644dfa9b7912eda9cf4f55db03a">libMesh::MeshBase::active_element_ptr_range()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a5ab834283fa6bc335ad623d2b737ec5e">libMesh::MeshBase::add_elem()</a>, <a class="el" href="boundary__info_8C_source.html#l00849">libMesh::BoundaryInfo::add_side()</a>, <a class="el" href="xdr__io_8C_source.html#l00051">bc_id</a>, <a class="el" href="boundary__info_8C_source.html#l00948">libMesh::BoundaryInfo::boundary_ids()</a>, <a class="el" href="elem_8C_source.html#l00245">libMesh::Elem::build()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a5c7824047ed759b5a4891a6936b546cc">libMesh::MeshBase::delete_elem()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a5173d38b4db709085b1cde698137d042">libMesh::MeshBase::element_ptr_range()</a>, <a class="el" href="mesh__base_8h_source.html#l00131">libMesh::MeshBase::get_boundary_info()</a>, <a class="el" href="dof__object_8h_source.html#l00655">libMesh::DofObject::id()</a>, <a class="el" href="boundary__info_8h_source.html#l00875">libMesh::BoundaryInfo::invalid_id</a>, <a class="el" href="libmesh__common_8h_source.html#l00461">libMesh::libmesh_ignore()</a>, <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#ae5b70f8be225d006fb25ef1e6b82bc3a">libMesh::MeshBase::n_active_elem()</a>, <a class="el" href="boundary__info_8C_source.html#l01646">libMesh::BoundaryInfo::n_boundary_conds()</a>, <a class="el" href="elem_8h_source.html#l02050">libMesh::Elem::neighbor_ptr()</a>, <a class="el" href="elem_8h_source.html#l02148">libMesh::Elem::node_index_range()</a>, <a class="el" href="elem_8h_source.html#l01957">libMesh::Elem::node_ptr()</a>, <a class="el" href="mesh__base_8C_source.html#l00152">libMesh::MeshBase::prepare_for_use()</a>, <a class="el" href="dof__object_8h_source.html#l00717">libMesh::DofObject::processor_id()</a>, <a class="el" href="remote__elem_8C_source.html#l00057">libMesh::remote_elem</a>, <a class="el" href="dof__object_8h_source.html#l00664">libMesh::DofObject::set_id()</a>, <a class="el" href="elem_8h_source.html#l02083">libMesh::Elem::set_neighbor()</a>, <a class="el" href="elem_8h_source.html#l02024">libMesh::Elem::set_node()</a>, <a class="el" href="dof__object_8h_source.html#l00685">libMesh::DofObject::set_unique_id()</a>, <a class="el" href="elem_8h_source.html#l02166">libMesh::Elem::side_index_range()</a>, <a class="el" href="elem_8h_source.html#l02034">libMesh::Elem::subdomain_id()</a>, <a class="el" href="classlibMesh_1_1Elem.html#ad06f8ac22978144723179eed42d10bae">libMesh::Elem::type()</a>, and <a class="el" href="dof__object_8h_source.html#l00672">libMesh::DofObject::unique_id()</a>.</p>
<div class="fragment"><div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;{</div><div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;  <span class="comment">// Algorithm:</span></div><div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;  <span class="comment">// .) For each active element in the mesh: construct a</span></div><div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;  <span class="comment">//    copy which is the same in every way *except* it is</span></div><div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;  <span class="comment">//    a level 0 element.  Store the pointers to these in</span></div><div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;  <span class="comment">//    a separate vector. Save any boundary information as well.</span></div><div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;  <span class="comment">//    Delete the active element from the mesh.</span></div><div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;  <span class="comment">// .) Loop over all (remaining) elements in the mesh, delete them.</span></div><div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;  <span class="comment">// .) Add the level-0 copies back to the mesh</span></div><div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;</div><div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;  <span class="comment">// Temporary storage for new element pointers</span></div><div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;  std::vector&lt;Elem *&gt; new_elements;</div><div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;</div><div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;  <span class="comment">// BoundaryInfo Storage for element ids, sides, and BC ids</span></div><div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;  std::vector&lt;Elem *&gt;              saved_boundary_elements;</div><div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;  std::vector&lt;boundary_id_type&gt;   saved_bc_ids;</div><div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;  std::vector&lt;unsigned short int&gt; saved_bc_sides;</div><div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;</div><div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;  <span class="comment">// Container to catch boundary ids passed back by BoundaryInfo</span></div><div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;  std::vector&lt;boundary_id_type&gt; bc_ids;</div><div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;</div><div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;  <span class="comment">// Reserve a reasonable amt. of space for each</span></div><div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;  new_elements.reserve(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.n_active_elem());</div><div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;  saved_boundary_elements.reserve(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.get_boundary_info().n_boundary_conds());</div><div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;  saved_bc_ids.reserve(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.get_boundary_info().n_boundary_conds());</div><div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;  saved_bc_sides.reserve(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.get_boundary_info().n_boundary_conds());</div><div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;</div><div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.active_element_ptr_range())</div><div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;    {</div><div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;      <span class="comment">// Make a new element of the same type</span></div><div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;      Elem * copy = Elem::build(elem-&gt;type()).release();</div><div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;</div><div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;      <span class="comment">// Set node pointers (they still point to nodes in the original mesh)</span></div><div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> n : elem-&gt;node_index_range())</div><div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;        copy-&gt;set_node(n) = elem-&gt;node_ptr(n);</div><div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;</div><div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;      <span class="comment">// Copy over ids</span></div><div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;      copy-&gt;processor_id() = elem-&gt;processor_id();</div><div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;      copy-&gt;subdomain_id() = elem-&gt;subdomain_id();</div><div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;</div><div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;      <span class="comment">// Retain the original element&#39;s ID(s) as well, otherwise</span></div><div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;      <span class="comment">// the Mesh may try to create them for you...</span></div><div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;      copy-&gt;set_id( elem-&gt;id() );</div><div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;<span class="preprocessor">#ifdef LIBMESH_ENABLE_UNIQUE_ID</span></div><div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;      copy-&gt;set_unique_id() = elem-&gt;unique_id();</div><div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;</div><div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;      <span class="comment">// This element could have boundary info or DistributedMesh</span></div><div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;      <span class="comment">// remote_elem links as well.  We need to save the (elem,</span></div><div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;      <span class="comment">// side, bc_id) triples and those links</span></div><div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> s : elem-&gt;side_index_range())</div><div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;        {</div><div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;          <span class="keywordflow">if</span> (elem-&gt;neighbor_ptr(s) == <a class="code" href="namespacelibMesh.html#a903992f631b52b5ba05ad96a51e7b383">remote_elem</a>)</div><div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;            copy-&gt;set_neighbor(s, const_cast&lt;RemoteElem *&gt;(<a class="code" href="namespacelibMesh.html#a903992f631b52b5ba05ad96a51e7b383">remote_elem</a>));</div><div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;</div><div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;          <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.get_boundary_info().boundary_ids(elem, s, bc_ids);</div><div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; <a class="code" href="xdr__io_8C.html#a7b966a996f9a3159d0be57a9c2e55df3">bc_id</a> : bc_ids)</div><div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="xdr__io_8C.html#a7b966a996f9a3159d0be57a9c2e55df3">bc_id</a> != BoundaryInfo::invalid_id)</div><div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;              {</div><div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;                saved_boundary_elements.push_back(copy);</div><div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;                saved_bc_ids.push_back(<a class="code" href="xdr__io_8C.html#a7b966a996f9a3159d0be57a9c2e55df3">bc_id</a>);</div><div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;                saved_bc_sides.push_back(s);</div><div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;              }</div><div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;        }</div><div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;</div><div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;</div><div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;      <span class="comment">// We&#39;re done with this element</span></div><div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;      <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.delete_elem(elem);</div><div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;</div><div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;      <span class="comment">// But save the copy</span></div><div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;      new_elements.push_back(copy);</div><div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;    }</div><div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;</div><div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;  <span class="comment">// Make sure we saved the same number of boundary conditions</span></div><div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;  <span class="comment">// in each vector.</span></div><div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;  libmesh_assert_equal_to (saved_boundary_elements.size(), saved_bc_ids.size());</div><div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;  libmesh_assert_equal_to (saved_bc_ids.size(), saved_bc_sides.size());</div><div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;</div><div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;  <span class="comment">// Loop again, delete any remaining elements</span></div><div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.element_ptr_range())</div><div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;    <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.delete_elem(elem);</div><div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;</div><div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;  <span class="comment">// Add the copied (now level-0) elements back to the mesh</span></div><div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; new_elem : new_elements)</div><div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;    {</div><div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;      <span class="comment">// Save the original ID, because the act of adding the Elem can</span></div><div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;      <span class="comment">// change new_elem&#39;s id!</span></div><div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;      <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> orig_id = new_elem-&gt;id();</div><div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;</div><div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;      Elem * added_elem = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.add_elem(new_elem);</div><div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;</div><div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;      <span class="comment">// If the Elem, as it was re-added to the mesh, now has a</span></div><div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;      <span class="comment">// different ID (this is unlikely, so it&#39;s just an assert)</span></div><div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;      <span class="comment">// the boundary information will no longer be correct.</span></div><div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;      libmesh_assert_equal_to (orig_id, added_elem-&gt;id());</div><div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;</div><div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;      <span class="comment">// Avoid compiler warnings in opt mode.</span></div><div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;      <a class="code" href="namespacelibMesh.html#a43f45640aab1af26176e69592c666432">libmesh_ignore</a>(added_elem, orig_id);</div><div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;    }</div><div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;</div><div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;  <span class="comment">// Finally, also add back the saved boundary information</span></div><div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;  <span class="keywordflow">for</span> (std::size_t e=0; e&lt;saved_boundary_elements.size(); ++e)</div><div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;    <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.get_boundary_info().add_side(saved_boundary_elements[e],</div><div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;                                      saved_bc_sides[e],</div><div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;                                      saved_bc_ids[e]);</div><div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;</div><div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;  <span class="comment">// Trim unused and renumber nodes and elements</span></div><div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;  <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.prepare_for_use(<span class="comment">/*skip_renumber =*/</span> <span class="keyword">false</span>);</div><div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;}</div><div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
<div class="ttc" id="xdr__io_8C_html_a7b966a996f9a3159d0be57a9c2e55df3"><div class="ttname"><a href="xdr__io_8C.html#a7b966a996f9a3159d0be57a9c2e55df3">bc_id</a></div><div class="ttdeci">boundary_id_type bc_id</div><div class="ttdef"><b>Definition:</b> <a href="xdr__io_8C_source.html#l00051">xdr_io.C:51</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a43f45640aab1af26176e69592c666432"><div class="ttname"><a href="namespacelibMesh.html#a43f45640aab1af26176e69592c666432">libMesh::libmesh_ignore</a></div><div class="ttdeci">void libmesh_ignore(const Args &amp;...)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00461">libmesh_common.h:461</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00064">id_types.h:64</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a903992f631b52b5ba05ad96a51e7b383"><div class="ttname"><a href="namespacelibMesh.html#a903992f631b52b5ba05ad96a51e7b383">libMesh::remote_elem</a></div><div class="ttdeci">const RemoteElem * remote_elem</div><div class="ttdef"><b>Definition:</b> <a href="remote__elem_8C_source.html#l00057">remote_elem.C:57</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9bb33f8faabadb6dbad5d5cf6c0efd9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb33f8faabadb6dbad5d5cf6c0efd9f">&#9670;&nbsp;</a></span>redistribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshTools::Modification::redistribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1FunctionBase.html">FunctionBase</a>&lt; <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapfunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deterministically perturb the nodal locations. This function will move each node from it's current x/y/z coordinates to a new x/y/z coordinate given by the first LIBMESH_DIM components of the specified function <code>mapfunc</code> </p>
<p>Nodes on the boundary are also moved.</p>
<p>Currently, non-vertex nodes are moved in the same way as vertex nodes, according to (newx,newy,newz) = mapfunc(x,y,z). This behavior is often suboptimal for higher order geometries and may be subject to change in future <a class="el" href="namespacelibMesh.html">libMesh</a> versions. </p>

<p class="definition">Definition at line <a class="el" href="mesh__modification_8C_source.html#l00138">138</a> of file <a class="el" href="mesh__modification_8C_source.html">mesh_modification.C</a>.</p>

<p class="reference">References <a class="el" href="classlibMesh_1_1FunctionBase.html#a1bfcfaf5b067f6c1b63b4d14d83078ef">libMesh::FunctionBase&lt; Output &gt;::clone()</a>, <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a190e556d3be87f5ccd8d4fc98d1779d3">libMesh::MeshBase::n_elem()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a5b76b109bc6bd087c981774897aa6167">libMesh::MeshBase::n_nodes()</a>, and <a class="el" href="classlibMesh_1_1MeshBase.html#a36c73b238ec8e3f2b2c2a7abd167206a">libMesh::MeshBase::node_ptr_range()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mesh__generation_8C_source.html#l00296">libMesh::MeshTools::Generation::build_cube()</a>.</p>
<div class="fragment"><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;{</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  libmesh_assert (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.n_nodes());</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  libmesh_assert (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.n_elem());</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;  LOG_SCOPE(<span class="stringliteral">&quot;redistribute()&quot;</span>, <span class="stringliteral">&quot;MeshTools::Modification&quot;</span>);</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;  DenseVector&lt;Real&gt; output_vec(LIBMESH_DIM);</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;  <span class="comment">// FIXME - we should thread this later.</span></div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;  std::unique_ptr&lt;FunctionBase&lt;Real&gt;&gt; myfunc = mapfunc.<a class="code" href="classlibMesh_1_1FunctionBase.html#a1bfcfaf5b067f6c1b63b4d14d83078ef">clone</a>();</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; node : <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.node_ptr_range())</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    {</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;      (*myfunc)(*node, output_vec);</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;      (*node)(0) = output_vec(0);</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="preprocessor">#if LIBMESH_DIM &gt; 1</span></div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;      (*node)(1) = output_vec(1);</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;<span class="preprocessor">#if LIBMESH_DIM &gt; 2</span></div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;      (*node)(2) = output_vec(2);</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    }</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;}</div><div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
<div class="ttc" id="classlibMesh_1_1FunctionBase_html_a1bfcfaf5b067f6c1b63b4d14d83078ef"><div class="ttname"><a href="classlibMesh_1_1FunctionBase.html#a1bfcfaf5b067f6c1b63b4d14d83078ef">libMesh::FunctionBase::clone</a></div><div class="ttdeci">virtual std::unique_ptr&lt; FunctionBase&lt; Output &gt; &gt; clone() const =0</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad1b9487f3155857fbc4c4201a748bc09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b9487f3155857fbc4c4201a748bc09">&#9670;&nbsp;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshTools::Modification::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td>
          <td class="paramname"><em>theta</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td>
          <td class="paramname"><em>psi</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rotates the mesh in the xy plane. The rotation is counter-clock-wise (mathematical definition). The angle is in degrees (360 make a full circle) Rotates the mesh in 3D space. Here the standard Euler angles are adopted (<a href="http://mathworld.wolfram.com/EulerAngles.html">http://mathworld.wolfram.com/EulerAngles.html</a>) The angles are in degrees (360 make a full circle) </p>

<p class="definition">Definition at line <a class="el" href="mesh__modification_8C_source.html#l00201">201</a> of file <a class="el" href="mesh__modification_8C_source.html">mesh_modification.C</a>.</p>

<p class="reference">References <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a36c73b238ec8e3f2b2c2a7abd167206a">libMesh::MeshBase::node_ptr_range()</a>, <a class="el" href="libmesh_8h_source.html#l00233">libMesh::pi</a>, and <a class="el" href="libmesh__common_8h_source.html#l00131">libMesh::Real</a>.</p>
<div class="fragment"><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;{</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;<span class="preprocessor">#if LIBMESH_DIM == 3</span></div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  p = -phi/180.*<a class="code" href="namespacelibMesh.html#a668b057121e7cf9d0c35207b7ab6bf38">libMesh::pi</a>;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  t = -theta/180.*<a class="code" href="namespacelibMesh.html#a668b057121e7cf9d0c35207b7ab6bf38">libMesh::pi</a>;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  s = -psi/180.*<a class="code" href="namespacelibMesh.html#a668b057121e7cf9d0c35207b7ab6bf38">libMesh::pi</a>;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> sp = std::sin(p), cp = std::cos(p);</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> st = std::sin(t), ct = std::cos(t);</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> ss = std::sin(s), cs = std::cos(s);</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;  <span class="comment">// We follow the convention described at http://mathworld.wolfram.com/EulerAngles.html</span></div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;  <span class="comment">// (equations 6-14 give the entries of the composite transformation matrix).</span></div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;  <span class="comment">// The rotations are performed sequentially about the z, x, and z axes, in that order.</span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;  <span class="comment">// A positive angle yields a counter-clockwise rotation about the axis in question.</span></div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; node : <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.node_ptr_range())</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    {</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;      <span class="keyword">const</span> Point pt = *node;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;      <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  x  = pt(0);</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;      <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  y  = pt(1);</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;      <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>  z  = pt(2);</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;      *node = Point(( cp*cs-sp*ct*ss)*x + ( sp*cs+cp*ct*ss)*y + (st*ss)*z,</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                    (-cp*ss-sp*ct*cs)*x + (-sp*ss+cp*ct*cs)*y + (st*cs)*z,</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;                    ( sp*st)*x          + (-cp*st)*y          + (ct)*z   );</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    }</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;  libmesh_error_msg(<span class="stringliteral">&quot;MeshTools::Modification::rotate() requires libMesh to be compiled with LIBMESH_DIM==3&quot;</span>);</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;}</div><div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
<div class="ttc" id="namespacelibMesh_html_aef28359fb4851abec08fc99cfbac118d"><div class="ttname"><a href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">libMesh::Real</a></div><div class="ttdeci">DIE A HORRIBLE DEATH HERE typedef LIBMESH_DEFAULT_SCALAR_TYPE Real</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00131">libmesh_common.h:131</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a668b057121e7cf9d0c35207b7ab6bf38"><div class="ttname"><a href="namespacelibMesh.html#a668b057121e7cf9d0c35207b7ab6bf38">libMesh::pi</a></div><div class="ttdeci">const Real pi</div><div class="ttdef"><b>Definition:</b> <a href="libmesh_8h_source.html#l00233">libmesh.h:233</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a48c03ebd8ce97c6c8aef8e2a05a94a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c03ebd8ce97c6c8aef8e2a05a94a16">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshTools::Modification::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td>
          <td class="paramname"><em>ys</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td>
          <td class="paramname"><em>zs</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scales the mesh. The grid points are scaled in the <code>x</code> direction by <code>xs</code>, in the <code>y</code> direction by <code>ys</code>, etc... If only <code>xs</code> is specified then the scaling is assumed uniform in all directions. </p>

<p class="definition">Definition at line <a class="el" href="mesh__modification_8C_source.html#l00234">234</a> of file <a class="el" href="mesh__modification_8C_source.html">mesh_modification.C</a>.</p>

<p class="reference">References <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a36c73b238ec8e3f2b2c2a7abd167206a">libMesh::MeshBase::node_ptr_range()</a>, and <a class="el" href="libmesh__common_8h_source.html#l00131">libMesh::Real</a>.</p>

<p class="reference">Referenced by <a class="el" href="dense__vector_8h_source.html#l00423">libMesh::DenseVector&lt; Output &gt;::operator*=()</a>, and <a class="el" href="dense__matrix_8h_source.html#l00871">libMesh::DenseMatrix&lt; Number &gt;::operator*=()</a>.</p>
<div class="fragment"><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;{</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> x_scale = xs;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;  <a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> y_scale       = ys;</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;  <a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> z_scale       = zs;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;  <span class="keywordflow">if</span> (ys == 0.)</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;    {</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;      libmesh_assert_equal_to (zs, 0.);</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;      y_scale = z_scale = x_scale;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    }</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;  <span class="comment">// Scale the x coordinate in all dimensions</span></div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; node : <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.node_ptr_range())</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;    (*node)(0) *= x_scale;</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;  <span class="comment">// Only scale the y coordinate in 2 and 3D</span></div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;  <span class="keywordflow">if</span> (LIBMESH_DIM &lt; 2)</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;    <span class="keywordflow">return</span>;</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; node : <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.node_ptr_range())</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    (*node)(1) *= y_scale;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;  <span class="comment">// Only scale the z coordinate in 3D</span></div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;  <span class="keywordflow">if</span> (LIBMESH_DIM &lt; 3)</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;    <span class="keywordflow">return</span>;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; node : <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.node_ptr_range())</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    (*node)(2) *= z_scale;</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;}</div><div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
<div class="ttc" id="namespacelibMesh_html_aef28359fb4851abec08fc99cfbac118d"><div class="ttname"><a href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">libMesh::Real</a></div><div class="ttdeci">DIE A HORRIBLE DEATH HERE typedef LIBMESH_DEFAULT_SCALAR_TYPE Real</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00131">libmesh_common.h:131</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2e817d4980341bde2cc3fba486d0d8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e817d4980341bde2cc3fba486d0d8e6">&#9670;&nbsp;</a></span>smooth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshTools::Modification::smooth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td>
          <td class="paramname"><em>power</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Smooth the mesh with a simple Laplace smoothing algorithm. The mesh is smoothed <code>n_iterations</code> times. If the parameter <code>power</code> is 0, each node is moved to the average position of the neighboring connected nodes. If <code>power</code> &gt; 0, the node positions are weighted by their distance. The positions of higher order nodes, and nodes living in refined elements, are calculated from the vertex positions of their parent nodes. Only works in 2D.</p>
<dl class="section author"><dt>Author</dt><dd>Martin Luthi (<a href="#" onclick="location.href='mai'+'lto:'+'lut'+'hi'+'@gi'+'.a'+'las'+'ka'+'.ed'+'u'; return false;">luthi<span style="display: none;">.nosp@m.</span>@gi.<span style="display: none;">.nosp@m.</span>alask<span style="display: none;">.nosp@m.</span>a.ed<span style="display: none;">.nosp@m.</span>u</a>) </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2005 </dd></dl>
<p>This implementation assumes every element "side" has only 2 nodes.</p>

<p class="definition">Definition at line <a class="el" href="mesh__modification_8C_source.html#l01106">1106</a> of file <a class="el" href="mesh__modification_8C_source.html">mesh_modification.C</a>.</p>

<p class="reference">References <a class="el" href="type__vector_8h_source.html#l00603">libMesh::TypeVector&lt; T &gt;::add()</a>, <a class="el" href="type__vector_8h_source.html#l00627">libMesh::TypeVector&lt; T &gt;::add_scaled()</a>, <a class="el" href="simple__range_8h_source.html#l00057">libMesh::as_range()</a>, <a class="el" href="classlibMesh_1_1Elem.html#a16afe15346ebf8b6dd467de99aaf6522">libMesh::Elem::build_side_ptr()</a>, <a class="el" href="classlibMesh_1_1Elem.html#a80c875428cd16109a2bc5667c6940542">libMesh::Elem::embedding_matrix()</a>, <a class="el" href="mesh__tools_8C_source.html#l00303">libMesh::MeshTools::find_boundary_nodes()</a>, <a class="el" href="dof__object_8h_source.html#l00655">libMesh::DofObject::id()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a0a4aaa9ec643866aac1330dcd22f33d8">libMesh::MeshBase::level_elements_begin()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a1d98b8c062de7f861f0eca8cc16b9b79">libMesh::MeshBase::level_elements_end()</a>, <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>, <a class="el" href="mesh__base_8C_source.html#l00126">libMesh::MeshBase::mesh_dimension()</a>, <a class="el" href="mesh__tools_8C_source.html#l00653">libMesh::MeshTools::n_levels()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a5b76b109bc6bd087c981774897aa6167">libMesh::MeshBase::n_nodes()</a>, <a class="el" href="classlibMesh_1_1Elem.html#a3a1e00b1906b0f6cf0cc1760c9a7da1f">libMesh::Elem::n_nodes()</a>, <a class="el" href="elem_8C_source.html#l02558">libMesh::Elem::n_second_order_adjacent_vertices()</a>, <a class="el" href="classlibMesh_1_1Elem.html#a27233687bfcc3f1988777fb8e2e514d1">libMesh::Elem::n_vertices()</a>, <a class="el" href="elem_8h_source.html#l02050">libMesh::Elem::neighbor_ptr()</a>, <a class="el" href="elem_8h_source.html#l02148">libMesh::Elem::node_index_range()</a>, <a class="el" href="elem_8h_source.html#l01957">libMesh::Elem::node_ptr()</a>, <a class="el" href="mesh__base_8h_source.html#l00434">libMesh::MeshBase::node_ref()</a>, <a class="el" href="type__vector_8h_source.html#l00912">libMesh::TypeVector&lt; T &gt;::norm()</a>, <a class="el" href="elem_8h_source.html#l02479">libMesh::Elem::parent()</a>, <a class="el" href="elem_8h_source.html#l01892">libMesh::Elem::point()</a>, <a class="el" href="libmesh__augment__std__namespace_8h_source.html#l00066">std::pow()</a>, <a class="el" href="libmesh__common_8h_source.html#l00131">libMesh::Real</a>, <a class="el" href="elem_8C_source.html#l02566">libMesh::Elem::second_order_adjacent_vertex()</a>, <a class="el" href="xdr__io_8C_source.html#l00050">side</a>, <a class="el" href="elem_8h_source.html#l02166">libMesh::Elem::side_index_range()</a>, <a class="el" href="mesh__tools_8C_source.html#l00233">libMesh::MeshTools::weight()</a>, and <a class="el" href="elem_8h_source.html#l02620">libMesh::Elem::which_child_am_i()</a>.</p>
<div class="fragment"><div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;{</div><div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;  libmesh_assert_equal_to (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.mesh_dimension(), 2);</div><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;</div><div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;  <span class="comment">/*</span></div><div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;<span class="comment">   * Create a quickly-searchable list of boundary nodes.</span></div><div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;<span class="comment">   */</span></div><div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;  std::unordered_set&lt;dof_id_type&gt; boundary_node_ids =</div><div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;    <a class="code" href="namespacelibMesh_1_1MeshTools.html#a0fd39d630f54c93571ee6449e8b15550">MeshTools::find_boundary_nodes</a> (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div><div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;</div><div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iter=0; iter&lt;n_iterations; iter++)</div><div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;    {</div><div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;      <span class="comment">/*</span></div><div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;<span class="comment">       * loop over the mesh refinement level</span></div><div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;<span class="comment">       */</span></div><div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacelibMesh_1_1MeshTools.html#ae15ece869d4ef3d283edb677942e8439">n_levels</a> = <a class="code" href="namespacelibMesh_1_1MeshTools.html#ae15ece869d4ef3d283edb677942e8439">MeshTools::n_levels</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>);</div><div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_level=0; refinement_level != <a class="code" href="namespacelibMesh_1_1MeshTools.html#ae15ece869d4ef3d283edb677942e8439">n_levels</a>;</div><div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;           refinement_level++)</div><div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;        {</div><div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;          <span class="comment">// initialize the storage (have to do it on every level to get empty vectors</span></div><div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;          std::vector&lt;Point&gt; new_positions;</div><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;          std::vector&lt;Real&gt;   <a class="code" href="namespacelibMesh_1_1MeshTools.html#a0701de7f01fd5eced3da4a332ff5ae51">weight</a>;</div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;          new_positions.resize(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.n_nodes());</div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;          <a class="code" href="namespacelibMesh_1_1MeshTools.html#a0701de7f01fd5eced3da4a332ff5ae51">weight</a>.resize(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.n_nodes());</div><div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;</div><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;          {</div><div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;            <span class="comment">// Loop over the elements to calculate new node positions</span></div><div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; elem : <a class="code" href="namespacelibMesh.html#a977361a82b7a9e7ad8e50ae1cae40d20">as_range</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.level_elements_begin(refinement_level),</div><div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;                                              <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.level_elements_end(refinement_level)))</div><div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;              {</div><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;                <span class="comment">/*</span></div><div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;<span class="comment">                 * We relax all nodes on level 0 first</span></div><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;<span class="comment">                 * If the element is refined (level &gt; 0), we interpolate the</span></div><div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;<span class="comment">                 * parents nodes with help of the embedding matrix</span></div><div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;<span class="comment">                 */</span></div><div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;                <span class="keywordflow">if</span> (refinement_level == 0)</div><div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;                  {</div><div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;                    <span class="keywordflow">for</span> (<span class="keyword">auto</span> s : elem-&gt;side_index_range())</div><div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;                      {</div><div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;                        <span class="comment">/*</span></div><div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;<span class="comment">                         * Only operate on sides which are on the</span></div><div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;<span class="comment">                         * boundary or for which the current element&#39;s</span></div><div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;<span class="comment">                         * id is greater than its neighbor&#39;s.</span></div><div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;<span class="comment">                         * Sides get only built once.</span></div><div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;<span class="comment">                         */</span></div><div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;                        <span class="keywordflow">if</span> ((elem-&gt;neighbor_ptr(s) != <span class="keyword">nullptr</span>) &amp;&amp;</div><div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;                            (elem-&gt;id() &gt; elem-&gt;neighbor_ptr(s)-&gt;id()))</div><div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;                          {</div><div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;                            std::unique_ptr&lt;const Elem&gt; <a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>(elem-&gt;build_side_ptr(s));</div><div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;</div><div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;                            <span class="keyword">const</span> Node &amp; node0 = <a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>-&gt;node_ref(0);</div><div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;                            <span class="keyword">const</span> Node &amp; node1 = <a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>-&gt;node_ref(1);</div><div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;</div><div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;                            <a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> node_weight = 1.;</div><div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;                            <span class="comment">// calculate the weight of the nodes</span></div><div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;                            <span class="keywordflow">if</span> (power &gt; 0)</div><div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;                              {</div><div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;                                Point diff = node0-node1;</div><div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;                                node_weight = <a class="code" href="namespacestd.html#a67fd575fd40c546de2928c8d9c6a5217">std::pow</a>(diff.norm(), power);</div><div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;                              }</div><div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;</div><div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;                            <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> id0 = node0.id(), id1 = node1.id();</div><div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;                            new_positions[id0].add_scaled( node1, node_weight );</div><div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;                            new_positions[id1].add_scaled( node0, node_weight );</div><div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;                            <a class="code" href="namespacelibMesh_1_1MeshTools.html#a0701de7f01fd5eced3da4a332ff5ae51">weight</a>[id0] += node_weight;</div><div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;                            <a class="code" href="namespacelibMesh_1_1MeshTools.html#a0701de7f01fd5eced3da4a332ff5ae51">weight</a>[id1] += node_weight;</div><div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;                          }</div><div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;                      } <span class="comment">// element neighbor loop</span></div><div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;                  }</div><div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;<span class="preprocessor">#ifdef LIBMESH_ENABLE_AMR</span></div><div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;                <span class="keywordflow">else</span>   <span class="comment">// refinement_level &gt; 0</span></div><div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;                  {</div><div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;                    <span class="comment">/*</span></div><div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;<span class="comment">                     * Find the positions of the hanging nodes of refined elements.</span></div><div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;<span class="comment">                     * We do this by calculating their position based on the parent</span></div><div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;<span class="comment">                     * (one level less refined) element, and the embedding matrix</span></div><div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;<span class="comment">                     */</span></div><div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;</div><div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;                    <span class="keyword">const</span> Elem * parent = elem-&gt;parent();</div><div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;</div><div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;                    <span class="comment">/*</span></div><div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;<span class="comment">                     * find out which child I am</span></div><div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;<span class="comment">                     */</span></div><div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;                    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = parent-&gt;which_child_am_i(elem);</div><div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;                    <span class="comment">/*</span></div><div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;<span class="comment">                     *loop over the childs (that is, the current elements) nodes</span></div><div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;<span class="comment">                     */</span></div><div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;                    <span class="keywordflow">for</span> (<span class="keyword">auto</span> nc : elem-&gt;node_index_range())</div><div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;                      {</div><div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;                        <span class="comment">/*</span></div><div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;<span class="comment">                         * the new position of the node</span></div><div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;<span class="comment">                         */</span></div><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;                        Point point;</div><div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;                        <span class="keywordflow">for</span> (<span class="keyword">auto</span> n : parent-&gt;node_index_range())</div><div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;                          {</div><div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;                            <span class="comment">/*</span></div><div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;<span class="comment">                             * The value from the embedding matrix</span></div><div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;<span class="comment">                             */</span></div><div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;                            <span class="keyword">const</span> <span class="keywordtype">float</span> em_val = parent-&gt;embedding_matrix(c,nc,n);</div><div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;</div><div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;                            <span class="keywordflow">if</span> (em_val != 0.)</div><div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;                              point.add_scaled (parent-&gt;point(n), em_val);</div><div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;                          }</div><div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;</div><div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;                        <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> <span class="keywordtype">id</span> = elem-&gt;node_ptr(nc)-&gt;id();</div><div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;                        new_positions[id] = point;</div><div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;                        <a class="code" href="namespacelibMesh_1_1MeshTools.html#a0701de7f01fd5eced3da4a332ff5ae51">weight</a>[id] = 1.;</div><div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;                      }</div><div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;                  } <span class="comment">// if element refinement_level</span></div><div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;<span class="preprocessor">#endif // #ifdef LIBMESH_ENABLE_AMR</span></div><div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;</div><div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;              } <span class="comment">// element loop</span></div><div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;</div><div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;            <span class="comment">/*</span></div><div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;<span class="comment">             * finally reposition the vertex nodes</span></div><div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;<span class="comment">             */</span></div><div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nid=0; nid&lt;<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.n_nodes(); ++nid)</div><div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;              <span class="keywordflow">if</span> (!boundary_node_ids.count(nid) &amp;&amp; <a class="code" href="namespacelibMesh_1_1MeshTools.html#a0701de7f01fd5eced3da4a332ff5ae51">weight</a>[nid] &gt; 0.)</div><div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;                <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.node_ref(nid) = new_positions[nid]/<a class="code" href="namespacelibMesh_1_1MeshTools.html#a0701de7f01fd5eced3da4a332ff5ae51">weight</a>[nid];</div><div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;          }</div><div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;</div><div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;          <span class="comment">// Now handle the additional second_order nodes by calculating</span></div><div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;          <span class="comment">// their position based on the vertex positions</span></div><div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;          <span class="comment">// we do a second loop over the level elements</span></div><div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;          <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : <a class="code" href="namespacelibMesh.html#a977361a82b7a9e7ad8e50ae1cae40d20">as_range</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.level_elements_begin(refinement_level),</div><div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;                                      <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.level_elements_end(refinement_level)))</div><div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;            {</div><div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> son_begin = elem-&gt;n_vertices();</div><div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> son_end   = elem-&gt;n_nodes();</div><div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n=son_begin; n&lt;son_end; n++)</div><div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;                {</div><div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_adjacent_vertices =</div><div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;                    elem-&gt;n_second_order_adjacent_vertices(n);</div><div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;</div><div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;                  Point point;</div><div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;n_adjacent_vertices; v++)</div><div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;                    point.add(elem-&gt;point( elem-&gt;second_order_adjacent_vertex(n,v) ));</div><div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;</div><div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;                  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> <span class="keywordtype">id</span> = elem-&gt;node_ptr(n)-&gt;id();</div><div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;                  <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.node_ref(<span class="keywordtype">id</span>) = point/n_adjacent_vertices;</div><div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;                }</div><div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;            }</div><div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;        } <span class="comment">// refinement_level loop</span></div><div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;    } <span class="comment">// end iteration</span></div><div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;}</div><div class="ttc" id="xdr__io_8C_html_a538c9c249908c84b07be8ce1400b82c9"><div class="ttname"><a href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a></div><div class="ttdeci">unsigned short int side</div><div class="ttdef"><b>Definition:</b> <a href="xdr__io_8C_source.html#l00050">xdr_io.C:50</a></div></div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_a0701de7f01fd5eced3da4a332ff5ae51"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#a0701de7f01fd5eced3da4a332ff5ae51">libMesh::MeshTools::weight</a></div><div class="ttdeci">dof_id_type weight(const MeshBase &amp;mesh, const processor_id_type pid)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00233">mesh_tools.C:233</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_ae15ece869d4ef3d283edb677942e8439"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#ae15ece869d4ef3d283edb677942e8439">libMesh::MeshTools::n_levels</a></div><div class="ttdeci">unsigned int n_levels(const MeshBase &amp;mesh)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00653">mesh_tools.C:653</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a977361a82b7a9e7ad8e50ae1cae40d20"><div class="ttname"><a href="namespacelibMesh.html#a977361a82b7a9e7ad8e50ae1cae40d20">libMesh::as_range</a></div><div class="ttdeci">SimpleRange&lt; I &gt; as_range(const std::pair&lt; I, I &gt; &amp;p)</div><div class="ttdef"><b>Definition:</b> <a href="simple__range_8h_source.html#l00057">simple_range.h:57</a></div></div>
<div class="ttc" id="namespacestd_html_a67fd575fd40c546de2928c8d9c6a5217"><div class="ttname"><a href="namespacestd.html#a67fd575fd40c546de2928c8d9c6a5217">std::pow</a></div><div class="ttdeci">double pow(double a, int b)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__augment__std__namespace_8h_source.html#l00066">libmesh_augment_std_namespace.h:66</a></div></div>
<div class="ttc" id="namespacelibMesh_html_aef28359fb4851abec08fc99cfbac118d"><div class="ttname"><a href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">libMesh::Real</a></div><div class="ttdeci">DIE A HORRIBLE DEATH HERE typedef LIBMESH_DEFAULT_SCALAR_TYPE Real</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00131">libmesh_common.h:131</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_a0fd39d630f54c93571ee6449e8b15550"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#a0fd39d630f54c93571ee6449e8b15550">libMesh::MeshTools::find_boundary_nodes</a></div><div class="ttdeci">void find_boundary_nodes(const MeshBase &amp;mesh, std::vector&lt; bool &gt; &amp;on_boundary)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00303">mesh_tools.C:303</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00064">id_types.h:64</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="add16d717dcc51dfd7d2bf671fe8e811b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add16d717dcc51dfd7d2bf671fe8e811b">&#9670;&nbsp;</a></span>translate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::MeshTools::Modification::translate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td>
          <td class="paramname"><em>xt</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td>
          <td class="paramname"><em>yt</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a>&#160;</td>
          <td class="paramname"><em>zt</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translates the mesh. The grid points are translated in the <code>x</code> direction by <code>xt</code>, in the <code>y</code> direction by <code>yt</code>, etc... </p>

<p class="definition">Definition at line <a class="el" href="mesh__modification_8C_source.html#l00167">167</a> of file <a class="el" href="mesh__modification_8C_source.html">mesh_modification.C</a>.</p>

<p class="reference">References <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>, and <a class="el" href="classlibMesh_1_1MeshBase.html#a36c73b238ec8e3f2b2c2a7abd167206a">libMesh::MeshBase::node_ptr_range()</a>.</p>
<div class="fragment"><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;{</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;  <span class="keyword">const</span> Point p(xt, yt, zt);</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; node : <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.node_ptr_range())</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    *node += p;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;}</div><div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
generated by <a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a>
</small></address>
<!-- dynamic header stuff -->
<script type="text/javascript">
$(document).ready(function(){
  $(window).on('scroll',function() {
    var scrolltop = $(this).scrollTop();
    if(scrolltop >= 215) {
      $('#fixedbar').fadeIn(250);
    }
    else if(scrolltop <= 210) {
      $('#fixedbar').fadeOut(250);
    }
  });
});
</script>
<!-- Google Analytics stuff -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-24978333-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
