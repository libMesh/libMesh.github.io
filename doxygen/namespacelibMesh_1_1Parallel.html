<!-- HTML header for doxygen -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libMesh: libMesh::Parallel Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="../styles.css" rel="stylesheet" type="text/css" />
<link href="doxygen_stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <nav id="fixedbar">
    <ul id="fixednav">
      <li><a href="../index.html">Home</a></li>
      <li><a href="../support.html">About Us</a></li>
      <li><a href="../publications.html">Publications</a></li>
      <li><a href="../developers.html">Developers</a></li>
      <li><a href="../installation.html">Installation</a></li>
      <li><a href="../examples.html">Examples</a></li>
      <li><a href="../doxygen/index.html">Documentation</a></li>
    </ul>
  </nav>
  <div id="w">
    <header id="logo"><a href="index.html"><span id="logobg">SomeWebsiteLogo</span></a></header>
    <nav id="navigation">
      <ul>
        <li><a href="../index.html">Home</a></li>
        <li><a href="../support.html">About Us</a></li>
        <li><a href="../publications.html">Publications</a></li>
        <li><a href="../developers.html">Developers</a></li>
        <li><a href="../installation.html">Installation</a></li>
        <li><a href="../examples.html">Examples</a></li>
        <li><a href="../doxygen/index.html">Documentation</a></li>
      </ul>
    </nav>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- <\!--BEGIN TITLEAREA-\-> -->
<!-- <div id="titlearea"> -->
<!-- <table cellspacing="0" cellpadding="0"> -->
<!--  <tbody> -->
<!--  <tr style="height: 56px;"> -->
<!--   <\!--BEGIN PROJECT_LOGO-\-> -->
<!--   <td id="projectlogo"><img alt="Logo" src=""/></td> -->
<!--   <\!--END PROJECT_LOGO-\-> -->
<!--   <\!--BEGIN PROJECT_NAME-\-> -->
<!--   <td style="padding-left: 0.5em;"> -->
<!--    <div id="projectname">libMesh -->
<!--    <\!--BEGIN PROJECT_NUMBER-\->&#160;<span id="projectnumber"></span><\!--END PROJECT_NUMBER-\-> -->
<!--    </div> -->
<!--    <\!--BEGIN PROJECT_BRIEF-\-><div id="projectbrief"></div><\!--END PROJECT_BRIEF-\-> -->
<!--   </td> -->
<!--   <\!--END PROJECT_NAME-\-> -->
<!--   <\!--BEGIN !PROJECT_NAME-\-> -->
<!--    <\!--BEGIN PROJECT_BRIEF-\-> -->
<!--     <td style="padding-left: 0.5em;"> -->
<!--     <div id="projectbrief"></div> -->
<!--     </td> -->
<!--    <\!--END PROJECT_BRIEF-\-> -->
<!--   <\!--END !PROJECT_NAME-\-> -->
<!--   <\!--BEGIN DISABLE_INDEX-\-> -->
<!--    <\!--BEGIN SEARCHENGINE-\-> -->
<!--    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td> -->
<!--    <\!--END SEARCHENGINE-\-> -->
<!--   <\!--END DISABLE_INDEX-\-> -->
<!--  </tr> -->
<!--  </tbody> -->
<!-- </table> -->
<!-- </div> -->
<!-- <\!--END TITLEAREA-\-> -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibMesh.html">libMesh</a></li><li class="navelem"><a class="el" href="namespacelibMesh_1_1Parallel.html">Parallel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">libMesh::Parallel Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacelibMesh_1_1Parallel_1_1Utils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel_1_1Utils.html">Utils</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibMesh_1_1Parallel_1_1Attributes.html">Attributes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1BinSorter.html">BinSorter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacelibMesh_1_1Parallel.html">Parallel</a> bin sorting object.  <a href="classlibMesh_1_1Parallel_1_1BinSorter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibMesh_1_1Parallel_1_1BuildStandardTypeVector.html">BuildStandardTypeVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibMesh_1_1Parallel_1_1BuildStandardTypeVector_3_010_01_4.html">BuildStandardTypeVector&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibMesh_1_1Parallel_1_1data__type.html">data_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1DataPlusInt.html">DataPlusInt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1DataType.html">DataType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibMesh_1_1Parallel_1_1FillDisplacementArray.html">FillDisplacementArray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibMesh_1_1Parallel_1_1FillDisplacementArray_3_010_01_4.html">FillDisplacementArray&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1Histogram.html">Histogram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used in conjunction with a <a class="el" href="classlibMesh_1_1Parallel_1_1BinSorter.html" title="Parallel bin sorting object. ">BinSorter</a> for parallel sorting.  <a href="classlibMesh_1_1Parallel_1_1Histogram.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1MessageTag.html">MessageTag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1OpFunction.html">OpFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1OpFunction_3_01Point_01_4.html">OpFunction&lt; Point &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1OpFunction_3_01TypeVector_3_01T_01_4_01_4.html">OpFunction&lt; TypeVector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1OpFunction_3_01VectorValue_3_01T_01_4_01_4.html">OpFunction&lt; VectorValue&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibMesh_1_1Parallel_1_1opfunction__dependent__false.html">opfunction_dependent_false</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1Packing.html">Packing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1Packing_3_01const_01Elem_01_5_01_4.html">Packing&lt; const Elem * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1Packing_3_01const_01Node_01_5_01_4.html">Packing&lt; const Node * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1Packing_3_01Elem_01_5_01_4.html">Packing&lt; Elem * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1Packing_3_01Node_01_5_01_4.html">Packing&lt; Node * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibMesh_1_1Parallel_1_1PostWaitCopyBuffer.html">PostWaitCopyBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibMesh_1_1Parallel_1_1PostWaitDeleteBuffer.html">PostWaitDeleteBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibMesh_1_1Parallel_1_1PostWaitDereferenceSharedPtr.html">PostWaitDereferenceSharedPtr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibMesh_1_1Parallel_1_1PostWaitDereferenceTag.html">PostWaitDereferenceTag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibMesh_1_1Parallel_1_1PostWaitFreeBuffer.html">PostWaitFreeBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibMesh_1_1Parallel_1_1PostWaitUnpackBuffer.html">PostWaitUnpackBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibMesh_1_1Parallel_1_1PostWaitWork.html">PostWaitWork</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1Request.html">Request</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibMesh_1_1Parallel_1_1request.html">request</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1Sort.html">Sort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object for performing parallel sorts using MPI.  <a href="classlibMesh_1_1Parallel_1_1Sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1StandardType.html">StandardType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1StandardType_3_01Hilbert_1_1HilbertIndices_01_4.html">StandardType&lt; Hilbert::HilbertIndices &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1StandardType_3_01Point_01_4.html">StandardType&lt; Point &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1StandardType_3_01std_1_1complex_3_01T_01_4_01_4.html">StandardType&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1StandardType_3_01std_1_1pair_3_01T1_00_01T2_01_4_01_4.html">StandardType&lt; std::pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1StandardType_3_01std_1_1tuple_3_01Types_8_8_8_01_4_01_4.html">StandardType&lt; std::tuple&lt; Types... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1StandardType_3_01TensorValue_3_01T_01_4_01_4.html">StandardType&lt; TensorValue&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1StandardType_3_01TypeTensor_3_01T_01_4_01_4.html">StandardType&lt; TypeTensor&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1StandardType_3_01TypeVector_3_01T_01_4_01_4.html">StandardType&lt; TypeVector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1StandardType_3_01VectorValue_3_01T_01_4_01_4.html">StandardType&lt; VectorValue&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibMesh_1_1Parallel_1_1standardtype__dependent__false.html">standardtype_dependent_false</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1Status.html">Status</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibMesh_1_1Parallel_1_1status.html">status</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibMesh_1_1Parallel_1_1SyncEverything.html">SyncEverything</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1Parallel_1_1TypeVectorOpFunction.html">TypeVectorOpFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2cdfa6faf50f37586a86c57926bda43e"><td class="memItemLeft" align="right" valign="top">typedef MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">communicator</a></td></tr>
<tr class="separator:a2cdfa6faf50f37586a86c57926bda43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad746570bb06f6070f3daf58cfc3cb77f"><td class="memItemLeft" align="right" valign="top">typedef MPI_Datatype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#ad746570bb06f6070f3daf58cfc3cb77f">data_type</a></td></tr>
<tr class="separator:ad746570bb06f6070f3daf58cfc3cb77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefbe7c94fa1895557e56fdc001710b16"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; Hilbert::HilbertIndices, <a class="el" href="namespacelibMesh.html#a0c8246ed396fb6017ccc59711d9b9f7e">unique_id_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">DofObjectKey</a></td></tr>
<tr class="separator:aefbe7c94fa1895557e56fdc001710b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf28cfb3d6fefc535e83fb4b2698276"><td class="memItemLeft" align="right" valign="top">typedef MPI_Request&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a4cf28cfb3d6fefc535e83fb4b2698276">request</a></td></tr>
<tr class="separator:a4cf28cfb3d6fefc535e83fb4b2698276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ff351bea1937bbde5a1af3160b4616"><td class="memItemLeft" align="right" valign="top">typedef MPI_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a08ff351bea1937bbde5a1af3160b4616">status</a></td></tr>
<tr class="separator:a08ff351bea1937bbde5a1af3160b4616"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aea5278a91928fa4f33b74aa0786f3592"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#aea5278a91928fa4f33b74aa0786f3592">wait</a> (std::vector&lt; <a class="el" href="classlibMesh_1_1Parallel_1_1Request.html">Request</a> &gt; &amp;r)</td></tr>
<tr class="separator:aea5278a91928fa4f33b74aa0786f3592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff47382fb119efc31a05639bd54f8ed6"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#aff47382fb119efc31a05639bd54f8ed6">waitany</a> (std::vector&lt; <a class="el" href="classlibMesh_1_1Parallel_1_1Request.html">Request</a> &gt; &amp;r)</td></tr>
<tr class="separator:aff47382fb119efc31a05639bd54f8ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8aa285b35cbf64b12a2f50d65f99ebc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#ac8aa285b35cbf64b12a2f50d65f99ebc">LIBMESH_INT_TYPE</a> (char)</td></tr>
<tr class="separator:ac8aa285b35cbf64b12a2f50d65f99ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeccc2a9b1f5e683c6e7783bb28b9104"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#aeeccc2a9b1f5e683c6e7783bb28b9104">LIBMESH_INT_TYPE</a> (signed char)</td></tr>
<tr class="separator:aeeccc2a9b1f5e683c6e7783bb28b9104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf16ebf7d9f546dc0ec699c2a965bfa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#aabf16ebf7d9f546dc0ec699c2a965bfa">LIBMESH_INT_TYPE</a> (unsigned char)</td></tr>
<tr class="separator:aabf16ebf7d9f546dc0ec699c2a965bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f687aedee05a68ae331324b2caeb8bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a5f687aedee05a68ae331324b2caeb8bf">LIBMESH_INT_TYPE</a> (short int)</td></tr>
<tr class="separator:a5f687aedee05a68ae331324b2caeb8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957361b7a122e44397d5e06f39ba185d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a957361b7a122e44397d5e06f39ba185d">LIBMESH_INT_TYPE</a> (unsigned short int)</td></tr>
<tr class="separator:a957361b7a122e44397d5e06f39ba185d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6b1d70a4215246b9c78a74a56924b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a2e6b1d70a4215246b9c78a74a56924b6">LIBMESH_INT_TYPE</a> (int)</td></tr>
<tr class="separator:a2e6b1d70a4215246b9c78a74a56924b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9138c7260b575dfdc3cd12433cb45389"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a9138c7260b575dfdc3cd12433cb45389">LIBMESH_INT_TYPE</a> (long)</td></tr>
<tr class="separator:a9138c7260b575dfdc3cd12433cb45389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6adffd9d06aaddf05bc3ec13ccd6aa9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#aa6adffd9d06aaddf05bc3ec13ccd6aa9">LIBMESH_INT_TYPE</a> (unsigned long long)</td></tr>
<tr class="separator:aa6adffd9d06aaddf05bc3ec13ccd6aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e7c3450394d89f5027b93ef4dc9740"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a93e7c3450394d89f5027b93ef4dc9740">LIBMESH_FLOAT_TYPE</a> (float)</td></tr>
<tr class="separator:a93e7c3450394d89f5027b93ef4dc9740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f2e9e505db0a5dce697a0e5f757fcf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#ab6f2e9e505db0a5dce697a0e5f757fcf">LIBMESH_FLOAT_TYPE</a> (double)</td></tr>
<tr class="separator:ab6f2e9e505db0a5dce697a0e5f757fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0329d8ad0d59334c0a79e62f59fa1c76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a0329d8ad0d59334c0a79e62f59fa1c76">LIBMESH_FLOAT_TYPE</a> (long double)</td></tr>
<tr class="separator:a0329d8ad0d59334c0a79e62f59fa1c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d38ea0b5cab9d3bae0e540aace3e999"><td class="memTemplParams" colspan="2">template&lt;typename T , typename C , typename A &gt; </td></tr>
<tr class="memitem:a2d38ea0b5cab9d3bae0e540aace3e999"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a2d38ea0b5cab9d3bae0e540aace3e999">LIBMESH_CONTAINER_TYPE</a> (std::set&lt; T LIBMESH_ATTRIBUTES_COMMA C LIBMESH_ATTRIBUTES_COMMA <a class="el" href="petscdmlibmeshimpl_8C.html#a015846b6188ce15e08cd94c74a9df1a3">A</a> &gt;)</td></tr>
<tr class="separator:a2d38ea0b5cab9d3bae0e540aace3e999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e798af988febd8807be449bc835113"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:ae2e798af988febd8807be449bc835113"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#ae2e798af988febd8807be449bc835113">LIBMESH_CONTAINER_TYPE</a> (std::vector&lt; T LIBMESH_ATTRIBUTES_COMMA <a class="el" href="petscdmlibmeshimpl_8C.html#a015846b6188ce15e08cd94c74a9df1a3">A</a> &gt;)</td></tr>
<tr class="separator:ae2e798af988febd8807be449bc835113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4779d9ce36f287fffefb041805efde1f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a4779d9ce36f287fffefb041805efde1f">LIBMESH_PARALLEL_INTEGER_OPS</a> (char)</td></tr>
<tr class="separator:a4779d9ce36f287fffefb041805efde1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2feb9f4a16d2fb40534ad239c897a3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#ab2feb9f4a16d2fb40534ad239c897a3f">LIBMESH_PARALLEL_INTEGER_OPS</a> (signed char)</td></tr>
<tr class="separator:ab2feb9f4a16d2fb40534ad239c897a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47801953ca83f05dee11abb0adf134c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#ae47801953ca83f05dee11abb0adf134c">LIBMESH_PARALLEL_INTEGER_OPS</a> (unsigned char)</td></tr>
<tr class="separator:ae47801953ca83f05dee11abb0adf134c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bed5fe4b7daf35de0c86e623cb2969"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#af0bed5fe4b7daf35de0c86e623cb2969">LIBMESH_PARALLEL_INTEGER_OPS</a> (short int)</td></tr>
<tr class="separator:af0bed5fe4b7daf35de0c86e623cb2969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d65ed6e7adae8d532cd16cf0a261c67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a7d65ed6e7adae8d532cd16cf0a261c67">LIBMESH_PARALLEL_INTEGER_OPS</a> (unsigned short int)</td></tr>
<tr class="separator:a7d65ed6e7adae8d532cd16cf0a261c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85be697082f5446c0abb91acb19dfaf5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a85be697082f5446c0abb91acb19dfaf5">LIBMESH_PARALLEL_INTEGER_OPS</a> (int)</td></tr>
<tr class="separator:a85be697082f5446c0abb91acb19dfaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9476a7115c67f46f4b9a3d8c212c727"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#ae9476a7115c67f46f4b9a3d8c212c727">LIBMESH_PARALLEL_INTEGER_OPS</a> (long)</td></tr>
<tr class="separator:ae9476a7115c67f46f4b9a3d8c212c727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef8f05a8d6c1e8cf7483f4a1c3fdcbd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a6ef8f05a8d6c1e8cf7483f4a1c3fdcbd">LIBMESH_PARALLEL_INTEGER_OPS</a> (unsigned long long)</td></tr>
<tr class="separator:a6ef8f05a8d6c1e8cf7483f4a1c3fdcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4869bd736c7bfe88fea240e940788bd0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a4869bd736c7bfe88fea240e940788bd0">LIBMESH_PARALLEL_FLOAT_OPS</a> (float)</td></tr>
<tr class="separator:a4869bd736c7bfe88fea240e940788bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af070a738fef21908708eec52898760d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#af070a738fef21908708eec52898760d1">LIBMESH_PARALLEL_FLOAT_OPS</a> (double)</td></tr>
<tr class="separator:af070a738fef21908708eec52898760d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c96360a1bc5e03c4890b0ef40452727"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a0c96360a1bc5e03c4890b0ef40452727">LIBMESH_PARALLEL_FLOAT_OPS</a> (long double)</td></tr>
<tr class="separator:a0c96360a1bc5e03c4890b0ef40452727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0febfa97ceea582f719f62c437d146"><td class="memTemplParams" colspan="2">template&lt;typename Context , typename buffertype , typename OutputIter , typename T &gt; </td></tr>
<tr class="memitem:a6d0febfa97ceea582f719f62c437d146"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a6d0febfa97ceea582f719f62c437d146">unpack_range</a> (const typename std::vector&lt; buffertype &gt; &amp;buffer, Context *context, OutputIter <a class="el" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">out</a>, const T *output_type)</td></tr>
<tr class="separator:a6d0febfa97ceea582f719f62c437d146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbff8955d0081e65a953e8076d7bfe94"><td class="memTemplParams" colspan="2">template&lt;typename Context , typename buffertype , typename Iter &gt; </td></tr>
<tr class="memitem:abbff8955d0081e65a953e8076d7bfe94"><td class="memTemplItemLeft" align="right" valign="top">Iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#abbff8955d0081e65a953e8076d7bfe94">pack_range</a> (const Context *context, Iter range_begin, const Iter range_end, typename std::vector&lt; buffertype &gt; &amp;buffer, std::size_t approx_buffer_size=1000000)</td></tr>
<tr class="separator:abbff8955d0081e65a953e8076d7bfe94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac96c8ed3881c25d394f6e65eabf6b2"><td class="memTemplParams" colspan="2">template&lt;typename Context , typename Iter &gt; </td></tr>
<tr class="memitem:a5ac96c8ed3881c25d394f6e65eabf6b2"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a5ac96c8ed3881c25d394f6e65eabf6b2">packed_range_size</a> (const Context *context, Iter range_begin, const Iter range_end)</td></tr>
<tr class="separator:a5ac96c8ed3881c25d394f6e65eabf6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43a801737716802b40c784a6a13ad63"><td class="memTemplParams" colspan="2">template&lt;typename Context , typename buffertype , typename OutputIter , typename T &gt; </td></tr>
<tr class="memitem:aa43a801737716802b40c784a6a13ad63"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#aa43a801737716802b40c784a6a13ad63">unpack_range</a> (const std::vector&lt; buffertype &gt; &amp;buffer, Context *context, OutputIter out_iter, const T *)</td></tr>
<tr class="separator:aa43a801737716802b40c784a6a13ad63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc7813882010b4a195a37dd579f1d03"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename DofObjType , typename SyncFunctor &gt; </td></tr>
<tr class="memitem:a7dc7813882010b4a195a37dd579f1d03"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a7dc7813882010b4a195a37dd579f1d03">sync_dofobject_data_by_xyz</a> (const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;comm, const Iterator &amp;range_begin, const Iterator &amp;range_end, <a class="el" href="classlibMesh_1_1LocationMap.html">LocationMap</a>&lt; DofObjType &gt; *location_map, SyncFunctor &amp;sync)</td></tr>
<tr class="separator:a7dc7813882010b4a195a37dd579f1d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d4f06bb34625465942e6b8d10f135e"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename SyncFunctor &gt; </td></tr>
<tr class="memitem:ac7d4f06bb34625465942e6b8d10f135e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#ac7d4f06bb34625465942e6b8d10f135e">sync_dofobject_data_by_id</a> (const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;comm, const Iterator &amp;range_begin, const Iterator &amp;range_end, SyncFunctor &amp;sync)</td></tr>
<tr class="separator:ac7d4f06bb34625465942e6b8d10f135e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ccf736a24de62226fbaf331153735c"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename DofObjectCheckFunctor , typename SyncFunctor &gt; </td></tr>
<tr class="memitem:ab0ccf736a24de62226fbaf331153735c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#ab0ccf736a24de62226fbaf331153735c">sync_dofobject_data_by_id</a> (const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;comm, const Iterator &amp;range_begin, const Iterator &amp;range_end, const DofObjectCheckFunctor &amp;dofobj_check, SyncFunctor &amp;sync)</td></tr>
<tr class="separator:ab0ccf736a24de62226fbaf331153735c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c79f0c66ce48d4b3801a77b139df3b"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename SyncFunctor &gt; </td></tr>
<tr class="memitem:a29c79f0c66ce48d4b3801a77b139df3b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a29c79f0c66ce48d4b3801a77b139df3b">sync_element_data_by_parent_id</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, const Iterator &amp;range_begin, const Iterator &amp;range_end, SyncFunctor &amp;sync)</td></tr>
<tr class="separator:a29c79f0c66ce48d4b3801a77b139df3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690437fd4e60ad2cedf64948c3f21519"><td class="memTemplParams" colspan="2">template&lt;typename ElemCheckFunctor , typename NodeCheckFunctor , typename SyncFunctor &gt; </td></tr>
<tr class="memitem:a690437fd4e60ad2cedf64948c3f21519"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a690437fd4e60ad2cedf64948c3f21519">sync_node_data_by_element_id_once</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, const <a class="el" href="structlibMesh_1_1MeshBase_1_1const__element__iterator.html">MeshBase::const_element_iterator</a> &amp;range_begin, const <a class="el" href="structlibMesh_1_1MeshBase_1_1const__element__iterator.html">MeshBase::const_element_iterator</a> &amp;range_end, const ElemCheckFunctor &amp;elem_check, const NodeCheckFunctor &amp;node_check, SyncFunctor &amp;sync)</td></tr>
<tr class="separator:a690437fd4e60ad2cedf64948c3f21519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a93cd4ce160f40c758f96e2cadbe25"><td class="memTemplParams" colspan="2">template&lt;typename ElemCheckFunctor , typename NodeCheckFunctor , typename SyncFunctor &gt; </td></tr>
<tr class="memitem:a78a93cd4ce160f40c758f96e2cadbe25"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a78a93cd4ce160f40c758f96e2cadbe25">sync_node_data_by_element_id</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, const <a class="el" href="structlibMesh_1_1MeshBase_1_1const__element__iterator.html">MeshBase::const_element_iterator</a> &amp;range_begin, const <a class="el" href="structlibMesh_1_1MeshBase_1_1const__element__iterator.html">MeshBase::const_element_iterator</a> &amp;range_end, const ElemCheckFunctor &amp;elem_check, const NodeCheckFunctor &amp;node_check, SyncFunctor &amp;sync)</td></tr>
<tr class="separator:a78a93cd4ce160f40c758f96e2cadbe25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab412d3606d51e5df080eab5795351901"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename DofObjType , typename SyncFunctor &gt; </td></tr>
<tr class="memitem:ab412d3606d51e5df080eab5795351901"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#ab412d3606d51e5df080eab5795351901">sync_dofobject_data_by_xyz</a> (const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;comm, const Iterator &amp;range_begin, const Iterator &amp;range_end, <a class="el" href="classlibMesh_1_1LocationMap.html">LocationMap</a>&lt; DofObjType &gt; &amp;location_map, SyncFunctor &amp;sync)</td></tr>
<tr class="separator:ab412d3606d51e5df080eab5795351901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7228e749d20793b8d57858105e3aea43"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7228e749d20793b8d57858105e3aea43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlibMesh_1_1Parallel_1_1data__type.html">data_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a7228e749d20793b8d57858105e3aea43">dataplusint_type</a> ()</td></tr>
<tr class="separator:a7228e749d20793b8d57858105e3aea43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26377566e6a1e104a0a422b729bdbcb"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af26377566e6a1e104a0a422b729bdbcb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlibMesh_1_1Parallel_1_1data__type.html">data_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#af26377566e6a1e104a0a422b729bdbcb">dataplusint_type&lt; short int &gt;</a> ()</td></tr>
<tr class="separator:af26377566e6a1e104a0a422b729bdbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880ceb4da5c93366b56ca941b1a53762"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a880ceb4da5c93366b56ca941b1a53762"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlibMesh_1_1Parallel_1_1data__type.html">data_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a880ceb4da5c93366b56ca941b1a53762">dataplusint_type&lt; int &gt;</a> ()</td></tr>
<tr class="separator:a880ceb4da5c93366b56ca941b1a53762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6924048a1af82d47ce0582d20059623"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ae6924048a1af82d47ce0582d20059623"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlibMesh_1_1Parallel_1_1data__type.html">data_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#ae6924048a1af82d47ce0582d20059623">dataplusint_type&lt; long &gt;</a> ()</td></tr>
<tr class="separator:ae6924048a1af82d47ce0582d20059623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af870d7629b079291ef0e6f5c32bee7e4"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af870d7629b079291ef0e6f5c32bee7e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlibMesh_1_1Parallel_1_1data__type.html">data_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#af870d7629b079291ef0e6f5c32bee7e4">dataplusint_type&lt; float &gt;</a> ()</td></tr>
<tr class="separator:af870d7629b079291ef0e6f5c32bee7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fed53973e584f967f78277b4f2337e0"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a1fed53973e584f967f78277b4f2337e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlibMesh_1_1Parallel_1_1data__type.html">data_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a1fed53973e584f967f78277b4f2337e0">dataplusint_type&lt; double &gt;</a> ()</td></tr>
<tr class="separator:a1fed53973e584f967f78277b4f2337e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f953b15c8f57983385cddd6bbf8311"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac0f953b15c8f57983385cddd6bbf8311"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structlibMesh_1_1Parallel_1_1data__type.html">data_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#ac0f953b15c8f57983385cddd6bbf8311">dataplusint_type&lt; long double &gt;</a> ()</td></tr>
<tr class="separator:ac0f953b15c8f57983385cddd6bbf8311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2840c544bef5845992c918f1cb4669f1"><td class="memTemplParams" colspan="2">template&lt;typename MapToVectors , typename RequestContainer , typename ActionFunctor &gt; </td></tr>
<tr class="memitem:a2840c544bef5845992c918f1cb4669f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a2840c544bef5845992c918f1cb4669f1">push_parallel_vector_data</a> (const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;comm, const MapToVectors &amp;<a class="el" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>, RequestContainer &amp;reqs, ActionFunctor &amp;act_on_data)</td></tr>
<tr class="separator:a2840c544bef5845992c918f1cb4669f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e13ce6e3b8d973e2e2d947a57942588"><td class="memTemplParams" colspan="2">template&lt;typename MapToVectors , typename ActionFunctor &gt; </td></tr>
<tr class="memitem:a9e13ce6e3b8d973e2e2d947a57942588"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a9e13ce6e3b8d973e2e2d947a57942588">push_parallel_vector_data</a> (const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;comm, const MapToVectors &amp;<a class="el" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>, ActionFunctor &amp;act_on_data)</td></tr>
<tr class="separator:a9e13ce6e3b8d973e2e2d947a57942588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21797734483c801c09fa26822455d989"><td class="memTemplParams" colspan="2">template&lt;typename datum , typename MapToVectors , typename RequestContainer , typename GatherFunctor , typename ActionFunctor &gt; </td></tr>
<tr class="memitem:a21797734483c801c09fa26822455d989"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a21797734483c801c09fa26822455d989">pull_parallel_vector_data</a> (const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;comm, const MapToVectors &amp;queries, RequestContainer &amp;reqs, GatherFunctor &amp;gather_data, ActionFunctor &amp;act_on_data, const datum *example)</td></tr>
<tr class="separator:a21797734483c801c09fa26822455d989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b8c5827b01ae110fdbf3ea145350af"><td class="memTemplParams" colspan="2">template&lt;typename datum , typename MapToVectors , typename GatherFunctor , typename ActionFunctor &gt; </td></tr>
<tr class="memitem:a49b8c5827b01ae110fdbf3ea145350af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a49b8c5827b01ae110fdbf3ea145350af">pull_parallel_vector_data</a> (const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;comm, const MapToVectors &amp;queries, GatherFunctor &amp;gather_data, ActionFunctor &amp;act_on_data, const datum *example)</td></tr>
<tr class="separator:a49b8c5827b01ae110fdbf3ea145350af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642969e3f24f42d7a2b02901c8690289"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, typename, typename ... &gt; class MapType, typename KeyType , typename ValueType , typename A1 , typename A2 , typename ... ExtraTypes, typename RequestContainer , typename ActionFunctor &gt; </td></tr>
<tr class="memitem:a642969e3f24f42d7a2b02901c8690289"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a642969e3f24f42d7a2b02901c8690289">push_parallel_vector_data</a> (const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;comm, const MapType&lt; <a class="el" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a>, std::vector&lt; std::vector&lt; ValueType, A1 &gt;, A2 &gt;, ExtraTypes... &gt; &amp;<a class="el" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>, RequestContainer &amp;reqs, ActionFunctor &amp;act_on_data)</td></tr>
<tr class="separator:a642969e3f24f42d7a2b02901c8690289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a387d9373b4f9fba21b87171d95ae62"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, typename, typename ... &gt; class MapType, typename KeyType , typename ValueType , typename A1 , typename A2 , typename ... ExtraTypes, typename ActionFunctor &gt; </td></tr>
<tr class="memitem:a6a387d9373b4f9fba21b87171d95ae62"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a6a387d9373b4f9fba21b87171d95ae62">push_parallel_vector_data</a> (const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;comm, const MapType&lt; <a class="el" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a>, std::vector&lt; std::vector&lt; ValueType, A1 &gt;, A2 &gt;, ExtraTypes... &gt; &amp;<a class="el" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>, ActionFunctor &amp;act_on_data)</td></tr>
<tr class="separator:a6a387d9373b4f9fba21b87171d95ae62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd835a87c6e9122d141633bf748bd2f"><td class="memTemplParams" colspan="2">template&lt;typename datum , typename A , typename MapToVectors , typename RequestContainer , typename GatherFunctor , typename ActionFunctor &gt; </td></tr>
<tr class="memitem:acbd835a87c6e9122d141633bf748bd2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#acbd835a87c6e9122d141633bf748bd2f">pull_parallel_vector_data</a> (const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;comm, const MapToVectors &amp;queries, RequestContainer &amp;reqs, GatherFunctor &amp;gather_data, ActionFunctor &amp;act_on_data, const std::vector&lt; datum, <a class="el" href="petscdmlibmeshimpl_8C.html#a015846b6188ce15e08cd94c74a9df1a3">A</a> &gt; *example)</td></tr>
<tr class="separator:acbd835a87c6e9122d141633bf748bd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed5f1c09ede99139461a86c8aff33ac"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, typename, typename ... &gt; class MapType, typename ValueType , typename A1 , typename A2 , typename ... ExtraTypes, typename RequestContainer , typename ActionFunctor &gt; </td></tr>
<tr class="memitem:a9ed5f1c09ede99139461a86c8aff33ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a9ed5f1c09ede99139461a86c8aff33ac">push_parallel_vector_data</a> (const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;comm, const MapType&lt; <a class="el" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a>, std::vector&lt; std::vector&lt; ValueType, A1 &gt;, A2 &gt;, ExtraTypes... &gt; &amp;<a class="el" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>, RequestContainer &amp;reqs, ActionFunctor &amp;act_on_data)</td></tr>
<tr class="separator:a9ed5f1c09ede99139461a86c8aff33ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9703aa21aa121441db66d7ebdfa8a7"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, typename, typename ... &gt; class MapType, typename ValueType , typename A1 , typename A2 , typename ... ExtraTypes, typename ActionFunctor &gt; </td></tr>
<tr class="memitem:aef9703aa21aa121441db66d7ebdfa8a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#aef9703aa21aa121441db66d7ebdfa8a7">push_parallel_vector_data</a> (const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;comm, const MapType&lt; <a class="el" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a>, std::vector&lt; std::vector&lt; ValueType, A1 &gt;, A2 &gt;, ExtraTypes... &gt; &amp;<a class="el" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>, ActionFunctor &amp;act_on_data)</td></tr>
<tr class="separator:aef9703aa21aa121441db66d7ebdfa8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94da485af333624e0167bb84b9adaf84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1Parallel_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a94da485af333624e0167bb84b9adaf84">wait</a> (<a class="el" href="classlibMesh_1_1Parallel_1_1Request.html">Request</a> &amp;r)</td></tr>
<tr class="separator:a94da485af333624e0167bb84b9adaf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34082a9080937b461e2a804e80dd6693"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a34082a9080937b461e2a804e80dd6693">LIBMESH_STANDARD_TYPE</a> (char, MPI_CHAR)</td></tr>
<tr class="separator:a34082a9080937b461e2a804e80dd6693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4860f42c2c3c03f94dbafbab147ea0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#ade4860f42c2c3c03f94dbafbab147ea0">LIBMESH_STANDARD_TYPE</a> (signed char, MPI_SIGNED_CHAR)</td></tr>
<tr class="separator:ade4860f42c2c3c03f94dbafbab147ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0404c7aa3609500b6d8c18710f2527e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#af0404c7aa3609500b6d8c18710f2527e">LIBMESH_STANDARD_TYPE</a> (unsigned char, MPI_UNSIGNED_CHAR)</td></tr>
<tr class="separator:af0404c7aa3609500b6d8c18710f2527e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab512f183275eed4287667786b900395b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#ab512f183275eed4287667786b900395b">LIBMESH_STANDARD_TYPE</a> (short int, MPI_SHORT)</td></tr>
<tr class="separator:ab512f183275eed4287667786b900395b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcde59eea2a499af418a0c8a896b8a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a1dcde59eea2a499af418a0c8a896b8a4">LIBMESH_STANDARD_TYPE</a> (unsigned short int, MPI_UNSIGNED_SHORT)</td></tr>
<tr class="separator:a1dcde59eea2a499af418a0c8a896b8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac2370de3f73920c820b68696c6daa0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a8ac2370de3f73920c820b68696c6daa0">LIBMESH_STANDARD_TYPE</a> (int, MPI_INT)</td></tr>
<tr class="separator:a8ac2370de3f73920c820b68696c6daa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43375c35ee1d88dd4d3da4b5c0f5abde"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a43375c35ee1d88dd4d3da4b5c0f5abde">LIBMESH_STANDARD_TYPE</a> (unsigned int, MPI_UNSIGNED)</td></tr>
<tr class="separator:a43375c35ee1d88dd4d3da4b5c0f5abde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f9cbfcfa5b5a9176d0ea57f732ecfb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a00f9cbfcfa5b5a9176d0ea57f732ecfb">LIBMESH_STANDARD_TYPE</a> (long, MPI_LONG)</td></tr>
<tr class="separator:a00f9cbfcfa5b5a9176d0ea57f732ecfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90e70b6571e38180131dd206342ffdd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#ab90e70b6571e38180131dd206342ffdd">LIBMESH_STANDARD_TYPE</a> (long long, MPI_LONG_LONG_INT)</td></tr>
<tr class="separator:ab90e70b6571e38180131dd206342ffdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0fb9da05ad9da6d0ef409117c08e882"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#ad0fb9da05ad9da6d0ef409117c08e882">LIBMESH_STANDARD_TYPE</a> (unsigned long, MPI_UNSIGNED_LONG)</td></tr>
<tr class="separator:ad0fb9da05ad9da6d0ef409117c08e882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96dfecfedfa2ed0acac08c0eac000468"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a96dfecfedfa2ed0acac08c0eac000468">LIBMESH_STANDARD_TYPE</a> (unsigned long long, MPI_UNSIGNED_LONG_LONG)</td></tr>
<tr class="separator:a96dfecfedfa2ed0acac08c0eac000468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ed7c90de6436c20acbbdf1dc6311b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#ac7ed7c90de6436c20acbbdf1dc6311b2">LIBMESH_STANDARD_TYPE</a> (float, MPI_FLOAT)</td></tr>
<tr class="separator:ac7ed7c90de6436c20acbbdf1dc6311b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e1eeb5923fc0aee13b8ccd23bbaa85"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#ae4e1eeb5923fc0aee13b8ccd23bbaa85">LIBMESH_STANDARD_TYPE</a> (double, MPI_DOUBLE)</td></tr>
<tr class="separator:ae4e1eeb5923fc0aee13b8ccd23bbaa85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99d9872a6acfd676e836e6773978995"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#af99d9872a6acfd676e836e6773978995">LIBMESH_STANDARD_TYPE</a> (long double, MPI_LONG_DOUBLE)</td></tr>
<tr class="separator:af99d9872a6acfd676e836e6773978995"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a981cb1019c5fd951755cf6e00caaa634"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a981cb1019c5fd951755cf6e00caaa634">any_source</a></td></tr>
<tr class="separator:a981cb1019c5fd951755cf6e00caaa634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0fd69f268eede17208c4c720ac19d5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibMesh_1_1Parallel_1_1MessageTag.html">MessageTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a0c0fd69f268eede17208c4c720ac19d5">any_tag</a> = <a class="el" href="classlibMesh_1_1Parallel_1_1MessageTag.html">MessageTag</a>(MPI_ANY_TAG)</td></tr>
<tr class="separator:a0c0fd69f268eede17208c4c720ac19d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2f05e8c57da65fd46aaa24d0af4078"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibMesh_1_1Parallel_1_1MessageTag.html">MessageTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibMesh_1_1Parallel.html#a0c2f05e8c57da65fd46aaa24d0af4078">no_tag</a> = <a class="el" href="classlibMesh_1_1Parallel_1_1MessageTag.html">MessageTag</a>(0)</td></tr>
<tr class="separator:a0c2f05e8c57da65fd46aaa24d0af4078"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="namespacelibMesh_1_1Parallel.html">Parallel</a> namespace is for wrapper functions for common general parallel synchronization tasks.</p>
<p>For MPI 1.1 compatibility, temporary buffers are used instead of MPI 2's MPI_IN_PLACE</p>
<p>The <a class="el" href="namespacelibMesh_1_1Parallel.html">Parallel</a> namespace is for wrapper functions for common general parallel synchronization tasks. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a2cdfa6faf50f37586a86c57926bda43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdfa6faf50f37586a86c57926bda43e">&#9670;&nbsp;</a></span>communicator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="namespacelibMesh_1_1Parallel.html#a2cdfa6faf50f37586a86c57926bda43e">libMesh::Parallel::communicator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> object for talking with subsets of processors </p>

<p class="definition">Definition at line <a class="el" href="communicator_8h_source.html#l00057">57</a> of file <a class="el" href="communicator_8h_source.html">communicator.h</a>.</p>

</div>
</div>
<a id="ad746570bb06f6070f3daf58cfc3cb77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad746570bb06f6070f3daf58cfc3cb77f">&#9670;&nbsp;</a></span>data_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef MPI_Datatype <a class="el" href="structlibMesh_1_1Parallel_1_1data__type.html">libMesh::Parallel::data_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data types for communication </p>

<p class="definition">Definition at line <a class="el" href="data__type_8h_source.html#l00046">46</a> of file <a class="el" href="data__type_8h_source.html">data_type.h</a>.</p>

</div>
</div>
<a id="aefbe7c94fa1895557e56fdc001710b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefbe7c94fa1895557e56fdc001710b16">&#9670;&nbsp;</a></span>DofObjectKey</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Hilbert::HilbertIndices <a class="el" href="namespacelibMesh_1_1Parallel.html#aefbe7c94fa1895557e56fdc001710b16">libMesh::Parallel::DofObjectKey</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parallel__hilbert_8h_source.html#l00069">69</a> of file <a class="el" href="parallel__hilbert_8h_source.html">parallel_hilbert.h</a>.</p>

</div>
</div>
<a id="a4cf28cfb3d6fefc535e83fb4b2698276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf28cfb3d6fefc535e83fb4b2698276">&#9670;&nbsp;</a></span>request</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef MPI_Request <a class="el" href="structlibMesh_1_1Parallel_1_1request.html">libMesh::Parallel::request</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classlibMesh_1_1Parallel_1_1Request.html">Request</a> object for non-blocking I/O </p>

<p class="definition">Definition at line <a class="el" href="request_8h_source.html#l00040">40</a> of file <a class="el" href="request_8h_source.html">request.h</a>.</p>

</div>
</div>
<a id="a08ff351bea1937bbde5a1af3160b4616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ff351bea1937bbde5a1af3160b4616">&#9670;&nbsp;</a></span>status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef MPI_Status <a class="el" href="structlibMesh_1_1Parallel_1_1status.html">libMesh::Parallel::status</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classlibMesh_1_1Parallel_1_1Status.html">Status</a> object for querying messages </p>

<p class="definition">Definition at line <a class="el" href="status_8h_source.html#l00041">41</a> of file <a class="el" href="status_8h_source.html">status.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7228e749d20793b8d57858105e3aea43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7228e749d20793b8d57858105e3aea43">&#9670;&nbsp;</a></span>dataplusint_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibMesh_1_1Parallel_1_1data__type.html">data_type</a> libMesh::Parallel::dataplusint_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Templated function to return the appropriate MPI datatype for use with built-in C types when combined with an int </p>

</div>
</div>
<a id="a1fed53973e584f967f78277b4f2337e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fed53973e584f967f78277b4f2337e0">&#9670;&nbsp;</a></span>dataplusint_type&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibMesh_1_1Parallel_1_1data__type.html">data_type</a> <a class="el" href="namespacelibMesh_1_1Parallel.html#a7228e749d20793b8d57858105e3aea43">libMesh::Parallel::dataplusint_type</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parallel__implementation_8h_source.html#l00167">167</a> of file <a class="el" href="parallel__implementation_8h_source.html">parallel_implementation.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;{ <span class="keywordflow">return</span> MPI_DOUBLE_INT; }</div></div><!-- fragment -->
</div>
</div>
<a id="af870d7629b079291ef0e6f5c32bee7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af870d7629b079291ef0e6f5c32bee7e4">&#9670;&nbsp;</a></span>dataplusint_type&lt; float &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibMesh_1_1Parallel_1_1data__type.html">data_type</a> <a class="el" href="namespacelibMesh_1_1Parallel.html#a7228e749d20793b8d57858105e3aea43">libMesh::Parallel::dataplusint_type</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parallel__implementation_8h_source.html#l00164">164</a> of file <a class="el" href="parallel__implementation_8h_source.html">parallel_implementation.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;{ <span class="keywordflow">return</span> MPI_FLOAT_INT; }</div></div><!-- fragment -->
</div>
</div>
<a id="a880ceb4da5c93366b56ca941b1a53762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880ceb4da5c93366b56ca941b1a53762">&#9670;&nbsp;</a></span>dataplusint_type&lt; int &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibMesh_1_1Parallel_1_1data__type.html">data_type</a> <a class="el" href="namespacelibMesh_1_1Parallel.html#a7228e749d20793b8d57858105e3aea43">libMesh::Parallel::dataplusint_type</a>&lt; int &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parallel__implementation_8h_source.html#l00158">158</a> of file <a class="el" href="parallel__implementation_8h_source.html">parallel_implementation.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;{ <span class="keywordflow">return</span> MPI_2INT; }</div></div><!-- fragment -->
</div>
</div>
<a id="ae6924048a1af82d47ce0582d20059623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6924048a1af82d47ce0582d20059623">&#9670;&nbsp;</a></span>dataplusint_type&lt; long &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibMesh_1_1Parallel_1_1data__type.html">data_type</a> <a class="el" href="namespacelibMesh_1_1Parallel.html#a7228e749d20793b8d57858105e3aea43">libMesh::Parallel::dataplusint_type</a>&lt; long &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parallel__implementation_8h_source.html#l00161">161</a> of file <a class="el" href="parallel__implementation_8h_source.html">parallel_implementation.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;{ <span class="keywordflow">return</span> MPI_LONG_INT; }</div></div><!-- fragment -->
</div>
</div>
<a id="ac0f953b15c8f57983385cddd6bbf8311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f953b15c8f57983385cddd6bbf8311">&#9670;&nbsp;</a></span>dataplusint_type&lt; long double &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibMesh_1_1Parallel_1_1data__type.html">data_type</a> <a class="el" href="namespacelibMesh_1_1Parallel.html#a7228e749d20793b8d57858105e3aea43">libMesh::Parallel::dataplusint_type</a>&lt; long double &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parallel__implementation_8h_source.html#l00170">170</a> of file <a class="el" href="parallel__implementation_8h_source.html">parallel_implementation.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;{ <span class="keywordflow">return</span> MPI_LONG_DOUBLE_INT; }</div></div><!-- fragment -->
</div>
</div>
<a id="af26377566e6a1e104a0a422b729bdbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26377566e6a1e104a0a422b729bdbcb">&#9670;&nbsp;</a></span>dataplusint_type&lt; short int &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibMesh_1_1Parallel_1_1data__type.html">data_type</a> <a class="el" href="namespacelibMesh_1_1Parallel.html#a7228e749d20793b8d57858105e3aea43">libMesh::Parallel::dataplusint_type</a>&lt; short int &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parallel__implementation_8h_source.html#l00155">155</a> of file <a class="el" href="parallel__implementation_8h_source.html">parallel_implementation.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;{ <span class="keywordflow">return</span> MPI_SHORT_INT; }</div></div><!-- fragment -->
</div>
</div>
<a id="a2d38ea0b5cab9d3bae0e540aace3e999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d38ea0b5cab9d3bae0e540aace3e999">&#9670;&nbsp;</a></span>LIBMESH_CONTAINER_TYPE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_CONTAINER_TYPE </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; T LIBMESH_ATTRIBUTES_COMMA C LIBMESH_ATTRIBUTES_COMMA <a class="el" href="petscdmlibmeshimpl_8C.html#a015846b6188ce15e08cd94c74a9df1a3">A</a> &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2e798af988febd8807be449bc835113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e798af988febd8807be449bc835113">&#9670;&nbsp;</a></span>LIBMESH_CONTAINER_TYPE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_CONTAINER_TYPE </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T LIBMESH_ATTRIBUTES_COMMA <a class="el" href="petscdmlibmeshimpl_8C.html#a015846b6188ce15e08cd94c74a9df1a3">A</a> &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93e7c3450394d89f5027b93ef4dc9740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e7c3450394d89f5027b93ef4dc9740">&#9670;&nbsp;</a></span>LIBMESH_FLOAT_TYPE() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_FLOAT_TYPE </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6f2e9e505db0a5dce697a0e5f757fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f2e9e505db0a5dce697a0e5f757fcf">&#9670;&nbsp;</a></span>LIBMESH_FLOAT_TYPE() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_FLOAT_TYPE </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0329d8ad0d59334c0a79e62f59fa1c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0329d8ad0d59334c0a79e62f59fa1c76">&#9670;&nbsp;</a></span>LIBMESH_FLOAT_TYPE() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_FLOAT_TYPE </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>double</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8aa285b35cbf64b12a2f50d65f99ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8aa285b35cbf64b12a2f50d65f99ebc">&#9670;&nbsp;</a></span>LIBMESH_INT_TYPE() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_INT_TYPE </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeeccc2a9b1f5e683c6e7783bb28b9104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeccc2a9b1f5e683c6e7783bb28b9104">&#9670;&nbsp;</a></span>LIBMESH_INT_TYPE() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_INT_TYPE </td>
          <td>(</td>
          <td class="paramtype">signed&#160;</td>
          <td class="paramname"><em>char</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aabf16ebf7d9f546dc0ec699c2a965bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf16ebf7d9f546dc0ec699c2a965bfa">&#9670;&nbsp;</a></span>LIBMESH_INT_TYPE() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_INT_TYPE </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>char</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f687aedee05a68ae331324b2caeb8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f687aedee05a68ae331324b2caeb8bf">&#9670;&nbsp;</a></span>LIBMESH_INT_TYPE() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_INT_TYPE </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>int</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a957361b7a122e44397d5e06f39ba185d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a957361b7a122e44397d5e06f39ba185d">&#9670;&nbsp;</a></span>LIBMESH_INT_TYPE() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_INT_TYPE </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>int</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e6b1d70a4215246b9c78a74a56924b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6b1d70a4215246b9c78a74a56924b6">&#9670;&nbsp;</a></span>LIBMESH_INT_TYPE() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_INT_TYPE </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9138c7260b575dfdc3cd12433cb45389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9138c7260b575dfdc3cd12433cb45389">&#9670;&nbsp;</a></span>LIBMESH_INT_TYPE() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_INT_TYPE </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6adffd9d06aaddf05bc3ec13ccd6aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6adffd9d06aaddf05bc3ec13ccd6aa9">&#9670;&nbsp;</a></span>LIBMESH_INT_TYPE() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_INT_TYPE </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>long</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4869bd736c7bfe88fea240e940788bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4869bd736c7bfe88fea240e940788bd0">&#9670;&nbsp;</a></span>LIBMESH_PARALLEL_FLOAT_OPS() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_PARALLEL_FLOAT_OPS </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af070a738fef21908708eec52898760d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af070a738fef21908708eec52898760d1">&#9670;&nbsp;</a></span>LIBMESH_PARALLEL_FLOAT_OPS() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_PARALLEL_FLOAT_OPS </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c96360a1bc5e03c4890b0ef40452727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c96360a1bc5e03c4890b0ef40452727">&#9670;&nbsp;</a></span>LIBMESH_PARALLEL_FLOAT_OPS() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_PARALLEL_FLOAT_OPS </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>double</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4779d9ce36f287fffefb041805efde1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4779d9ce36f287fffefb041805efde1f">&#9670;&nbsp;</a></span>LIBMESH_PARALLEL_INTEGER_OPS() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_PARALLEL_INTEGER_OPS </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2feb9f4a16d2fb40534ad239c897a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2feb9f4a16d2fb40534ad239c897a3f">&#9670;&nbsp;</a></span>LIBMESH_PARALLEL_INTEGER_OPS() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_PARALLEL_INTEGER_OPS </td>
          <td>(</td>
          <td class="paramtype">signed&#160;</td>
          <td class="paramname"><em>char</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae47801953ca83f05dee11abb0adf134c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47801953ca83f05dee11abb0adf134c">&#9670;&nbsp;</a></span>LIBMESH_PARALLEL_INTEGER_OPS() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_PARALLEL_INTEGER_OPS </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>char</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af0bed5fe4b7daf35de0c86e623cb2969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0bed5fe4b7daf35de0c86e623cb2969">&#9670;&nbsp;</a></span>LIBMESH_PARALLEL_INTEGER_OPS() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_PARALLEL_INTEGER_OPS </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>int</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d65ed6e7adae8d532cd16cf0a261c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d65ed6e7adae8d532cd16cf0a261c67">&#9670;&nbsp;</a></span>LIBMESH_PARALLEL_INTEGER_OPS() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_PARALLEL_INTEGER_OPS </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>int</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a85be697082f5446c0abb91acb19dfaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85be697082f5446c0abb91acb19dfaf5">&#9670;&nbsp;</a></span>LIBMESH_PARALLEL_INTEGER_OPS() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_PARALLEL_INTEGER_OPS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9476a7115c67f46f4b9a3d8c212c727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9476a7115c67f46f4b9a3d8c212c727">&#9670;&nbsp;</a></span>LIBMESH_PARALLEL_INTEGER_OPS() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_PARALLEL_INTEGER_OPS </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ef8f05a8d6c1e8cf7483f4a1c3fdcbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef8f05a8d6c1e8cf7483f4a1c3fdcbd">&#9670;&nbsp;</a></span>LIBMESH_PARALLEL_INTEGER_OPS() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_PARALLEL_INTEGER_OPS </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>long</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34082a9080937b461e2a804e80dd6693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34082a9080937b461e2a804e80dd6693">&#9670;&nbsp;</a></span>LIBMESH_STANDARD_TYPE() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_STANDARD_TYPE </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_CHAR&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade4860f42c2c3c03f94dbafbab147ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4860f42c2c3c03f94dbafbab147ea0">&#9670;&nbsp;</a></span>LIBMESH_STANDARD_TYPE() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_STANDARD_TYPE </td>
          <td>(</td>
          <td class="paramtype">signed&#160;</td>
          <td class="paramname"><em>char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_SIGNED_CHAR&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af0404c7aa3609500b6d8c18710f2527e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0404c7aa3609500b6d8c18710f2527e">&#9670;&nbsp;</a></span>LIBMESH_STANDARD_TYPE() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_STANDARD_TYPE </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_UNSIGNED_CHAR&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab512f183275eed4287667786b900395b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab512f183275eed4287667786b900395b">&#9670;&nbsp;</a></span>LIBMESH_STANDARD_TYPE() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_STANDARD_TYPE </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_SHORT&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1dcde59eea2a499af418a0c8a896b8a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dcde59eea2a499af418a0c8a896b8a4">&#9670;&nbsp;</a></span>LIBMESH_STANDARD_TYPE() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_STANDARD_TYPE </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_UNSIGNED_SHORT&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ac2370de3f73920c820b68696c6daa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac2370de3f73920c820b68696c6daa0">&#9670;&nbsp;</a></span>LIBMESH_STANDARD_TYPE() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_STANDARD_TYPE </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_INT&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a43375c35ee1d88dd4d3da4b5c0f5abde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43375c35ee1d88dd4d3da4b5c0f5abde">&#9670;&nbsp;</a></span>LIBMESH_STANDARD_TYPE() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_STANDARD_TYPE </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_UNSIGNED&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a00f9cbfcfa5b5a9176d0ea57f732ecfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f9cbfcfa5b5a9176d0ea57f732ecfb">&#9670;&nbsp;</a></span>LIBMESH_STANDARD_TYPE() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_STANDARD_TYPE </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_LONG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab90e70b6571e38180131dd206342ffdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90e70b6571e38180131dd206342ffdd">&#9670;&nbsp;</a></span>LIBMESH_STANDARD_TYPE() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_STANDARD_TYPE </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>long</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_LONG_LONG_INT&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0fb9da05ad9da6d0ef409117c08e882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0fb9da05ad9da6d0ef409117c08e882">&#9670;&nbsp;</a></span>LIBMESH_STANDARD_TYPE() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_STANDARD_TYPE </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>long</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_UNSIGNED_LONG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96dfecfedfa2ed0acac08c0eac000468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96dfecfedfa2ed0acac08c0eac000468">&#9670;&nbsp;</a></span>LIBMESH_STANDARD_TYPE() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_STANDARD_TYPE </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>long</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_UNSIGNED_LONG_LONG&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7ed7c90de6436c20acbbdf1dc6311b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ed7c90de6436c20acbbdf1dc6311b2">&#9670;&nbsp;</a></span>LIBMESH_STANDARD_TYPE() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_STANDARD_TYPE </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_FLOAT&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4e1eeb5923fc0aee13b8ccd23bbaa85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e1eeb5923fc0aee13b8ccd23bbaa85">&#9670;&nbsp;</a></span>LIBMESH_STANDARD_TYPE() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_STANDARD_TYPE </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_DOUBLE&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af99d9872a6acfd676e836e6773978995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af99d9872a6acfd676e836e6773978995">&#9670;&nbsp;</a></span>LIBMESH_STANDARD_TYPE() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::Parallel::LIBMESH_STANDARD_TYPE </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>double</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_LONG_DOUBLE&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abbff8955d0081e65a953e8076d7bfe94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbff8955d0081e65a953e8076d7bfe94">&#9670;&nbsp;</a></span>pack_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Context , typename buffertype , typename Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iter libMesh::Parallel::pack_range </td>
          <td>(</td>
          <td class="paramtype">const Context *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>range_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iter&#160;</td>
          <td class="paramname"><em>range_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::vector&lt; buffertype &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>approx_buffer_size</em> = <code>1000000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encode a range of potentially-variable-size objects to a data array.</p>
<p>The data will be buffered in vectors with lengths that do not exceed the sum of <code>approx_buffer_size</code> and the size of an individual packed object.</p>
<p>Helper function for range packing </p>

<p class="definition">Definition at line <a class="el" href="packing_8h_source.html#l00139">139</a> of file <a class="el" href="packing_8h_source.html">packing.h</a>.</p>

<p class="reference">References <a class="el" href="classlibMesh_1_1Parallel_1_1Packing.html#a15e3480d864bfb38e4f62fa7f7e8a8d3">libMesh::Parallel::Packing&lt; T &gt;::pack()</a>, <a class="el" href="classlibMesh_1_1Parallel_1_1Packing.html#a98886c98b162d96d7e086c1c5f49c8bc">libMesh::Parallel::Packing&lt; T &gt;::packable_size()</a>, and <a class="el" href="classlibMesh_1_1Parallel_1_1Packing.html#a56f82b789dd6b6dda1c7e03f40bad578">libMesh::Parallel::Packing&lt; T &gt;::packed_size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="parallel__implementation_8h_source.html#l03176">libMesh::Parallel::Communicator::allgather_packed_range()</a>, <a class="el" href="parallel__implementation_8h_source.html#l01672">libMesh::Parallel::Communicator::broadcast_packed_range()</a>, <a class="el" href="parallel__implementation_8h_source.html#l03143">libMesh::Parallel::Communicator::gather_packed_range()</a>, <a class="el" href="parallel__implementation_8h_source.html#l00686">libMesh::Parallel::Communicator::nonblocking_send_packed_range()</a>, <a class="el" href="parallel__implementation_8h_source.html#l00562">libMesh::Parallel::Communicator::send_packed_range()</a>, and <a class="el" href="parallel__implementation_8h_source.html#l01876">libMesh::Parallel::Communicator::send_receive_packed_range()</a>.</p>
<div class="fragment"><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;{</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;  <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;Iter&gt;::value_type T;</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;  <span class="comment">// Count the total size of and preallocate buffer for efficiency.</span></div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;  <span class="comment">// Prepare to stop early if the buffer would be too large.</span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;  std::size_t buffer_size = 0;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;  Iter range_stop = range_begin;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;  <span class="keywordflow">for</span> (; range_stop != range_end &amp;&amp; buffer_size &lt; approx_buffer_size;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;       ++range_stop)</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    {</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;      std::size_t next_buffer_size =</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        Parallel::Packing&lt;T&gt;::packable_size(*range_stop, context);</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;      buffer_size += next_buffer_size;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    }</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;  buffer.reserve(buffer.size() + buffer_size);</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;  <span class="comment">// Pack the objects into the buffer</span></div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;  <span class="keywordflow">for</span> (; range_begin != range_stop; ++range_begin)</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    {</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;<span class="preprocessor">#ifndef NDEBUG</span></div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;      std::size_t old_size = buffer.size();</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;      Parallel::Packing&lt;T&gt;::pack</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;        (*range_begin, back_inserter(buffer), context);</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;<span class="preprocessor">#ifndef NDEBUG</span></div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> my_packable_size =</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;        Parallel::Packing&lt;T&gt;::packable_size(*range_begin, context);</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> my_packed_size =</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;        Parallel::Packing&lt;T&gt;::packed_size (buffer.begin() + old_size);</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;      libmesh_assert_equal_to (my_packable_size, my_packed_size);</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;      libmesh_assert_equal_to (buffer.size(), old_size + my_packable_size);</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    }</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;  <span class="keywordflow">return</span> range_stop;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5ac96c8ed3881c25d394f6e65eabf6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac96c8ed3881c25d394f6e65eabf6b2">&#9670;&nbsp;</a></span>packed_range_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Context , typename Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t libMesh::Parallel::packed_range_size </td>
          <td>(</td>
          <td class="paramtype">const Context *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>range_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iter&#160;</td>
          <td class="paramname"><em>range_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total buffer size needed to encode a range of potentially-variable-size objects to a data array.</p>
<p>Helper function for range packing </p>

<p class="definition">Definition at line <a class="el" href="packing_8h_source.html#l00118">118</a> of file <a class="el" href="packing_8h_source.html">packing.h</a>.</p>

<p class="reference">References <a class="el" href="classlibMesh_1_1Parallel_1_1Packing.html#a98886c98b162d96d7e086c1c5f49c8bc">libMesh::Parallel::Packing&lt; T &gt;::packable_size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="parallel__implementation_8h_source.html#l00562">libMesh::Parallel::Communicator::send_packed_range()</a>.</p>
<div class="fragment"><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;{</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;Iter&gt;::value_type T;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;  std::size_t buffer_size = 0;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;  <span class="keywordflow">for</span> (Iter range_count = range_begin;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;       range_count != range_end;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;       ++range_count)</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    {</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;      buffer_size += Parallel::Packing&lt;T&gt;::packable_size(*range_count, context);</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    }</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  <span class="keywordflow">return</span> buffer_size;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a21797734483c801c09fa26822455d989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21797734483c801c09fa26822455d989">&#9670;&nbsp;</a></span>pull_parallel_vector_data() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename datum , typename MapToVectors , typename RequestContainer , typename GatherFunctor , typename ActionFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Parallel::pull_parallel_vector_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MapToVectors &amp;&#160;</td>
          <td class="paramname"><em>queries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RequestContainer &amp;&#160;</td>
          <td class="paramname"><em>reqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GatherFunctor &amp;&#160;</td>
          <td class="paramname"><em>gather_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ActionFunctor &amp;&#160;</td>
          <td class="paramname"><em>act_on_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const datum *&#160;</td>
          <td class="paramname"><em>example</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send query vectors, receive and answer them with vectors of data, then act on those answers.</p>
<p>The <code>data</code> map is indexed by processor ids as keys, and for each processor id in the map there should be a vector of query ids to send.</p>
<p>Query data which is received from other processors will be operated on by gather_data(processor_id_type pid, const std::vector&lt;id&gt; &amp; ids, std::vector&lt;datum&gt; &amp; data)</p>
<p>Answer data which is received from other processors will be operated on by act_on_data(processor_id_type pid, const std::vector&lt;id&gt; &amp; ids, const std::vector&lt;datum&gt; &amp; data);</p>
<p>The example pointer may be null; it merely needs to be of the correct type. It's just here because function overloading in C++ is easy, whereas SFINAE is hard and partial template specialization of functions is impossible.</p>
<p>No guarantee about operation ordering is made - this function will attempt to act on data in the order in which it is received.</p>
<p>All receives and actions are completed before this function returns.</p>
<p>Not all sends may have yet completed. The supplied container of <a class="el" href="classlibMesh_1_1Parallel_1_1Request.html">Request</a> objects, <code>req</code>, has more requests inserted, one for each of the data sends. These requests must be waited on before the <code>data</code> map is deleted. </p>

<p class="definition">Definition at line <a class="el" href="parallel__sync_8h_source.html#l00472">472</a> of file <a class="el" href="parallel__sync_8h_source.html">parallel_sync.h</a>.</p>

<p class="reference">References <a class="el" href="communicator_8C_source.html#l00201">libMesh::Parallel::Communicator::get_unique_tag()</a>, <a class="el" href="parallel__sync_8h_source.html#l00239">push_parallel_vector_data()</a>, <a class="el" href="mesh__communication_8C_source.html#l01416">query</a>, <a class="el" href="communicator_8h_source.html#l00173">libMesh::Parallel::Communicator::rank()</a>, <a class="el" href="parallel__implementation_8h_source.html#l00771">libMesh::Parallel::Communicator::receive()</a>, <a class="el" href="parallel__implementation_8h_source.html#l00261">libMesh::Parallel::Communicator::send()</a>, <a class="el" href="communicator_8h_source.html#l00175">libMesh::Parallel::Communicator::size()</a>, <a class="el" href="request_8C_source.html#l00213">wait()</a>, and <a class="el" href="request_8C_source.html#l00219">waitany()</a>.</p>

<p class="reference">Referenced by <a class="el" href="dof__map__constraints_8C_source.html#l02595">libMesh::DofMap::allgather_recursive_constraints()</a>, <a class="el" href="mesh__communication__global__indices_8C_source.html#l00168">libMesh::MeshCommunication::assign_global_indices()</a>, <a class="el" href="partitioner_8C_source.html#l01113">libMesh::Partitioner::assign_partitioning()</a>, <a class="el" href="mesh__communication__global__indices_8C_source.html#l00708">libMesh::MeshCommunication::find_global_indices()</a>, <a class="el" href="dof__map__constraints_8C_source.html#l03871">libMesh::DofMap::gather_constraints()</a>, <a class="el" href="distributed__vector_8C_source.html#l00423">libMesh::DistributedVector&lt; T &gt;::localize()</a>, <a class="el" href="parallel__sync_8h_source.html#l00559">pull_parallel_vector_data()</a>, <a class="el" href="distributed__mesh_8C_source.html#l00961">libMesh::DistributedMesh::renumber_dof_objects()</a>, <a class="el" href="partitioner_8C_source.html#l00679">libMesh::Partitioner::set_node_processor_ids()</a>, <a class="el" href="dof__map_8C_source.html#l00321">libMesh::DofMap::set_nonlocal_dof_objects()</a>, <a class="el" href="parallel__ghost__sync_8h_source.html#l00347">sync_dofobject_data_by_id()</a>, <a class="el" href="parallel__ghost__sync_8h_source.html#l00232">sync_dofobject_data_by_xyz()</a>, <a class="el" href="parallel__ghost__sync_8h_source.html#l00429">sync_element_data_by_parent_id()</a>, <a class="el" href="parallel__ghost__sync_8h_source.html#l00546">sync_node_data_by_element_id_once()</a>, and <a class="el" href="xdr__io_8C_source.html#l00351">libMesh::XdrIO::write_serialized_connectivity()</a>.</p>
<div class="fragment"><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;{</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;  <span class="keyword">typedef</span> <span class="keyword">typename</span> MapToVectors::mapped_type query_type;</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;  std::map&lt;processor_id_type, std::vector&lt;datum&gt; &gt;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;    response_data, received_data;</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;  std::vector&lt;Request&gt; response_reqs;</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;  StandardType&lt;datum&gt; datatype;</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;  <span class="comment">// We&#39;ll grab a tag so we can overlap request sends and receives</span></div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;  <span class="comment">// without confusing one for the other</span></div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;  MessageTag tag = comm.get_unique_tag(105);</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;  <span class="keyword">auto</span> gather_functor =</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;    [&amp;comm, &amp;gather_data, &amp;response_data, &amp;response_reqs, &amp;datatype, &amp;tag]</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;    (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> pid, query_type <a class="code" href="mesh__communication_8C.html#af9480beb819e5e9e85e156922fd16716">query</a>)</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    {</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;      gather_data(pid, <a class="code" href="mesh__communication_8C.html#af9480beb819e5e9e85e156922fd16716">query</a>, response_data[pid]);</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;      libmesh_assert_equal_to(<a class="code" href="mesh__communication_8C.html#af9480beb819e5e9e85e156922fd16716">query</a>.size(), response_data[pid].size());</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;      <span class="comment">// Just act on data later if the user requested a send-to-self</span></div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;      <span class="keywordflow">if</span> (pid != comm.rank())</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;        {</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;          Request sendreq;</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;          comm.send(pid, response_data[pid], datatype, sendreq, tag);</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;          response_reqs.push_back(sendreq);</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;        }</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;    };</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#aef9703aa21aa121441db66d7ebdfa8a7">push_parallel_vector_data</a> (comm, queries, reqs, gather_functor);</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;  <span class="comment">// Every outgoing query should now have an incoming response.</span></div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;  <span class="comment">// Post all of the receives, non-blocking</span></div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;  std::vector&lt;Request&gt; receive_reqs;</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;  std::vector&lt;processor_id_type&gt; receive_procids;</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; querypair : queries)</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;    {</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;      <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> proc_id = querypair.first;</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;      libmesh_assert_less(proc_id, comm.size());</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;      <span class="keywordflow">if</span> (proc_id == comm.rank())</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;        {</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;          libmesh_assert(queries.count(proc_id));</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;          libmesh_assert_equal_to(queries.at(proc_id).size(),</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;                                  response_data.at(proc_id).size());</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;          act_on_data(proc_id, queries.at(proc_id), response_data.at(proc_id));</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;        }</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;        {</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;          <span class="keyword">auto</span> &amp; querydata = querypair.second;</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;          Request req;</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;          <span class="keyword">auto</span> &amp; incoming_data = received_data[proc_id];</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;          incoming_data.resize(querydata.size());</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;          comm.receive(proc_id, incoming_data, datatype, req, tag);</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;          receive_reqs.push_back(req);</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;          receive_procids.push_back(proc_id);</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;        }</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;    }</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;  <span class="keywordflow">while</span>(receive_reqs.size())</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;    {</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;      std::size_t completed = <a class="code" href="namespacelibMesh_1_1Parallel.html#aff47382fb119efc31a05639bd54f8ed6">waitany</a>(receive_reqs);</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;      <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> proc_id = receive_procids[completed];</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;      receive_reqs.erase(receive_reqs.begin() + completed);</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;      receive_procids.erase(receive_procids.begin() + completed);</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;      libmesh_assert(queries.count(proc_id));</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;      libmesh_assert_equal_to(queries.at(proc_id).size(),</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;                              received_data[proc_id].size());</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;      act_on_data(proc_id, queries.at(proc_id), received_data[proc_id]);</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;      received_data.erase(proc_id);</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;    }</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#aea5278a91928fa4f33b74aa0786f3592">wait</a>(response_reqs);</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;}</div><div class="ttc" id="namespacelibMesh_1_1Parallel_html_aea5278a91928fa4f33b74aa0786f3592"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#aea5278a91928fa4f33b74aa0786f3592">libMesh::Parallel::wait</a></div><div class="ttdeci">void wait(std::vector&lt; Request &gt; &amp;r)</div><div class="ttdef"><b>Definition:</b> <a href="request_8C_source.html#l00213">request.C:213</a></div></div>
<div class="ttc" id="namespacelibMesh_html_afebcb3616f8c81cda531dec404f2420d"><div class="ttname"><a href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">libMesh::processor_id_type</a></div><div class="ttdeci">uint8_t processor_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00099">id_types.h:99</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_aef9703aa21aa121441db66d7ebdfa8a7"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#aef9703aa21aa121441db66d7ebdfa8a7">libMesh::Parallel::push_parallel_vector_data</a></div><div class="ttdeci">void push_parallel_vector_data(const Communicator &amp;comm, const MapType&lt; processor_id_type, std::vector&lt; std::vector&lt; ValueType, A1 &gt;, A2 &gt;, ExtraTypes... &gt; &amp;data, ActionFunctor &amp;act_on_data)</div><div class="ttdef"><b>Definition:</b> <a href="parallel__sync_8h_source.html#l00454">parallel_sync.h:454</a></div></div>
<div class="ttc" id="mesh__communication_8C_html_af9480beb819e5e9e85e156922fd16716"><div class="ttname"><a href="mesh__communication_8C.html#af9480beb819e5e9e85e156922fd16716">query</a></div><div class="ttdeci">query_obj query</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01416">mesh_communication.C:1416</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_aff47382fb119efc31a05639bd54f8ed6"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#aff47382fb119efc31a05639bd54f8ed6">libMesh::Parallel::waitany</a></div><div class="ttdeci">std::size_t waitany(std::vector&lt; Request &gt; &amp;r)</div><div class="ttdef"><b>Definition:</b> <a href="request_8C_source.html#l00219">request.C:219</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a49b8c5827b01ae110fdbf3ea145350af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b8c5827b01ae110fdbf3ea145350af">&#9670;&nbsp;</a></span>pull_parallel_vector_data() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename datum , typename MapToVectors , typename GatherFunctor , typename ActionFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Parallel::pull_parallel_vector_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MapToVectors &amp;&#160;</td>
          <td class="paramname"><em>queries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GatherFunctor &amp;&#160;</td>
          <td class="paramname"><em>gather_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ActionFunctor &amp;&#160;</td>
          <td class="paramname"><em>act_on_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const datum *&#160;</td>
          <td class="paramname"><em>example</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send query vectors, receive and answer them with vectors of data, then act on those answers.</p>
<p>The <code>data</code> map is indexed by processor ids as keys, and for each processor id in the map there should be a vector of query ids to send.</p>
<p>Query data which is received from other processors will be operated on by gather_data(processor_id_type pid, const std::vector&lt;id&gt; &amp; ids, std::vector&lt;datum&gt; &amp; data)</p>
<p>Answer data which is received from other processors will be operated on by act_on_data(processor_id_type pid, const std::vector&lt;id&gt; &amp; ids, const std::vector&lt;datum&gt; &amp; data);</p>
<p>The example pointer may be null; it merely needs to be of the correct type. It's just here because function overloading in C++ is easy, whereas SFINAE is hard and partial template specialization of functions is impossible.</p>
<p>No guarantee about operation ordering is made - this function will attempt to act on data in the order in which it is received.</p>
<p>All communication and actions are complete when this function returns. </p>

<p class="definition">Definition at line <a class="el" href="parallel__sync_8h_source.html#l00559">559</a> of file <a class="el" href="parallel__sync_8h_source.html">parallel_sync.h</a>.</p>

<p class="reference">References <a class="el" href="parallel__sync_8h_source.html#l00472">pull_parallel_vector_data()</a>, and <a class="el" href="request_8C_source.html#l00213">wait()</a>.</p>
<div class="fragment"><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;{</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;  std::vector&lt;Request&gt; requests;</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#acbd835a87c6e9122d141633bf748bd2f">pull_parallel_vector_data</a>(comm, queries, requests, gather_data,</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;                            act_on_data, example);</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#aea5278a91928fa4f33b74aa0786f3592">wait</a>(requests);</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;}</div><div class="ttc" id="namespacelibMesh_1_1Parallel_html_aea5278a91928fa4f33b74aa0786f3592"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#aea5278a91928fa4f33b74aa0786f3592">libMesh::Parallel::wait</a></div><div class="ttdeci">void wait(std::vector&lt; Request &gt; &amp;r)</div><div class="ttdef"><b>Definition:</b> <a href="request_8C_source.html#l00213">request.C:213</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_acbd835a87c6e9122d141633bf748bd2f"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#acbd835a87c6e9122d141633bf748bd2f">libMesh::Parallel::pull_parallel_vector_data</a></div><div class="ttdeci">void pull_parallel_vector_data(const Communicator &amp;comm, const MapToVectors &amp;queries, RequestContainer &amp;reqs, GatherFunctor &amp;gather_data, ActionFunctor &amp;act_on_data, const std::vector&lt; datum, A &gt; *example)</div><div class="ttdef"><b>Definition:</b> <a href="parallel__sync_8h_source.html#l00580">parallel_sync.h:580</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="acbd835a87c6e9122d141633bf748bd2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd835a87c6e9122d141633bf748bd2f">&#9670;&nbsp;</a></span>pull_parallel_vector_data() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename datum , typename A , typename MapToVectors , typename RequestContainer , typename GatherFunctor , typename ActionFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Parallel::pull_parallel_vector_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MapToVectors &amp;&#160;</td>
          <td class="paramname"><em>queries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RequestContainer &amp;&#160;</td>
          <td class="paramname"><em>reqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GatherFunctor &amp;&#160;</td>
          <td class="paramname"><em>gather_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ActionFunctor &amp;&#160;</td>
          <td class="paramname"><em>act_on_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; datum, <a class="el" href="petscdmlibmeshimpl_8C.html#a015846b6188ce15e08cd94c74a9df1a3">A</a> &gt; *&#160;</td>
          <td class="paramname"><em>example</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parallel__sync_8h_source.html#l00580">580</a> of file <a class="el" href="parallel__sync_8h_source.html">parallel_sync.h</a>.</p>

<p class="reference">References <a class="el" href="communicator_8h_source.html#l00070">any_source</a>, <a class="el" href="communicator_8C_source.html#l00201">libMesh::Parallel::Communicator::get_unique_tag()</a>, <a class="el" href="parallel__implementation_8h_source.html#l00174">libMesh::Parallel::Communicator::probe()</a>, <a class="el" href="parallel__sync_8h_source.html#l00239">push_parallel_vector_data()</a>, <a class="el" href="mesh__communication_8C_source.html#l01416">query</a>, <a class="el" href="communicator_8h_source.html#l00173">libMesh::Parallel::Communicator::rank()</a>, <a class="el" href="parallel__implementation_8h_source.html#l00771">libMesh::Parallel::Communicator::receive()</a>, <a class="el" href="parallel__implementation_8h_source.html#l00261">libMesh::Parallel::Communicator::send()</a>, and <a class="el" href="request_8C_source.html#l00213">wait()</a>.</p>
<div class="fragment"><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;{</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;  <span class="keyword">typedef</span> <span class="keyword">typename</span> MapToVectors::mapped_type query_type;</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;  std::map&lt;processor_id_type, std::vector&lt;std::vector&lt;datum,A&gt;&gt;&gt;</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;    response_data;</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;  std::vector&lt;Request&gt; response_reqs;</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;  <span class="comment">// We&#39;ll grab a tag so we can overlap request sends and receives</span></div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;  <span class="comment">// without confusing one for the other</span></div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;  MessageTag tag = comm.get_unique_tag(105);</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;  <span class="keyword">auto</span> gather_functor =</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;    [&amp;comm, &amp;gather_data, &amp;act_on_data,</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;     &amp;response_data, &amp;response_reqs, &amp;tag]</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;    (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> pid, query_type <a class="code" href="mesh__communication_8C.html#af9480beb819e5e9e85e156922fd16716">query</a>)</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;    {</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;      gather_data(pid, <a class="code" href="mesh__communication_8C.html#af9480beb819e5e9e85e156922fd16716">query</a>, response_data[pid]);</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;      libmesh_assert_equal_to(<a class="code" href="mesh__communication_8C.html#af9480beb819e5e9e85e156922fd16716">query</a>.size(),</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;                              response_data[pid].size());</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;      <span class="comment">// Just act on data if the user requested a send-to-self</span></div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;      <span class="keywordflow">if</span> (pid == comm.rank())</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;        {</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;          act_on_data(pid, <a class="code" href="mesh__communication_8C.html#af9480beb819e5e9e85e156922fd16716">query</a>, response_data[pid]);</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;        }</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;        {</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;          Request sendreq;</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;          comm.send(pid, response_data[pid], sendreq, tag);</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;          response_reqs.push_back(sendreq);</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;        }</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;    };</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#aef9703aa21aa121441db66d7ebdfa8a7">push_parallel_vector_data</a> (comm, queries, reqs, gather_functor);</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;  <span class="comment">// Every outgoing query should now have an incoming response.</span></div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;  <span class="comment">// Post all of the receives.</span></div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;  <span class="comment">// Use blocking API here since we can&#39;t use the pre-sized</span></div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;  <span class="comment">// non-blocking APIs with this data type.</span></div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;  <span class="comment">// FIXME - implement Derek&#39;s API from #1684, switch to that!</span></div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;  std::vector&lt;Request&gt; receive_reqs;</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;  std::vector&lt;processor_id_type&gt; receive_procids;</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;  <span class="keywordflow">for</span> (std::size_t i = 0,</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;       n_queries = queries.size() - queries.count(comm.rank());</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;       i != n_queries; ++i)</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;    {</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;      Status stat(comm.probe(<a class="code" href="namespacelibMesh_1_1Parallel.html#a981cb1019c5fd951755cf6e00caaa634">any_source</a>, tag));</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;      <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a></div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;        proc_id = cast_int&lt;processor_id_type&gt;(stat.source());</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;      std::vector&lt;std::vector&lt;datum,A&gt;&gt; received_data;</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;      comm.receive(proc_id, received_data, tag);</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;      libmesh_assert(queries.count(proc_id));</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;      <span class="keyword">auto</span> &amp; querydata = queries.at(proc_id);</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;      libmesh_assert_equal_to(querydata.size(), received_data.size());</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;      act_on_data(proc_id, querydata, received_data);</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;    }</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#aea5278a91928fa4f33b74aa0786f3592">wait</a>(response_reqs);</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;}</div><div class="ttc" id="namespacelibMesh_1_1Parallel_html_aea5278a91928fa4f33b74aa0786f3592"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#aea5278a91928fa4f33b74aa0786f3592">libMesh::Parallel::wait</a></div><div class="ttdeci">void wait(std::vector&lt; Request &gt; &amp;r)</div><div class="ttdef"><b>Definition:</b> <a href="request_8C_source.html#l00213">request.C:213</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_a981cb1019c5fd951755cf6e00caaa634"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#a981cb1019c5fd951755cf6e00caaa634">libMesh::Parallel::any_source</a></div><div class="ttdeci">const unsigned int any_source</div><div class="ttdef"><b>Definition:</b> <a href="communicator_8h_source.html#l00070">communicator.h:70</a></div></div>
<div class="ttc" id="namespacelibMesh_html_afebcb3616f8c81cda531dec404f2420d"><div class="ttname"><a href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">libMesh::processor_id_type</a></div><div class="ttdeci">uint8_t processor_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00099">id_types.h:99</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_aef9703aa21aa121441db66d7ebdfa8a7"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#aef9703aa21aa121441db66d7ebdfa8a7">libMesh::Parallel::push_parallel_vector_data</a></div><div class="ttdeci">void push_parallel_vector_data(const Communicator &amp;comm, const MapType&lt; processor_id_type, std::vector&lt; std::vector&lt; ValueType, A1 &gt;, A2 &gt;, ExtraTypes... &gt; &amp;data, ActionFunctor &amp;act_on_data)</div><div class="ttdef"><b>Definition:</b> <a href="parallel__sync_8h_source.html#l00454">parallel_sync.h:454</a></div></div>
<div class="ttc" id="mesh__communication_8C_html_af9480beb819e5e9e85e156922fd16716"><div class="ttname"><a href="mesh__communication_8C.html#af9480beb819e5e9e85e156922fd16716">query</a></div><div class="ttdeci">query_obj query</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01416">mesh_communication.C:1416</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2840c544bef5845992c918f1cb4669f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2840c544bef5845992c918f1cb4669f1">&#9670;&nbsp;</a></span>push_parallel_vector_data() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MapToVectors , typename RequestContainer , typename ActionFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Parallel::push_parallel_vector_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MapToVectors &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RequestContainer &amp;&#160;</td>
          <td class="paramname"><em>reqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ActionFunctor &amp;&#160;</td>
          <td class="paramname"><em>act_on_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send and receive and act on vectors of data.</p>
<p>The <code>data</code> map is indexed by processor ids as keys, and for each processor id in the map there should be a vector of data to send.</p>
<p>Data which is received from other processors will be operated on by act_on_data(processor_id_type pid, const std::vector&lt;datum&gt; &amp; data)</p>
<p>No guarantee about operation ordering is made - this function will attempt to act on data in the order in which it is received.</p>
<p>All receives and actions are completed before this function returns.</p>
<p>Not all sends may have yet completed. The supplied container of <a class="el" href="classlibMesh_1_1Parallel_1_1Request.html">Request</a> objects, <code>req</code>, has more requests inserted, one for each of the data sends. These requests must be waited on before the <code>data</code> map is deleted. </p>

<p class="definition">Definition at line <a class="el" href="parallel__sync_8h_source.html#l00239">239</a> of file <a class="el" href="parallel__sync_8h_source.html">parallel_sync.h</a>.</p>

<p class="reference">References <a class="el" href="parallel__implementation_8h_source.html#l03092">libMesh::Parallel::Communicator::alltoall()</a>, <a class="el" href="variant__filter__iterator_8h_source.html#l00337">data</a>, <a class="el" href="communicator_8C_source.html#l00201">libMesh::Parallel::Communicator::get_unique_tag()</a>, <a class="el" href="communicator_8h_source.html#l00173">libMesh::Parallel::Communicator::rank()</a>, <a class="el" href="parallel__implementation_8h_source.html#l00771">libMesh::Parallel::Communicator::receive()</a>, <a class="el" href="parallel__implementation_8h_source.html#l00261">libMesh::Parallel::Communicator::send()</a>, <a class="el" href="communicator_8h_source.html#l00175">libMesh::Parallel::Communicator::size()</a>, and <a class="el" href="request_8C_source.html#l00219">waitany()</a>.</p>

<p class="reference">Referenced by <a class="el" href="dof__map__constraints_8C_source.html#l02595">libMesh::DofMap::allgather_recursive_constraints()</a>, <a class="el" href="parallel__sort_8C_source.html#l00196">libMesh::Parallel::Sort&lt; KeyType, IdxType &gt;::communicate_bins()</a>, <a class="el" href="mesh__tools_8C_source.html#l02259">libMesh::MeshTools::correct_node_proc_ids()</a>, <a class="el" href="parallel__sync_8h_source.html#l00472">pull_parallel_vector_data()</a>, <a class="el" href="parallel__sync_8h_source.html#l00435">push_parallel_vector_data()</a>, and <a class="el" href="dof__map__constraints_8C_source.html#l03432">libMesh::DofMap::scatter_constraints()</a>.</p>
<div class="fragment"><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;{</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;  libmesh_parallel_only(comm);</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;  <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> num_procs = comm.size();</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;  <span class="comment">// Size of vectors to send to each procesor</span></div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;  std::vector&lt;std::size_t&gt; will_send_to(num_procs, 0);</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;  <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> num_sends = 0;</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; datapair : <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>)</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    {</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;      <span class="comment">// Don&#39;t try to send anywhere that doesn&#39;t exist</span></div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;      libmesh_assert_less(datapair.first, num_procs);</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;      <span class="comment">// Don&#39;t give us empty vectors to send</span></div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;      libmesh_assert_greater(datapair.second.size(), 0);</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;      will_send_to[datapair.first] = datapair.second.size();</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;      num_sends++;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;    }</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;  <span class="comment">// Tell everyone about where everyone will send to</span></div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;  comm.alltoall(will_send_to);</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;  <span class="comment">// will_send_to now represents who we&#39;ll receive from</span></div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;  <span class="comment">// give it a good name</span></div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;  <span class="keyword">auto</span> &amp; will_receive_from = will_send_to;</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;  <span class="comment">// This function only works for &quot;flat&quot; data that we can pre-size</span></div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;  <span class="comment">// receive buffers for: a map to vectors-of-standard-types, not e.g.</span></div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;  <span class="comment">// vectors-of-vectors.</span></div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;  <span class="comment">// Trying to instantiate a StandardType&lt;T&gt; gives us a compiler error</span></div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;  <span class="comment">// where otherwise we would have had a runtime error.</span></div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;  <span class="comment">// Creating a StandardType&lt;T&gt; manually also saves our APIs from</span></div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;  <span class="comment">// having to do a bunch of automatic creations later.</span></div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;  <span class="comment">// This object will be free&#39;d before all non-blocking communications</span></div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;  <span class="comment">// complete, but the MPI standard for MPI_Type_free specifies &quot;Any</span></div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;  <span class="comment">// communication that is currently using this datatype will</span></div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;  <span class="comment">// complete normally.&quot; so we&#39;re cool.</span></div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;  <span class="keyword">typedef</span> decltype(<a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>.begin()-&gt;second.front()) ref_type;</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;  <span class="keyword">typedef</span> <span class="keyword">typename</span> std::remove_reference&lt;ref_type&gt;::type nonref_type;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;  StandardType&lt;typename std::remove_const&lt;nonref_type&gt;::type&gt; datatype;</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;  <span class="comment">// We&#39;ll grab a tag so we can overlap request sends and receives</span></div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;  <span class="comment">// without confusing one for the other</span></div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;  MessageTag tag = comm.get_unique_tag(1225);</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;  MapToVectors received_data;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;  <span class="comment">// Post all of the sends, non-blocking</span></div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; datapair : <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>)</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    {</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;      <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> destid = datapair.first;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;      libmesh_assert_less(destid, num_procs);</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;      <span class="keyword">auto</span> &amp; datum = datapair.second;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;      <span class="comment">// Just act on data if the user requested a send-to-self</span></div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;      <span class="keywordflow">if</span> (destid == comm.rank())</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;        act_on_data(destid, datum);</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;        {</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;          Request sendreq;</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;          comm.send(destid, datum, datatype, sendreq, tag);</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;          reqs.insert(reqs.end(), sendreq);</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;        }</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    }</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;  <span class="comment">// Post all of the receives, non-blocking</span></div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;  std::vector&lt;Request&gt; receive_reqs;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;  std::vector&lt;processor_id_type&gt; receive_procids;</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> proc_id = 0; proc_id &lt; num_procs; proc_id++)</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    <span class="keywordflow">if</span> (will_receive_from[proc_id] &amp;&amp; proc_id != comm.rank())</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;      {</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;        Request req;</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;        <span class="keyword">auto</span> &amp; incoming_data = received_data[proc_id];</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;        incoming_data.resize(will_receive_from[proc_id]);</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;        comm.receive(proc_id, incoming_data, datatype, req, tag);</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;        receive_reqs.push_back(req);</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        receive_procids.push_back(proc_id);</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;      }</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;  <span class="keywordflow">while</span>(receive_reqs.size())</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    {</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;      std::size_t completed = <a class="code" href="namespacelibMesh_1_1Parallel.html#aff47382fb119efc31a05639bd54f8ed6">waitany</a>(receive_reqs);</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;      <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> proc_id = receive_procids[completed];</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;      receive_reqs.erase(receive_reqs.begin() + completed);</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;      receive_procids.erase(receive_procids.begin() + completed);</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;      act_on_data(proc_id, received_data[proc_id]);</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;      received_data.erase(proc_id);</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    }</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;}</div><div class="ttc" id="namespacelibMesh_html_afebcb3616f8c81cda531dec404f2420d"><div class="ttname"><a href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">libMesh::processor_id_type</a></div><div class="ttdeci">uint8_t processor_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00099">id_types.h:99</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_aff47382fb119efc31a05639bd54f8ed6"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#aff47382fb119efc31a05639bd54f8ed6">libMesh::Parallel::waitany</a></div><div class="ttdeci">std::size_t waitany(std::vector&lt; Request &gt; &amp;r)</div><div class="ttdef"><b>Definition:</b> <a href="request_8C_source.html#l00219">request.C:219</a></div></div>
<div class="ttc" id="variant__filter__iterator_8h_html_a3464f722394258d66e04720e221f07ff"><div class="ttname"><a href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a></div><div class="ttdeci">IterBase * data</div><div class="ttdef"><b>Definition:</b> <a href="variant__filter__iterator_8h_source.html#l00337">variant_filter_iterator.h:337</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9e13ce6e3b8d973e2e2d947a57942588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e13ce6e3b8d973e2e2d947a57942588">&#9670;&nbsp;</a></span>push_parallel_vector_data() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MapToVectors , typename ActionFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Parallel::push_parallel_vector_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MapToVectors &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ActionFunctor &amp;&#160;</td>
          <td class="paramname"><em>act_on_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send and receive and act on vectors of data.</p>
<p>The <code>data</code> map is indexed by processor ids as keys, and for each processor id in the map there should be a vector of data to send.</p>
<p>Data which is received from other processors will be operated on by act_on_data(processor_id_type pid, const std::vector&lt;datum&gt; &amp; data);</p>
<p>No guarantee about operation ordering is made - this function will attempt to act on data in the order in which it is received.</p>
<p>All communication and actions are complete when this function returns. </p>

<p class="definition">Definition at line <a class="el" href="parallel__sync_8h_source.html#l00435">435</a> of file <a class="el" href="parallel__sync_8h_source.html">parallel_sync.h</a>.</p>

<p class="reference">References <a class="el" href="variant__filter__iterator_8h_source.html#l00337">data</a>, <a class="el" href="parallel__sync_8h_source.html#l00239">push_parallel_vector_data()</a>, and <a class="el" href="request_8C_source.html#l00213">wait()</a>.</p>
<div class="fragment"><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;{</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;  std::vector&lt;Request&gt; requests;</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#aef9703aa21aa121441db66d7ebdfa8a7">push_parallel_vector_data</a>(comm, <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>, requests, act_on_data);</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#aea5278a91928fa4f33b74aa0786f3592">wait</a>(requests);</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;}</div><div class="ttc" id="namespacelibMesh_1_1Parallel_html_aea5278a91928fa4f33b74aa0786f3592"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#aea5278a91928fa4f33b74aa0786f3592">libMesh::Parallel::wait</a></div><div class="ttdeci">void wait(std::vector&lt; Request &gt; &amp;r)</div><div class="ttdef"><b>Definition:</b> <a href="request_8C_source.html#l00213">request.C:213</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_aef9703aa21aa121441db66d7ebdfa8a7"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#aef9703aa21aa121441db66d7ebdfa8a7">libMesh::Parallel::push_parallel_vector_data</a></div><div class="ttdeci">void push_parallel_vector_data(const Communicator &amp;comm, const MapType&lt; processor_id_type, std::vector&lt; std::vector&lt; ValueType, A1 &gt;, A2 &gt;, ExtraTypes... &gt; &amp;data, ActionFunctor &amp;act_on_data)</div><div class="ttdef"><b>Definition:</b> <a href="parallel__sync_8h_source.html#l00454">parallel_sync.h:454</a></div></div>
<div class="ttc" id="variant__filter__iterator_8h_html_a3464f722394258d66e04720e221f07ff"><div class="ttname"><a href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a></div><div class="ttdeci">IterBase * data</div><div class="ttdef"><b>Definition:</b> <a href="variant__filter__iterator_8h_source.html#l00337">variant_filter_iterator.h:337</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a642969e3f24f42d7a2b02901c8690289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642969e3f24f42d7a2b02901c8690289">&#9670;&nbsp;</a></span>push_parallel_vector_data() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename, typename, typename ... &gt; class MapType, typename KeyType , typename ValueType , typename A1 , typename A2 , typename ... ExtraTypes, typename RequestContainer , typename ActionFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Parallel::push_parallel_vector_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MapType&lt; <a class="el" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a>, std::vector&lt; std::vector&lt; ValueType, A1 &gt;, A2 &gt;, ExtraTypes... &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RequestContainer &amp;&#160;</td>
          <td class="paramname"><em>reqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ActionFunctor &amp;&#160;</td>
          <td class="paramname"><em>act_on_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parallel__sync_8h_source.html#l00348">348</a> of file <a class="el" href="parallel__sync_8h_source.html">parallel_sync.h</a>.</p>

<p class="reference">References <a class="el" href="parallel__implementation_8h_source.html#l03092">libMesh::Parallel::Communicator::alltoall()</a>, <a class="el" href="communicator_8h_source.html#l00070">any_source</a>, <a class="el" href="variant__filter__iterator_8h_source.html#l00337">data</a>, <a class="el" href="communicator_8C_source.html#l00201">libMesh::Parallel::Communicator::get_unique_tag()</a>, <a class="el" href="parallel__implementation_8h_source.html#l00174">libMesh::Parallel::Communicator::probe()</a>, <a class="el" href="communicator_8h_source.html#l00173">libMesh::Parallel::Communicator::rank()</a>, <a class="el" href="parallel__implementation_8h_source.html#l00771">libMesh::Parallel::Communicator::receive()</a>, <a class="el" href="parallel__implementation_8h_source.html#l00261">libMesh::Parallel::Communicator::send()</a>, and <a class="el" href="communicator_8h_source.html#l00175">libMesh::Parallel::Communicator::size()</a>.</p>
<div class="fragment"><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;{</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;  libmesh_parallel_only(comm);</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;  <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> num_procs = comm.size();</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;  <span class="comment">// Size of vectors to send to each procesor</span></div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;  std::vector&lt;std::size_t&gt; will_send_to(num_procs, 0);</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;  <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> num_sends = 0;</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; datapair : <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>)</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    {</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;      <span class="comment">// Don&#39;t try to send anywhere that doesn&#39;t exist</span></div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;      libmesh_assert_less(datapair.first, num_procs);</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;      <span class="comment">// Don&#39;t give us empty vectors to send</span></div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;      libmesh_assert_greater(datapair.second.size(), 0);</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;      will_send_to[datapair.first] = datapair.second.size();</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;      num_sends++;</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    }</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;  <span class="comment">// Tell everyone about where everyone will send to</span></div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;  comm.alltoall(will_send_to);</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;  <span class="comment">// will_send_to now represents who we&#39;ll receive from</span></div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;  <span class="comment">// give it a good name</span></div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;  <span class="keyword">auto</span> &amp; will_receive_from = will_send_to;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;  <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> n_receives = 0;</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> proc_id = 0; proc_id &lt; num_procs; proc_id++)</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    <span class="keywordflow">if</span> (will_receive_from[proc_id])</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;      n_receives++;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;  <span class="comment">// We&#39;ll construct a datatype once for repeated use</span></div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;  StandardType&lt;ValueType&gt; datatype;</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;  <span class="comment">// We&#39;ll grab a tag so we can overlap request sends and receives</span></div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;  <span class="comment">// without confusing one for the other</span></div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;  MessageTag tag = comm.get_unique_tag(1225);</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;  <span class="comment">// Post all of the sends, non-blocking</span></div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; datapair : <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>)</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    {</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;      <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> destid = datapair.first;</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;      libmesh_assert_less(destid, num_procs);</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;      <span class="keyword">auto</span> &amp; datum = datapair.second;</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;      <span class="comment">// Just act on data if the user requested a send-to-self</span></div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;      <span class="keywordflow">if</span> (destid == comm.rank())</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;        {</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;          act_on_data(destid, datum);</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;          n_receives--;</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;        }</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;        {</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;          Request sendreq;</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;          comm.send(destid, datum, datatype, sendreq, tag);</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;          reqs.insert(reqs.end(), sendreq);</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;        }</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    }</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;  <span class="comment">// Post all of the receives.</span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;  <span class="comment">// Use blocking API here since we can&#39;t use the pre-sized</span></div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;  <span class="comment">// non-blocking APIs with this data type.</span></div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;  <span class="comment">// FIXME - implement Derek&#39;s API from #1684, switch to that!</span></div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> i = 0; i != n_receives; ++i)</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    {</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;      Status stat(comm.probe(<a class="code" href="namespacelibMesh_1_1Parallel.html#a981cb1019c5fd951755cf6e00caaa634">any_source</a>, tag));</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;      <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a></div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;        proc_id = cast_int&lt;processor_id_type&gt;(stat.source());</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;      std::vector&lt;std::vector&lt;ValueType,A1&gt;,A2&gt; received_data;</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;      comm.receive(proc_id, received_data, datatype, tag);</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;      act_on_data(proc_id, received_data);</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    }</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;}</div><div class="ttc" id="namespacelibMesh_1_1Parallel_html_a981cb1019c5fd951755cf6e00caaa634"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#a981cb1019c5fd951755cf6e00caaa634">libMesh::Parallel::any_source</a></div><div class="ttdeci">const unsigned int any_source</div><div class="ttdef"><b>Definition:</b> <a href="communicator_8h_source.html#l00070">communicator.h:70</a></div></div>
<div class="ttc" id="namespacelibMesh_html_afebcb3616f8c81cda531dec404f2420d"><div class="ttname"><a href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">libMesh::processor_id_type</a></div><div class="ttdeci">uint8_t processor_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00099">id_types.h:99</a></div></div>
<div class="ttc" id="variant__filter__iterator_8h_html_a3464f722394258d66e04720e221f07ff"><div class="ttname"><a href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a></div><div class="ttdeci">IterBase * data</div><div class="ttdef"><b>Definition:</b> <a href="variant__filter__iterator_8h_source.html#l00337">variant_filter_iterator.h:337</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6a387d9373b4f9fba21b87171d95ae62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a387d9373b4f9fba21b87171d95ae62">&#9670;&nbsp;</a></span>push_parallel_vector_data() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename, typename, typename ... &gt; class MapType, typename KeyType , typename ValueType , typename A1 , typename A2 , typename ... ExtraTypes, typename ActionFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Parallel::push_parallel_vector_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MapType&lt; <a class="el" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a>, std::vector&lt; std::vector&lt; ValueType, A1 &gt;, A2 &gt;, ExtraTypes... &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ActionFunctor &amp;&#160;</td>
          <td class="paramname"><em>act_on_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parallel__sync_8h_source.html#l00454">454</a> of file <a class="el" href="parallel__sync_8h_source.html">parallel_sync.h</a>.</p>

<p class="reference">References <a class="el" href="variant__filter__iterator_8h_source.html#l00337">data</a>, <a class="el" href="parallel__sync_8h_source.html#l00239">push_parallel_vector_data()</a>, and <a class="el" href="request_8C_source.html#l00213">wait()</a>.</p>
<div class="fragment"><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;{</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;  std::vector&lt;Request&gt; requests;</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#aef9703aa21aa121441db66d7ebdfa8a7">push_parallel_vector_data</a>(comm, <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>, requests, act_on_data);</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#aea5278a91928fa4f33b74aa0786f3592">wait</a>(requests);</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;}</div><div class="ttc" id="namespacelibMesh_1_1Parallel_html_aea5278a91928fa4f33b74aa0786f3592"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#aea5278a91928fa4f33b74aa0786f3592">libMesh::Parallel::wait</a></div><div class="ttdeci">void wait(std::vector&lt; Request &gt; &amp;r)</div><div class="ttdef"><b>Definition:</b> <a href="request_8C_source.html#l00213">request.C:213</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_aef9703aa21aa121441db66d7ebdfa8a7"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#aef9703aa21aa121441db66d7ebdfa8a7">libMesh::Parallel::push_parallel_vector_data</a></div><div class="ttdeci">void push_parallel_vector_data(const Communicator &amp;comm, const MapType&lt; processor_id_type, std::vector&lt; std::vector&lt; ValueType, A1 &gt;, A2 &gt;, ExtraTypes... &gt; &amp;data, ActionFunctor &amp;act_on_data)</div><div class="ttdef"><b>Definition:</b> <a href="parallel__sync_8h_source.html#l00454">parallel_sync.h:454</a></div></div>
<div class="ttc" id="variant__filter__iterator_8h_html_a3464f722394258d66e04720e221f07ff"><div class="ttname"><a href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a></div><div class="ttdeci">IterBase * data</div><div class="ttdef"><b>Definition:</b> <a href="variant__filter__iterator_8h_source.html#l00337">variant_filter_iterator.h:337</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9ed5f1c09ede99139461a86c8aff33ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed5f1c09ede99139461a86c8aff33ac">&#9670;&nbsp;</a></span>push_parallel_vector_data() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename, typename, typename ... &gt; class MapType, typename ValueType , typename A1 , typename A2 , typename ... ExtraTypes, typename RequestContainer , typename ActionFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Parallel::push_parallel_vector_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MapType&lt; <a class="el" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a>, std::vector&lt; std::vector&lt; ValueType, A1 &gt;, A2 &gt;, ExtraTypes... &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RequestContainer &amp;&#160;</td>
          <td class="paramname"><em>reqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ActionFunctor &amp;&#160;</td>
          <td class="paramname"><em>act_on_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parallel__sync_8h_source.html#l00348">348</a> of file <a class="el" href="parallel__sync_8h_source.html">parallel_sync.h</a>.</p>

<p class="reference">References <a class="el" href="parallel__implementation_8h_source.html#l03092">libMesh::Parallel::Communicator::alltoall()</a>, <a class="el" href="communicator_8h_source.html#l00070">any_source</a>, <a class="el" href="variant__filter__iterator_8h_source.html#l00337">data</a>, <a class="el" href="communicator_8C_source.html#l00201">libMesh::Parallel::Communicator::get_unique_tag()</a>, <a class="el" href="parallel__implementation_8h_source.html#l00174">libMesh::Parallel::Communicator::probe()</a>, <a class="el" href="communicator_8h_source.html#l00173">libMesh::Parallel::Communicator::rank()</a>, <a class="el" href="parallel__implementation_8h_source.html#l00771">libMesh::Parallel::Communicator::receive()</a>, <a class="el" href="parallel__implementation_8h_source.html#l00261">libMesh::Parallel::Communicator::send()</a>, and <a class="el" href="communicator_8h_source.html#l00175">libMesh::Parallel::Communicator::size()</a>.</p>
<div class="fragment"><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;{</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;  libmesh_parallel_only(comm);</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;  <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> num_procs = comm.size();</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;  <span class="comment">// Size of vectors to send to each procesor</span></div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;  std::vector&lt;std::size_t&gt; will_send_to(num_procs, 0);</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;  <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> num_sends = 0;</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; datapair : <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>)</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    {</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;      <span class="comment">// Don&#39;t try to send anywhere that doesn&#39;t exist</span></div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;      libmesh_assert_less(datapair.first, num_procs);</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;      <span class="comment">// Don&#39;t give us empty vectors to send</span></div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;      libmesh_assert_greater(datapair.second.size(), 0);</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;      will_send_to[datapair.first] = datapair.second.size();</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;      num_sends++;</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    }</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;  <span class="comment">// Tell everyone about where everyone will send to</span></div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;  comm.alltoall(will_send_to);</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;  <span class="comment">// will_send_to now represents who we&#39;ll receive from</span></div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;  <span class="comment">// give it a good name</span></div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;  <span class="keyword">auto</span> &amp; will_receive_from = will_send_to;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;  <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> n_receives = 0;</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> proc_id = 0; proc_id &lt; num_procs; proc_id++)</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    <span class="keywordflow">if</span> (will_receive_from[proc_id])</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;      n_receives++;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;  <span class="comment">// We&#39;ll construct a datatype once for repeated use</span></div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;  StandardType&lt;ValueType&gt; datatype;</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;  <span class="comment">// We&#39;ll grab a tag so we can overlap request sends and receives</span></div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;  <span class="comment">// without confusing one for the other</span></div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;  MessageTag tag = comm.get_unique_tag(1225);</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;  <span class="comment">// Post all of the sends, non-blocking</span></div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; datapair : <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>)</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    {</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;      <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> destid = datapair.first;</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;      libmesh_assert_less(destid, num_procs);</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;      <span class="keyword">auto</span> &amp; datum = datapair.second;</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;      <span class="comment">// Just act on data if the user requested a send-to-self</span></div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;      <span class="keywordflow">if</span> (destid == comm.rank())</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;        {</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;          act_on_data(destid, datum);</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;          n_receives--;</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;        }</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;        {</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;          Request sendreq;</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;          comm.send(destid, datum, datatype, sendreq, tag);</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;          reqs.insert(reqs.end(), sendreq);</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;        }</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    }</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;  <span class="comment">// Post all of the receives.</span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;  <span class="comment">// Use blocking API here since we can&#39;t use the pre-sized</span></div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;  <span class="comment">// non-blocking APIs with this data type.</span></div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;  <span class="comment">// FIXME - implement Derek&#39;s API from #1684, switch to that!</span></div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> i = 0; i != n_receives; ++i)</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    {</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;      Status stat(comm.probe(<a class="code" href="namespacelibMesh_1_1Parallel.html#a981cb1019c5fd951755cf6e00caaa634">any_source</a>, tag));</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;      <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a></div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;        proc_id = cast_int&lt;processor_id_type&gt;(stat.source());</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;      std::vector&lt;std::vector&lt;ValueType,A1&gt;,A2&gt; received_data;</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;      comm.receive(proc_id, received_data, datatype, tag);</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;      act_on_data(proc_id, received_data);</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    }</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;}</div><div class="ttc" id="namespacelibMesh_1_1Parallel_html_a981cb1019c5fd951755cf6e00caaa634"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#a981cb1019c5fd951755cf6e00caaa634">libMesh::Parallel::any_source</a></div><div class="ttdeci">const unsigned int any_source</div><div class="ttdef"><b>Definition:</b> <a href="communicator_8h_source.html#l00070">communicator.h:70</a></div></div>
<div class="ttc" id="namespacelibMesh_html_afebcb3616f8c81cda531dec404f2420d"><div class="ttname"><a href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">libMesh::processor_id_type</a></div><div class="ttdeci">uint8_t processor_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00099">id_types.h:99</a></div></div>
<div class="ttc" id="variant__filter__iterator_8h_html_a3464f722394258d66e04720e221f07ff"><div class="ttname"><a href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a></div><div class="ttdeci">IterBase * data</div><div class="ttdef"><b>Definition:</b> <a href="variant__filter__iterator_8h_source.html#l00337">variant_filter_iterator.h:337</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aef9703aa21aa121441db66d7ebdfa8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9703aa21aa121441db66d7ebdfa8a7">&#9670;&nbsp;</a></span>push_parallel_vector_data() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename, typename, typename ... &gt; class MapType, typename ValueType , typename A1 , typename A2 , typename ... ExtraTypes, typename ActionFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Parallel::push_parallel_vector_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MapType&lt; <a class="el" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a>, std::vector&lt; std::vector&lt; ValueType, A1 &gt;, A2 &gt;, ExtraTypes... &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ActionFunctor &amp;&#160;</td>
          <td class="paramname"><em>act_on_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parallel__sync_8h_source.html#l00454">454</a> of file <a class="el" href="parallel__sync_8h_source.html">parallel_sync.h</a>.</p>

<p class="reference">References <a class="el" href="variant__filter__iterator_8h_source.html#l00337">data</a>, <a class="el" href="parallel__sync_8h_source.html#l00239">push_parallel_vector_data()</a>, and <a class="el" href="request_8C_source.html#l00213">wait()</a>.</p>
<div class="fragment"><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;{</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;  std::vector&lt;Request&gt; requests;</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#aef9703aa21aa121441db66d7ebdfa8a7">push_parallel_vector_data</a>(comm, <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>, requests, act_on_data);</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#aea5278a91928fa4f33b74aa0786f3592">wait</a>(requests);</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;}</div><div class="ttc" id="namespacelibMesh_1_1Parallel_html_aea5278a91928fa4f33b74aa0786f3592"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#aea5278a91928fa4f33b74aa0786f3592">libMesh::Parallel::wait</a></div><div class="ttdeci">void wait(std::vector&lt; Request &gt; &amp;r)</div><div class="ttdef"><b>Definition:</b> <a href="request_8C_source.html#l00213">request.C:213</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_aef9703aa21aa121441db66d7ebdfa8a7"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#aef9703aa21aa121441db66d7ebdfa8a7">libMesh::Parallel::push_parallel_vector_data</a></div><div class="ttdeci">void push_parallel_vector_data(const Communicator &amp;comm, const MapType&lt; processor_id_type, std::vector&lt; std::vector&lt; ValueType, A1 &gt;, A2 &gt;, ExtraTypes... &gt; &amp;data, ActionFunctor &amp;act_on_data)</div><div class="ttdef"><b>Definition:</b> <a href="parallel__sync_8h_source.html#l00454">parallel_sync.h:454</a></div></div>
<div class="ttc" id="variant__filter__iterator_8h_html_a3464f722394258d66e04720e221f07ff"><div class="ttname"><a href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a></div><div class="ttdeci">IterBase * data</div><div class="ttdef"><b>Definition:</b> <a href="variant__filter__iterator_8h_source.html#l00337">variant_filter_iterator.h:337</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac7d4f06bb34625465942e6b8d10f135e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d4f06bb34625465942e6b8d10f135e">&#9670;&nbsp;</a></span>sync_dofobject_data_by_id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename SyncFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Parallel::sync_dofobject_data_by_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>range_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>range_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SyncFunctor &amp;&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classlibMesh_1_1Parallel_1_1Request.html">Request</a> data about a range of ghost dofobjects uniquely identified by their id. Fulfill requests with sync.gather_data(const std::vector&lt;dof_id_type&gt; &amp; ids, std::vector&lt;sync::datum&gt; &amp; data), by resizing and setting the values of the data vector. Respond to fulfillment with sync.act_on_data(const std::vector&lt;dof_id_type&gt; &amp; ids, std::vector&lt;sync::datum&gt; &amp; data) The user must define Parallel::StandardType&lt;sync::datum&gt; if sync::datum isn't a built-in type. </p>

<p class="definition">Definition at line <a class="el" href="parallel__ghost__sync_8h_source.html#l00336">336</a> of file <a class="el" href="parallel__ghost__sync_8h_source.html">parallel_ghost_sync.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="partitioner_8C_source.html#l00907">libMesh::Partitioner::_find_global_index_by_pid_map()</a>, <a class="el" href="mesh__tools_8C_source.html#l02259">libMesh::MeshTools::correct_node_proc_ids()</a>, <a class="el" href="mesh__refinement_8C_source.html#l00779">libMesh::MeshRefinement::make_coarsening_compatible()</a>, <a class="el" href="mesh__communication_8C_source.html#l01505">libMesh::MeshCommunication::make_elems_parallel_consistent()</a>, <a class="el" href="mesh__refinement_8C_source.html#l00751">libMesh::MeshRefinement::make_flags_parallel_consistent()</a>, <a class="el" href="mesh__communication_8C_source.html#l01481">libMesh::MeshCommunication::make_node_unique_ids_parallel_consistent()</a>, <a class="el" href="mesh__communication_8C_source.html#l01529">libMesh::MeshCommunication::make_p_levels_parallel_consistent()</a>, <a class="el" href="fem__system_8C_source.html#l01061">libMesh::FEMSystem::mesh_position_set()</a>, <a class="el" href="mesh__smoother__laplace_8C_source.html#l00045">libMesh::LaplaceMeshSmoother::smooth()</a>, and <a class="el" href="mesh__refinement_8C_source.html#l01701">libMesh::MeshRefinement::uniformly_coarsen()</a>.</p>
<div class="fragment"><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;{</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#ab0ccf736a24de62226fbaf331153735c">sync_dofobject_data_by_id</a>(comm, range_begin, range_end, SyncEverything(), sync);</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;}</div><div class="ttc" id="namespacelibMesh_1_1Parallel_html_ab0ccf736a24de62226fbaf331153735c"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#ab0ccf736a24de62226fbaf331153735c">libMesh::Parallel::sync_dofobject_data_by_id</a></div><div class="ttdeci">void sync_dofobject_data_by_id(const Communicator &amp;comm, const Iterator &amp;range_begin, const Iterator &amp;range_end, const DofObjectCheckFunctor &amp;dofobj_check, SyncFunctor &amp;sync)</div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00347">parallel_ghost_sync.h:347</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab0ccf736a24de62226fbaf331153735c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ccf736a24de62226fbaf331153735c">&#9670;&nbsp;</a></span>sync_dofobject_data_by_id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename DofObjectCheckFunctor , typename SyncFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Parallel::sync_dofobject_data_by_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>range_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>range_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DofObjectCheckFunctor &amp;&#160;</td>
          <td class="paramname"><em>dofobj_check</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SyncFunctor &amp;&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classlibMesh_1_1Parallel_1_1Request.html">Request</a> data about a range of ghost dofobjects uniquely identified by their id.</p>
<p>Elements within the range can be excluded from the request by returning false from dofobj_check(dof_object) </p>

<p class="definition">Definition at line <a class="el" href="parallel__ghost__sync_8h_source.html#l00347">347</a> of file <a class="el" href="parallel__ghost__sync_8h_source.html">parallel_ghost_sync.h</a>.</p>

<p class="reference">References <a class="el" href="variant__filter__iterator_8h_source.html#l00337">data</a>, <a class="el" href="dof__object_8h_source.html#l00655">libMesh::DofObject::id()</a>, <a class="el" href="dof__object_8h_source.html#l00358">libMesh::DofObject::invalid_processor_id</a>, <a class="el" href="dof__object_8h_source.html#l00717">libMesh::DofObject::processor_id()</a>, <a class="el" href="parallel__sync_8h_source.html#l00472">pull_parallel_vector_data()</a>, <a class="el" href="communicator_8h_source.html#l00173">libMesh::Parallel::Communicator::rank()</a>, and <a class="el" href="communicator_8h_source.html#l00175">libMesh::Parallel::Communicator::size()</a>.</p>
<div class="fragment"><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;{</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;  libmesh_parallel_only(comm);</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;  <span class="comment">// Count the objects to ask each processor about</span></div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;  std::vector&lt;dof_id_type&gt;</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;    ghost_objects_from_proc(comm.size(), 0);</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;  <span class="keywordflow">for</span> (Iterator it = range_begin; it != range_end; ++it)</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    {</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;      DofObject * obj = *it;</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;      libmesh_assert (obj);</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;      <span class="comment">// We may want to pass Elem* or Node* to the check function, not</span></div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;      <span class="comment">// just DofObject*</span></div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;      <span class="keywordflow">if</span> (!dofobj_check(*it))</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;      <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> obj_procid = obj-&gt;processor_id();</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;      <span class="keywordflow">if</span> (obj_procid != DofObject::invalid_processor_id)</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;        ghost_objects_from_proc[obj_procid]++;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    }</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;  <span class="comment">// Request sets to send to each processor</span></div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;  std::map&lt;processor_id_type, std::vector&lt;dof_id_type&gt;&gt;</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    requested_objs_id;</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;  <span class="comment">// We know how many objects live on each processor, so reserve()</span></div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;  <span class="comment">// space for each.</span></div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> p=0; p != comm.size(); ++p)</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    <span class="keywordflow">if</span> (p != comm.rank() &amp;&amp; ghost_objects_from_proc[p])</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;      requested_objs_id[p].reserve(ghost_objects_from_proc[p]);</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;  <span class="keywordflow">for</span> (Iterator it = range_begin; it != range_end; ++it)</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;    {</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;      DofObject * obj = *it;</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;      <span class="keywordflow">if</span> (!dofobj_check(*it))</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;      <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> obj_procid = obj-&gt;processor_id();</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;      <span class="keywordflow">if</span> (obj_procid == comm.rank() ||</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;          obj_procid == DofObject::invalid_processor_id)</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;      requested_objs_id[obj_procid].push_back(obj-&gt;id());</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    }</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;  <span class="keyword">auto</span> gather_functor =</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;    [&amp;sync]</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a>, <span class="keyword">const</span> std::vector&lt;dof_id_type&gt; &amp; ids,</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;     std::vector&lt;typename SyncFunctor::datum&gt; &amp; <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>)</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;    {</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;      sync.gather_data(ids, <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>);</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    };</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;  <span class="keyword">auto</span> action_functor =</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;    [&amp;sync]</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;    (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a>, <span class="keyword">const</span> std::vector&lt;dof_id_type&gt; &amp; ids,</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;     <span class="keyword">const</span> std::vector&lt;typename SyncFunctor::datum&gt; &amp; <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>)</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    {</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;      <span class="comment">// Let the user process the results</span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;      sync.act_on_data(ids, <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>);</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;    };</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;  <span class="comment">// Trade requests with other processors</span></div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;  <span class="keyword">typename</span> SyncFunctor::datum * ex = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#a21797734483c801c09fa26822455d989">pull_parallel_vector_data</a></div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    (comm, requested_objs_id, gather_functor, action_functor, ex);</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;}</div><div class="ttc" id="namespacelibMesh_html_afebcb3616f8c81cda531dec404f2420d"><div class="ttname"><a href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">libMesh::processor_id_type</a></div><div class="ttdeci">uint8_t processor_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00099">id_types.h:99</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_a21797734483c801c09fa26822455d989"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#a21797734483c801c09fa26822455d989">libMesh::Parallel::pull_parallel_vector_data</a></div><div class="ttdeci">void pull_parallel_vector_data(const Communicator &amp;comm, const MapToVectors &amp;queries, RequestContainer &amp;reqs, GatherFunctor &amp;gather_data, ActionFunctor &amp;act_on_data, const datum *example)</div><div class="ttdef"><b>Definition:</b> <a href="parallel__sync_8h_source.html#l00472">parallel_sync.h:472</a></div></div>
<div class="ttc" id="variant__filter__iterator_8h_html_a3464f722394258d66e04720e221f07ff"><div class="ttname"><a href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a></div><div class="ttdeci">IterBase * data</div><div class="ttdef"><b>Definition:</b> <a href="variant__filter__iterator_8h_source.html#l00337">variant_filter_iterator.h:337</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7dc7813882010b4a195a37dd579f1d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc7813882010b4a195a37dd579f1d03">&#9670;&nbsp;</a></span>sync_dofobject_data_by_xyz() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename DofObjType , typename SyncFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Parallel::sync_dofobject_data_by_xyz </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>range_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>range_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1LocationMap.html">LocationMap</a>&lt; DofObjType &gt; *&#160;</td>
          <td class="paramname"><em>location_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SyncFunctor &amp;&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classlibMesh_1_1Parallel_1_1Request.html">Request</a> data about a range of ghost nodes uniquely identified by their xyz location or a range of active ghost elements uniquely identified by their centroids' xyz location. Fulfill requests with sync.gather_data(const std::vector&lt;unsigned int&gt; &amp; ids, std::vector&lt;sync::datum&gt; &amp; data), by resizing and setting the values of the data vector. Respond to fulfillment with sync.act_on_data(const std::vector&lt;unsigned int&gt; &amp; ids, std::vector&lt;sync::datum&gt; &amp; data) The user must define Parallel::StandardType&lt;sync::datum&gt; if sync::datum isn't a built-in type. The user-provided location_map will be used and left unchanged if it is provided, or filled and cleared if it is empty. </p>

</div>
</div>
<a id="ab412d3606d51e5df080eab5795351901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab412d3606d51e5df080eab5795351901">&#9670;&nbsp;</a></span>sync_dofobject_data_by_xyz() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename DofObjType , typename SyncFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Parallel::sync_dofobject_data_by_xyz </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>range_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>range_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1LocationMap.html">LocationMap</a>&lt; DofObjType &gt; &amp;&#160;</td>
          <td class="paramname"><em>location_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SyncFunctor &amp;&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parallel__ghost__sync_8h_source.html#l00232">232</a> of file <a class="el" href="parallel__ghost__sync_8h_source.html">parallel_ghost_sync.h</a>.</p>

<p class="reference">References <a class="el" href="variant__filter__iterator_8h_source.html#l00337">data</a>, <a class="el" href="location__maps_8h_source.html#l00063">libMesh::LocationMap&lt; T &gt;::empty()</a>, <a class="el" href="location__maps_8C_source.html#l00111">libMesh::LocationMap&lt; T &gt;::find()</a>, <a class="el" href="dof__object_8h_source.html#l00358">libMesh::DofObject::invalid_processor_id</a>, <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html#ac82839410a5e87606482504ae269f31f">libMesh::Parallel::Communicator::max()</a>, <a class="el" href="classlibMesh_1_1LocationMap.html#a97d899a845dc5b4c7ba0dac21ea1fc96">libMesh::LocationMap&lt; T &gt;::point_of()</a>, <a class="el" href="parallel__sync_8h_source.html#l00472">pull_parallel_vector_data()</a>, <a class="el" href="communicator_8h_source.html#l00173">libMesh::Parallel::Communicator::rank()</a>, and <a class="el" href="communicator_8h_source.html#l00175">libMesh::Parallel::Communicator::size()</a>.</p>
<div class="fragment"><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;{</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;  libmesh_parallel_only(comm);</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;  <span class="comment">// We need a valid location_map</span></div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;  <span class="keywordtype">bool</span> need_map_update = (range_begin != range_end &amp;&amp; location_map.empty());</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;  comm.max(need_map_update);</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;  libmesh_assert(!need_map_update);</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;  <span class="comment">// Count the objects to ask each processor about</span></div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;  std::vector&lt;dof_id_type&gt;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    ghost_objects_from_proc(comm.size(), 0);</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;  <span class="keywordflow">for</span> (Iterator it = range_begin; it != range_end; ++it)</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    {</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;      DofObjType * obj = *it;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;      libmesh_assert (obj);</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;      <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> obj_procid = obj-&gt;processor_id();</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;      <span class="keywordflow">if</span> (obj_procid != DofObject::invalid_processor_id)</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;        ghost_objects_from_proc[obj_procid]++;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    }</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;  <span class="comment">// Request sets to send to each processor</span></div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;  std::map&lt;processor_id_type, std::vector&lt;Point&gt;&gt;</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;    requested_objs_pt;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;  <span class="comment">// Corresponding ids to keep track of</span></div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;  std::map&lt;processor_id_type, std::vector&lt;dof_id_type&gt;&gt;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    requested_objs_id;</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;  <span class="comment">// We know how many objects live on each processor, so reserve()</span></div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;  <span class="comment">// space for each.</span></div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> p=0; p != comm.size(); ++p)</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    <span class="keywordflow">if</span> (p != comm.rank() &amp;&amp; ghost_objects_from_proc[p])</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;      {</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;        requested_objs_pt[p].reserve(ghost_objects_from_proc[p]);</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;        requested_objs_id[p].reserve(ghost_objects_from_proc[p]);</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;      }</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;  <span class="keywordflow">for</span> (Iterator it = range_begin; it != range_end; ++it)</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    {</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;      DofObjType * obj = *it;</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;      <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> obj_procid = obj-&gt;processor_id();</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;      <span class="keywordflow">if</span> (obj_procid == comm.rank() ||</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;          obj_procid == DofObject::invalid_processor_id)</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;      Point p = location_map.point_of(*obj);</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;      requested_objs_pt[obj_procid].push_back(p);</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;      requested_objs_id[obj_procid].push_back(obj-&gt;id());</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    }</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;  <span class="keyword">auto</span> gather_functor =</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    [&amp;location_map, &amp;sync]</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> <span class="comment">/*pid*/</span>, <span class="keyword">const</span> std::vector&lt;Point&gt; &amp; pts,</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;     std::vector&lt;typename SyncFunctor::datum&gt; &amp; <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>)</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    {</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;      <span class="comment">// Find the local id of each requested object</span></div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;      std::size_t query_size = pts.size();</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;      std::vector&lt;dof_id_type&gt; query_id(query_size);</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;      <span class="keywordflow">for</span> (std::size_t i=0; i != query_size; ++i)</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;        {</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;          Point pt = pts[i];</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;          <span class="comment">// Look for this object in the multimap</span></div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;          DofObjType * obj = location_map.find(pt);</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;          <span class="comment">// We&#39;d better find every object we&#39;re asked for</span></div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;          libmesh_assert (obj);</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;          <span class="comment">// Return the object&#39;s correct processor id,</span></div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;          <span class="comment">// and our (correct if it&#39;s local) id for it.</span></div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;          query_id[i] = obj-&gt;id();</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;        }</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;      <span class="comment">// Gather whatever data the user wants</span></div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;      sync.gather_data(query_id, <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>);</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    };</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;  <span class="keyword">auto</span> action_functor =</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    [&amp;sync, &amp;requested_objs_id]</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;    (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> pid, <span class="keyword">const</span> std::vector&lt;Point&gt; &amp;,</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;     <span class="keyword">const</span> std::vector&lt;typename SyncFunctor::datum&gt; &amp; <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>)</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    {</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;      <span class="comment">// Let the user process the results</span></div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;      sync.act_on_data(requested_objs_id[pid], <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>);</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    };</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;  <span class="comment">// Trade requests with other processors</span></div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;  <span class="keyword">typename</span> SyncFunctor::datum * ex = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#a21797734483c801c09fa26822455d989">pull_parallel_vector_data</a></div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    (comm, requested_objs_pt, gather_functor, action_functor, ex);</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;}</div><div class="ttc" id="namespacelibMesh_html_afebcb3616f8c81cda531dec404f2420d"><div class="ttname"><a href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">libMesh::processor_id_type</a></div><div class="ttdeci">uint8_t processor_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00099">id_types.h:99</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_a21797734483c801c09fa26822455d989"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#a21797734483c801c09fa26822455d989">libMesh::Parallel::pull_parallel_vector_data</a></div><div class="ttdeci">void pull_parallel_vector_data(const Communicator &amp;comm, const MapToVectors &amp;queries, RequestContainer &amp;reqs, GatherFunctor &amp;gather_data, ActionFunctor &amp;act_on_data, const datum *example)</div><div class="ttdef"><b>Definition:</b> <a href="parallel__sync_8h_source.html#l00472">parallel_sync.h:472</a></div></div>
<div class="ttc" id="variant__filter__iterator_8h_html_a3464f722394258d66e04720e221f07ff"><div class="ttname"><a href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a></div><div class="ttdeci">IterBase * data</div><div class="ttdef"><b>Definition:</b> <a href="variant__filter__iterator_8h_source.html#l00337">variant_filter_iterator.h:337</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a29c79f0c66ce48d4b3801a77b139df3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c79f0c66ce48d4b3801a77b139df3b">&#9670;&nbsp;</a></span>sync_element_data_by_parent_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename SyncFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Parallel::sync_element_data_by_parent_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>range_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>range_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SyncFunctor &amp;&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classlibMesh_1_1Parallel_1_1Request.html">Request</a> data about a range of ghost elements uniquely identified by their parent id and which child they are. Fulfill requests with sync.gather_data(const std::vector&lt;unsigned int&gt; &amp; ids, std::vector&lt;sync::datum&gt; &amp; data), by resizing and setting the values of the data vector. Respond to fulfillment with sync.act_on_data(const std::vector&lt;unsigned int&gt; &amp; ids, std::vector&lt;sync::datum&gt; &amp; data) The user must define Parallel::StandardType&lt;sync::datum&gt; if sync::datum isn't a built-in type. </p>

<p class="definition">Definition at line <a class="el" href="parallel__ghost__sync_8h_source.html#l00429">429</a> of file <a class="el" href="parallel__ghost__sync_8h_source.html">parallel_ghost_sync.h</a>.</p>

<p class="reference">References <a class="el" href="elem_8h_source.html#l02390">libMesh::Elem::active()</a>, <a class="el" href="elem_8h_source.html#l02578">libMesh::Elem::child_ptr()</a>, <a class="el" href="variant__filter__iterator_8h_source.html#l00337">data</a>, <a class="el" href="elem_8h_source.html#l02428">libMesh::Elem::has_children()</a>, <a class="el" href="dof__object_8h_source.html#l00655">libMesh::DofObject::id()</a>, <a class="el" href="dof__object_8h_source.html#l00358">libMesh::DofObject::invalid_processor_id</a>, <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>, <a class="el" href="elem_8h_source.html#l02479">libMesh::Elem::parent()</a>, <a class="el" href="dof__object_8h_source.html#l00717">libMesh::DofObject::processor_id()</a>, <a class="el" href="parallel__sync_8h_source.html#l00472">pull_parallel_vector_data()</a>, and <a class="el" href="elem_8h_source.html#l02620">libMesh::Elem::which_child_am_i()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mesh__communication_8C_source.html#l01505">libMesh::MeshCommunication::make_elems_parallel_consistent()</a>.</p>
<div class="fragment"><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;{</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;  <span class="keyword">const</span> Communicator &amp; comm (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.comm());</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;  libmesh_parallel_only(comm);</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;  <span class="comment">// Count the objects to ask each processor about</span></div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;  std::vector&lt;dof_id_type&gt;</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;    ghost_objects_from_proc(comm.size(), 0);</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;  <span class="keywordflow">for</span> (Iterator it = range_begin; it != range_end; ++it)</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;    {</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;      Elem * elem = *it;</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;      <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> obj_procid = elem-&gt;processor_id();</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;      <span class="keywordflow">if</span> (obj_procid == comm.rank() ||</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;          obj_procid == DofObject::invalid_processor_id)</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;      <span class="keyword">const</span> Elem * parent = elem-&gt;parent();</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;      <span class="keywordflow">if</span> (!parent || !elem-&gt;active())</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;      ghost_objects_from_proc[obj_procid]++;</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    }</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;  <span class="comment">// Request sets to send to each processor</span></div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;  std::map&lt;processor_id_type, std::vector&lt;dof_id_type&gt;&gt;</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    requested_objs_id;</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;  std::map&lt;processor_id_type, std::vector&lt;std::pair&lt;dof_id_type,unsigned char&gt;&gt;&gt;</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;    requested_objs_parent_id_child_num;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;  <span class="comment">// We know how many objects live on each processor, so reserve()</span></div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;  <span class="comment">// space for each.</span></div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> p=0; p != comm.size(); ++p)</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;    <span class="keywordflow">if</span> (p != comm.rank() &amp;&amp; ghost_objects_from_proc[p])</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;      {</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;        requested_objs_id[p].reserve(ghost_objects_from_proc[p]);</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;        requested_objs_parent_id_child_num[p].reserve(ghost_objects_from_proc[p]);</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;      }</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;  <span class="keywordflow">for</span> (Iterator it = range_begin; it != range_end; ++it)</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    {</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;      Elem * elem = *it;</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;      <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> obj_procid = elem-&gt;processor_id();</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;      <span class="keywordflow">if</span> (obj_procid == comm.rank() ||</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;          obj_procid == DofObject::invalid_processor_id)</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;      <span class="keyword">const</span> Elem * parent = elem-&gt;parent();</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;      <span class="keywordflow">if</span> (!parent || !elem-&gt;active())</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;      requested_objs_id[obj_procid].push_back(elem-&gt;id());</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;      requested_objs_parent_id_child_num[obj_procid].push_back</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;        (std::make_pair</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;         (parent-&gt;id(),</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;          cast_int&lt;unsigned char&gt;</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;            (parent-&gt;which_child_am_i(elem))));</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;    }</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;  <span class="keyword">auto</span> gather_functor =</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;    [&amp;<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, &amp;sync]</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;    (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a>,</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;     <span class="keyword">const</span> std::vector&lt;std::pair&lt;dof_id_type, unsigned char&gt;&gt; &amp; parent_id_child_num,</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;     std::vector&lt;typename SyncFunctor::datum&gt; &amp; <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>)</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;    {</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;      <span class="comment">// Find the id of each requested element</span></div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;      std::size_t query_size = parent_id_child_num.size();</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;      std::vector&lt;dof_id_type&gt; query_id(query_size);</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;      <span class="keywordflow">for</span> (std::size_t i=0; i != query_size; ++i)</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;        {</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;          Elem &amp; parent = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.elem_ref(parent_id_child_num[i].first);</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;          libmesh_assert(parent.has_children());</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;          Elem * child = parent.child_ptr(parent_id_child_num[i].second);</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;          libmesh_assert(child);</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;          libmesh_assert(child-&gt;active());</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;          query_id[i] = child-&gt;id();</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;        }</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;      <span class="comment">// Gather whatever data the user wants</span></div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;      sync.gather_data(query_id, <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>);</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;    };</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;  <span class="keyword">auto</span> action_functor =</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;    [&amp;sync, &amp;requested_objs_id]</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;    (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> pid,</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;     <span class="keyword">const</span> std::vector&lt;std::pair&lt;dof_id_type, unsigned char&gt;&gt; &amp;,</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;     <span class="keyword">const</span> std::vector&lt;typename SyncFunctor::datum&gt; &amp; <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>)</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;    {</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;      <span class="comment">// Let the user process the results</span></div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;      sync.act_on_data(requested_objs_id[pid], <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>);</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;    };</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;  <span class="comment">// Trade requests with other processors</span></div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;  <span class="keyword">typename</span> SyncFunctor::datum * ex = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#a21797734483c801c09fa26822455d989">pull_parallel_vector_data</a></div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;    (comm, requested_objs_parent_id_child_num, gather_functor,</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;     action_functor, ex);</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;}</div><div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
<div class="ttc" id="namespacelibMesh_html_afebcb3616f8c81cda531dec404f2420d"><div class="ttname"><a href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">libMesh::processor_id_type</a></div><div class="ttdeci">uint8_t processor_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00099">id_types.h:99</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_a21797734483c801c09fa26822455d989"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#a21797734483c801c09fa26822455d989">libMesh::Parallel::pull_parallel_vector_data</a></div><div class="ttdeci">void pull_parallel_vector_data(const Communicator &amp;comm, const MapToVectors &amp;queries, RequestContainer &amp;reqs, GatherFunctor &amp;gather_data, ActionFunctor &amp;act_on_data, const datum *example)</div><div class="ttdef"><b>Definition:</b> <a href="parallel__sync_8h_source.html#l00472">parallel_sync.h:472</a></div></div>
<div class="ttc" id="variant__filter__iterator_8h_html_a3464f722394258d66e04720e221f07ff"><div class="ttname"><a href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a></div><div class="ttdeci">IterBase * data</div><div class="ttdef"><b>Definition:</b> <a href="variant__filter__iterator_8h_source.html#l00337">variant_filter_iterator.h:337</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a78a93cd4ce160f40c758f96e2cadbe25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a93cd4ce160f40c758f96e2cadbe25">&#9670;&nbsp;</a></span>sync_node_data_by_element_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElemCheckFunctor , typename NodeCheckFunctor , typename SyncFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Parallel::sync_node_data_by_element_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlibMesh_1_1MeshBase_1_1const__element__iterator.html">MeshBase::const_element_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>range_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlibMesh_1_1MeshBase_1_1const__element__iterator.html">MeshBase::const_element_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>range_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ElemCheckFunctor &amp;&#160;</td>
          <td class="paramname"><em>elem_check</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NodeCheckFunctor &amp;&#160;</td>
          <td class="paramname"><em>node_check</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SyncFunctor &amp;&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronize data about a range of ghost nodes uniquely identified by an element id and local node id, iterating until data is completely in sync and futher synchronization passes cause no changes.</p>
<p>Imagine a vertex surrounded by triangles, each on a different processor, with a ghosting policy that include only face neighbors and not point neighbors. Then the only way for authoritative information to trickle out from that vertex is by being passed along, one neighbor at a time, to processors who mostly don't even see the node's true owner!</p>
<p>Data for all nodes connected to elements in the given range of <em>element</em> iterators will be requested.</p>
<p>Elements can be further excluded from the request by returning false from element_check(elem)</p>
<p>Nodes can be further excluded from the request by returning false from node_check(elem, local_node_num)</p>
<p>Fulfill requests with sync.gather_data(const std::vector&lt;unsigned int&gt; &amp; ids, std::vector&lt;sync::datum&gt; &amp; data), by resizing and setting the values of the data vector. Respond to fulfillment with bool sync.act_on_data(const std::vector&lt;unsigned int&gt; &amp; ids, std::vector&lt;sync::datum&gt; &amp; data) and return true iff the response changed any data.</p>
<p>The user must define Parallel::StandardType&lt;sync::datum&gt; if sync::datum isn't a built-in type. </p>

<p class="definition">Definition at line <a class="el" href="parallel__ghost__sync_8h_source.html#l00752">752</a> of file <a class="el" href="parallel__ghost__sync_8h_source.html">parallel_ghost_sync.h</a>.</p>

<p class="reference">References <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>, and <a class="el" href="parallel__ghost__sync_8h_source.html#l00546">sync_node_data_by_element_id_once()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mesh__communication_8C_source.html#l01685">libMesh::MeshCommunication::make_new_node_proc_ids_parallel_consistent()</a>, <a class="el" href="mesh__communication_8C_source.html#l01452">libMesh::MeshCommunication::make_node_ids_parallel_consistent()</a>, and <a class="el" href="mesh__communication_8C_source.html#l01656">libMesh::MeshCommunication::make_node_proc_ids_parallel_consistent()</a>.</p>
<div class="fragment"><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;{</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;  libmesh_parallel_only(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.comm());</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;  <span class="keywordtype">bool</span> need_sync = <span class="keyword">false</span>;</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;  <span class="keywordflow">do</span></div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;    {</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;      need_sync =</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;        <a class="code" href="namespacelibMesh_1_1Parallel.html#a690437fd4e60ad2cedf64948c3f21519">sync_node_data_by_element_id_once</a></div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;          (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, range_begin, range_end, elem_check, node_check,</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;           sync);</div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;    } <span class="keywordflow">while</span> (need_sync);</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;}</div><div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_a690437fd4e60ad2cedf64948c3f21519"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#a690437fd4e60ad2cedf64948c3f21519">libMesh::Parallel::sync_node_data_by_element_id_once</a></div><div class="ttdeci">bool sync_node_data_by_element_id_once(MeshBase &amp;mesh, const MeshBase::const_element_iterator &amp;range_begin, const MeshBase::const_element_iterator &amp;range_end, const ElemCheckFunctor &amp;elem_check, const NodeCheckFunctor &amp;node_check, SyncFunctor &amp;sync)</div><div class="ttdef"><b>Definition:</b> <a href="parallel__ghost__sync_8h_source.html#l00546">parallel_ghost_sync.h:546</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a690437fd4e60ad2cedf64948c3f21519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a690437fd4e60ad2cedf64948c3f21519">&#9670;&nbsp;</a></span>sync_node_data_by_element_id_once()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElemCheckFunctor , typename NodeCheckFunctor , typename SyncFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool libMesh::Parallel::sync_node_data_by_element_id_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlibMesh_1_1MeshBase_1_1const__element__iterator.html">MeshBase::const_element_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>range_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlibMesh_1_1MeshBase_1_1const__element__iterator.html">MeshBase::const_element_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>range_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ElemCheckFunctor &amp;&#160;</td>
          <td class="paramname"><em>elem_check</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NodeCheckFunctor &amp;&#160;</td>
          <td class="paramname"><em>node_check</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SyncFunctor &amp;&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronize data about a range of ghost nodes uniquely identified by an element id and local node id, assuming a single synchronization pass is necessary.</p>
<p>Data for all nodes connected to elements in the given range of <em>element</em> iterators will be requested.</p>
<p>Elements can be further excluded from the request by returning false from element_check(elem)</p>
<p>Nodes can be further excluded from the request by returning false from node_check(elem, local_node_num)</p>
<p>Fulfill requests with sync.gather_data(const std::vector&lt;unsigned int&gt; &amp; ids, std::vector&lt;sync::datum&gt; &amp; data), by resizing and setting the values of the data vector. Respond to fulfillment with bool sync.act_on_data(const std::vector&lt;unsigned int&gt; &amp; ids, std::vector&lt;sync::datum&gt; &amp; data) and return true iff the response changed any data.</p>
<p>The user must define Parallel::StandardType&lt;sync::datum&gt; if sync::datum isn't a built-in type.</p>
<p>This method returns true iff the sync pass changed any data on any processor. </p>

<p class="definition">Definition at line <a class="el" href="parallel__ghost__sync_8h_source.html#l00546">546</a> of file <a class="el" href="parallel__ghost__sync_8h_source.html">parallel_ghost_sync.h</a>.</p>

<p class="reference">References <a class="el" href="simple__range_8h_source.html#l00057">libMesh::as_range()</a>, <a class="el" href="variant__filter__iterator_8h_source.html#l00337">data</a>, <a class="el" href="dof__object_8h_source.html#l00655">libMesh::DofObject::id()</a>, <a class="el" href="dof__object_8h_source.html#l00347">libMesh::DofObject::invalid_id</a>, <a class="el" href="dof__object_8h_source.html#l00358">libMesh::DofObject::invalid_processor_id</a>, <a class="el" href="mesh__communication_8C_source.html#l01245">mesh</a>, <a class="el" href="classlibMesh_1_1Elem.html#a3a1e00b1906b0f6cf0cc1760c9a7da1f">libMesh::Elem::n_nodes()</a>, <a class="el" href="elem_8h_source.html#l01979">libMesh::Elem::node_ref()</a>, <a class="el" href="dof__object_8h_source.html#l00717">libMesh::DofObject::processor_id()</a>, and <a class="el" href="parallel__sync_8h_source.html#l00472">pull_parallel_vector_data()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mesh__communication_8C_source.html#l01685">libMesh::MeshCommunication::make_new_node_proc_ids_parallel_consistent()</a>, and <a class="el" href="parallel__ghost__sync_8h_source.html#l00752">sync_node_data_by_element_id()</a>.</p>
<div class="fragment"><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;{</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;  <span class="keyword">const</span> Communicator &amp; comm (<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.comm());</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;  <span class="comment">// Count the objects to ask each processor about</span></div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;  std::vector&lt;dof_id_type&gt;</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;    ghost_objects_from_proc(comm.size(), 0);</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; elem : <a class="code" href="namespacelibMesh.html#a977361a82b7a9e7ad8e50ae1cae40d20">as_range</a>(range_begin, range_end))</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;    {</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;      libmesh_assert (elem);</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;      <span class="keywordflow">if</span> (!elem_check(elem))</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;      <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> proc_id = elem-&gt;processor_id();</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;      <span class="keywordtype">bool</span> i_have_elem =</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;        (proc_id == comm.rank() ||</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;         proc_id == DofObject::invalid_processor_id);</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;      <span class="keywordflow">if</span> (elem-&gt;active() &amp;&amp; i_have_elem)</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> n : elem-&gt;node_index_range())</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;        {</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;          <span class="keywordflow">if</span> (!node_check(elem, n))</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;          <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> node_pid =</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;            elem-&gt;node_ref(n).processor_id();</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;          <span class="keywordflow">if</span> (i_have_elem &amp;&amp; (node_pid == comm.rank()))</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;          <span class="keywordflow">if</span> (i_have_elem)</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;            {</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;              libmesh_assert_not_equal_to</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;                (node_pid, DofObject::invalid_processor_id);</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;              ghost_objects_from_proc[node_pid]++;</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;            }</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;          <span class="keywordflow">else</span></div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;            {</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;              <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> request_pid =</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;                (node_pid == DofObject::invalid_processor_id) ?</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;                 proc_id : node_pid;</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;              ghost_objects_from_proc[request_pid]++;</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;            }</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;        }</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;    }</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;  <span class="comment">// Now repeat that iteration, filling request sets this time.</span></div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;  <span class="comment">// Request sets to send to each processor</span></div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;  std::map&lt;processor_id_type, std::vector&lt;std::pair&lt;dof_id_type, unsigned char&gt;&gt;&gt;</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;    requested_objs_elem_id_node_num;</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;  <span class="comment">// We know how many objects live on each processor, so reserve()</span></div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;  <span class="comment">// space for each.</span></div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> p=0; p != comm.size(); ++p)</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;    <span class="keywordflow">if</span> (p != comm.rank() &amp;&amp; ghost_objects_from_proc[p])</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;      {</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;        requested_objs_elem_id_node_num[p].reserve(ghost_objects_from_proc[p]);</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;      }</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; elem : <a class="code" href="namespacelibMesh.html#a977361a82b7a9e7ad8e50ae1cae40d20">as_range</a>(range_begin, range_end))</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;    {</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;      libmesh_assert (elem);</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;      <span class="keywordflow">if</span> (!elem_check(elem))</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;      <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> proc_id = elem-&gt;processor_id();</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;      <span class="keywordtype">bool</span> i_have_elem =</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;        (proc_id == comm.rank() ||</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;         proc_id == DofObject::invalid_processor_id);</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;      <span class="keywordflow">if</span> (elem-&gt;active() &amp;&amp; i_have_elem)</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;      <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> elem_id = elem-&gt;id();</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> n : elem-&gt;node_index_range())</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;        {</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;          <span class="keywordflow">if</span> (!node_check(elem, n))</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;          <span class="keyword">const</span> Node &amp; node = elem-&gt;node_ref(n);</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;          <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> node_pid = node.processor_id();</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;          <span class="keywordflow">if</span> (i_have_elem &amp;&amp; (node_pid == comm.rank()))</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;          <span class="keywordflow">if</span> (i_have_elem)</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;            {</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;              libmesh_assert_not_equal_to</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;                (node_pid, DofObject::invalid_processor_id);</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;              requested_objs_elem_id_node_num[node_pid].push_back</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;                (std::make_pair</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;                 (elem_id,</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;                  cast_int&lt;unsigned char&gt;(n)));</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;            }</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;          <span class="keywordflow">else</span></div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;            {</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;              <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> request_pid =</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;                (node_pid == DofObject::invalid_processor_id) ?</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;                 proc_id : node_pid;</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;              requested_objs_elem_id_node_num[request_pid].push_back</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;                (std::make_pair</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;                 (elem_id,</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;                  cast_int&lt;unsigned char&gt;(n)));</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;            }</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;        }</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;    }</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;  <span class="keyword">auto</span> gather_functor =</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;    [&amp;<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, &amp;sync]</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;    (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a>,</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;     <span class="keyword">const</span> std::vector&lt;std::pair&lt;dof_id_type, unsigned char&gt;&gt; &amp; elem_id_node_num,</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;     std::vector&lt;typename SyncFunctor::datum&gt; &amp; <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>)</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;    {</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;      <span class="comment">// Find the id of each requested element</span></div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;      std::size_t request_size = elem_id_node_num.size();</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;      std::vector&lt;dof_id_type&gt; query_id(request_size);</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;      <span class="keywordflow">for</span> (std::size_t i=0; i != request_size; ++i)</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;        {</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;          <span class="comment">// We might now get queries about remote elements, in which</span></div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;          <span class="comment">// case we&#39;ll have to ignore them and wait for the query</span></div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;          <span class="comment">// answer to filter to the querier via another source.</span></div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;          <span class="keyword">const</span> Elem * elem = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.query_elem_ptr(elem_id_node_num[i].first);</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;          <span class="keywordflow">if</span> (elem)</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;            {</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = elem_id_node_num[i].second;</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;              libmesh_assert_less (n, elem-&gt;n_nodes());</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;              <span class="keyword">const</span> Node &amp; node = elem-&gt;node_ref(n);</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;              <span class="comment">// This isn&#39;t a safe assertion in the case where we&#39;re</span></div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;              <span class="comment">// syncing processor ids</span></div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;              <span class="comment">// libmesh_assert_equal_to (node-&gt;processor_id(), comm.rank());</span></div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;              query_id[i] = node.id();</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;            }</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;          <span class="keywordflow">else</span></div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;            query_id[i] = DofObject::invalid_id;</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;        }</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;      <span class="comment">// Gather whatever data the user wants</span></div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;      sync.gather_data(query_id, <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>);</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;    };</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;  <span class="keywordtype">bool</span> data_changed = <span class="keyword">false</span>;</div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;  <span class="keyword">auto</span> action_functor =</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;    [&amp;sync, &amp;<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>, &amp;requested_objs_elem_id_node_num, &amp;data_changed]</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;    (<a class="code" href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">processor_id_type</a> pid,</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;     <span class="keyword">const</span> std::vector&lt;std::pair&lt;dof_id_type, unsigned char&gt;&gt; &amp;,</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;     <span class="keyword">const</span> std::vector&lt;typename SyncFunctor::datum&gt; &amp; <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>)</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;    {</div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span> &amp; elem_id_node_num =</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;        requested_objs_elem_id_node_num[pid];</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;      <span class="keyword">const</span> std::size_t data_size = <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>.size();</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;      libmesh_assert_equal_to(elem_id_node_num.size(), data_size);</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;      std::vector&lt;dof_id_type&gt; requested_objs_id(<a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>.size());</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> i : IntRange&lt;std::size_t&gt;(0,data_size))</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;        {</div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;          <span class="keyword">const</span> Elem &amp; elem = <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>.elem_ref(elem_id_node_num[i].first);</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;          <span class="keyword">const</span> Node &amp; node = elem.node_ref(elem_id_node_num[i].second);</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;          requested_objs_id[i] = node.id();</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;        }</div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;</div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;      <span class="comment">// Let the user process the results.  If any of the results</span></div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;      <span class="comment">// were different than what the user expected, then we may</span></div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;      <span class="comment">// need to sync again just in case this processor has to</span></div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;      <span class="comment">// pass on the changes to yet another processor.</span></div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;      <span class="keywordflow">if</span> (sync.act_on_data(requested_objs_id, <a class="code" href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a>))</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;        data_changed = <span class="keyword">true</span>;</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;    };</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;  <span class="comment">// Trade requests with other processors</span></div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;  <span class="keyword">typename</span> SyncFunctor::datum * ex = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;  <a class="code" href="namespacelibMesh_1_1Parallel.html#a21797734483c801c09fa26822455d989">pull_parallel_vector_data</a></div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;    (comm, requested_objs_elem_id_node_num, gather_functor,</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;     action_functor, ex);</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;  comm.max(data_changed);</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;  <span class="keywordflow">return</span> data_changed;</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;}</div><div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01245">mesh_communication.C:1245</a></div></div>
<div class="ttc" id="namespacelibMesh_html_afebcb3616f8c81cda531dec404f2420d"><div class="ttname"><a href="namespacelibMesh.html#afebcb3616f8c81cda531dec404f2420d">libMesh::processor_id_type</a></div><div class="ttdeci">uint8_t processor_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00099">id_types.h:99</a></div></div>
<div class="ttc" id="namespacelibMesh_1_1Parallel_html_a21797734483c801c09fa26822455d989"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#a21797734483c801c09fa26822455d989">libMesh::Parallel::pull_parallel_vector_data</a></div><div class="ttdeci">void pull_parallel_vector_data(const Communicator &amp;comm, const MapToVectors &amp;queries, RequestContainer &amp;reqs, GatherFunctor &amp;gather_data, ActionFunctor &amp;act_on_data, const datum *example)</div><div class="ttdef"><b>Definition:</b> <a href="parallel__sync_8h_source.html#l00472">parallel_sync.h:472</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a977361a82b7a9e7ad8e50ae1cae40d20"><div class="ttname"><a href="namespacelibMesh.html#a977361a82b7a9e7ad8e50ae1cae40d20">libMesh::as_range</a></div><div class="ttdeci">SimpleRange&lt; I &gt; as_range(const std::pair&lt; I, I &gt; &amp;p)</div><div class="ttdef"><b>Definition:</b> <a href="simple__range_8h_source.html#l00057">simple_range.h:57</a></div></div>
<div class="ttc" id="variant__filter__iterator_8h_html_a3464f722394258d66e04720e221f07ff"><div class="ttname"><a href="variant__filter__iterator_8h.html#a3464f722394258d66e04720e221f07ff">data</a></div><div class="ttdeci">IterBase * data</div><div class="ttdef"><b>Definition:</b> <a href="variant__filter__iterator_8h_source.html#l00337">variant_filter_iterator.h:337</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00064">id_types.h:64</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6d0febfa97ceea582f719f62c437d146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0febfa97ceea582f719f62c437d146">&#9670;&nbsp;</a></span>unpack_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Context , typename buffertype , typename OutputIter , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Parallel::unpack_range </td>
          <td>(</td>
          <td class="paramtype">const typename std::vector&lt; buffertype &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Context *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>output_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decode a range of potentially-variable-size objects from a data array. </p>

<p class="reference">Referenced by <a class="el" href="parallel__implementation_8h_source.html#l03176">libMesh::Parallel::Communicator::allgather_packed_range()</a>, <a class="el" href="parallel__implementation_8h_source.html#l01672">libMesh::Parallel::Communicator::broadcast_packed_range()</a>, <a class="el" href="parallel__implementation_8h_source.html#l03143">libMesh::Parallel::Communicator::gather_packed_range()</a>, <a class="el" href="parallel__implementation_8h_source.html#l01060">libMesh::Parallel::Communicator::receive_packed_range()</a>, <a class="el" href="post__wait__unpack__buffer_8h_source.html#l00042">libMesh::Parallel::PostWaitUnpackBuffer&lt; Container, Context, OutputIter, T &gt;::run()</a>, and <a class="el" href="parallel__implementation_8h_source.html#l01876">libMesh::Parallel::Communicator::send_receive_packed_range()</a>.</p>

</div>
</div>
<a id="aa43a801737716802b40c784a6a13ad63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43a801737716802b40c784a6a13ad63">&#9670;&nbsp;</a></span>unpack_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Context , typename buffertype , typename OutputIter , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Parallel::unpack_range </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; buffertype &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Context *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&#160;</td>
          <td class="paramname"><em>out_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function for range unpacking </p>

<p class="definition">Definition at line <a class="el" href="packing_8h_source.html#l00194">194</a> of file <a class="el" href="packing_8h_source.html">packing.h</a>.</p>

<p class="reference">References <a class="el" href="classlibMesh_1_1Parallel_1_1Packing.html#a56f82b789dd6b6dda1c7e03f40bad578">libMesh::Parallel::Packing&lt; T &gt;::packed_size()</a>, and <a class="el" href="classlibMesh_1_1Parallel_1_1Packing.html#a43bbdaa33ac1326710d69248c51e7fb0">libMesh::Parallel::Packing&lt; T &gt;::unpack()</a>.</p>
<div class="fragment"><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;{</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;  <span class="comment">// Loop through the buffer and unpack each object, returning the</span></div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;  <span class="comment">// object pointer via the output iterator</span></div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;  <span class="keyword">typename</span> std::vector&lt;buffertype&gt;::const_iterator</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    next_object_start = buffer.begin();</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;  <span class="keywordflow">while</span> (next_object_start &lt; buffer.end())</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    {</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;      *out_iter++ = Parallel::Packing&lt;T&gt;::unpack(next_object_start, context);</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;      next_object_start +=</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        Parallel::Packing&lt;T&gt;::packed_size(next_object_start);</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    }</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;  <span class="comment">// We should have used up the exact amount of data in the buffer</span></div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;  libmesh_assert (next_object_start == buffer.end());</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a94da485af333624e0167bb84b9adaf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94da485af333624e0167bb84b9adaf84">&#9670;&nbsp;</a></span>wait() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1Parallel_1_1Status.html">Status</a> libMesh::Parallel::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1Parallel_1_1Request.html">Request</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wait for a non-blocking send or receive to finish </p>

<p class="definition">Definition at line <a class="el" href="request_8h_source.html#l00129">129</a> of file <a class="el" href="request_8h_source.html">request.h</a>.</p>

<p class="reference">References <a class="el" href="request_8C_source.html#l00121">libMesh::Parallel::Request::wait()</a>.</p>
<div class="fragment"><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;{ <span class="keywordflow">return</span> r.wait(); }</div></div><!-- fragment -->
</div>
</div>
<a id="aea5278a91928fa4f33b74aa0786f3592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea5278a91928fa4f33b74aa0786f3592">&#9670;&nbsp;</a></span>wait() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::Parallel::wait </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classlibMesh_1_1Parallel_1_1Request.html">Request</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for all non-blocking operations to finish </p>

<p class="definition">Definition at line <a class="el" href="request_8C_source.html#l00213">213</a> of file <a class="el" href="request_8C_source.html">request.C</a>.</p>

<p class="reference">Referenced by <a class="el" href="dof__map__constraints_8C_source.html#l02595">libMesh::DofMap::allgather_recursive_constraints()</a>, <a class="el" href="boundary__info_8C_source.html#l01779">libMesh::BoundaryInfo::build_node_list_from_side_list()</a>, <a class="el" href="mesh__tools_8C_source.html#l02259">libMesh::MeshTools::correct_node_proc_ids()</a>, <a class="el" href="mesh__refinement_8C_source.html#l00779">libMesh::MeshRefinement::make_coarsening_compatible()</a>, <a class="el" href="sparsity__pattern_8C_source.html#l00443">libMesh::SparsityPattern::Build::parallel_sync()</a>, <a class="el" href="parallel__sync_8h_source.html#l00472">pull_parallel_vector_data()</a>, <a class="el" href="parallel__sync_8h_source.html#l00435">push_parallel_vector_data()</a>, <a class="el" href="nemesis__io_8C_source.html#l00148">libMesh::Nemesis_IO::read()</a>, <a class="el" href="system__io_8C_source.html#l00811">libMesh::System::read_serialized_blocked_dof_objects()</a>, <a class="el" href="dof__map__constraints_8C_source.html#l03432">libMesh::DofMap::scatter_constraints()</a>, <a class="el" href="mesh__refinement_8C_source.html#l01701">libMesh::MeshRefinement::uniformly_coarsen()</a>, <a class="el" href="system__io_8C_source.html#l01815">libMesh::System::write_serialized_blocked_dof_objects()</a>, and <a class="el" href="xdr__io_8C_source.html#l00710">libMesh::XdrIO::write_serialized_nodes()</a>.</p>
<div class="fragment"><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;{</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;  <span class="keywordflow">for</span> (std::size_t i=0; i&lt;r.size(); i++)</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    r[i].<a class="code" href="namespacelibMesh_1_1Parallel.html#aea5278a91928fa4f33b74aa0786f3592">wait</a>();</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;}</div><div class="ttc" id="namespacelibMesh_1_1Parallel_html_aea5278a91928fa4f33b74aa0786f3592"><div class="ttname"><a href="namespacelibMesh_1_1Parallel.html#aea5278a91928fa4f33b74aa0786f3592">libMesh::Parallel::wait</a></div><div class="ttdeci">void wait(std::vector&lt; Request &gt; &amp;r)</div><div class="ttdef"><b>Definition:</b> <a href="request_8C_source.html#l00213">request.C:213</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aff47382fb119efc31a05639bd54f8ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff47382fb119efc31a05639bd54f8ed6">&#9670;&nbsp;</a></span>waitany()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t libMesh::Parallel::waitany </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classlibMesh_1_1Parallel_1_1Request.html">Request</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for at least one non-blocking operation to finish. Return the index of the request which completed. </p>

<p class="definition">Definition at line <a class="el" href="request_8C_source.html#l00219">219</a> of file <a class="el" href="request_8C_source.html">request.C</a>.</p>

<p class="reference">References <a class="el" href="request_8h_source.html#l00110">libMesh::Parallel::Request::_prior_request</a>, <a class="el" href="request_8h_source.html#l00080">libMesh::Parallel::Request::get()</a>, <a class="el" href="mesh__subdivision__support_8h_source.html#l00103">libMesh::MeshTools::Subdivision::next</a>, and <a class="el" href="request_8h_source.html#l00118">libMesh::Parallel::Request::post_wait_work</a>.</p>

<p class="reference">Referenced by <a class="el" href="parallel__sync_8h_source.html#l00472">pull_parallel_vector_data()</a>, and <a class="el" href="parallel__sync_8h_source.html#l00239">push_parallel_vector_data()</a>.</p>
<div class="fragment"><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;{</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;  libmesh_assert(!r.empty());</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;  <span class="keywordtype">int</span> index = 0;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;  <span class="keywordtype">int</span> r_size = cast_int&lt;int&gt;(r.size());</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;  std::vector&lt;request&gt; raw(r_size);</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i != r_size; ++i)</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    {</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;      Request * root = &amp;r[i];</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;      <span class="comment">// If we have prior requests, we need to complete the first one</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;      <span class="comment">// first</span></div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;      <span class="keywordflow">while</span> (root-&gt;_prior_request.get())</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;        root = root-&gt;_prior_request.get();</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;      raw[i] = *root-&gt;get();</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    }</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;  <span class="keywordtype">bool</span> only_priors_completed = <span class="keyword">false</span>;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;  Request * <a class="code" href="namespacelibMesh_1_1MeshTools_1_1Subdivision.html#a9ddda19838f9b54edff4cb8970e7363c">next</a>;</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;  <span class="keywordflow">do</span></div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;    {</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;<span class="preprocessor">#ifdef LIBMESH_HAVE_MPI</span></div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;      libmesh_call_mpi</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;        (MPI_Waitany(r_size, raw.data(), &amp;index, MPI_STATUS_IGNORE));</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;      Request * completed = &amp;r[index];</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;      <a class="code" href="namespacelibMesh_1_1MeshTools_1_1Subdivision.html#a9ddda19838f9b54edff4cb8970e7363c">next</a> = completed;</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;      <span class="comment">// If we completed a prior request, we&#39;re not really done yet,</span></div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;      <span class="comment">// so find the next in that line to try again.</span></div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;      <span class="keywordflow">while</span> (completed-&gt;_prior_request.get())</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;        {</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;          only_priors_completed = <span class="keyword">true</span>;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;          <a class="code" href="namespacelibMesh_1_1MeshTools_1_1Subdivision.html#a9ddda19838f9b54edff4cb8970e7363c">next</a> = completed;</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;          completed = completed-&gt;_prior_request.get();</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;        }</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;      <span class="comment">// Do any post-wait work for the completed request</span></div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;      <span class="keywordflow">if</span> (completed-&gt;post_wait_work)</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; item : completed-&gt;post_wait_work-&gt;first)</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;          {</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;            <span class="comment">// The user should never try to give us non-existent work or try</span></div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;            <span class="comment">// to wait() twice.</span></div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;            libmesh_assert (item);</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;            item-&gt;run();</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;            <span class="keyword">delete</span> item;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;            item = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;          }</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;      <a class="code" href="namespacelibMesh_1_1MeshTools_1_1Subdivision.html#a9ddda19838f9b54edff4cb8970e7363c">next</a>-&gt;_prior_request.reset(<span class="keyword">nullptr</span>);</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;      raw[index] = *<a class="code" href="namespacelibMesh_1_1MeshTools_1_1Subdivision.html#a9ddda19838f9b54edff4cb8970e7363c">next</a>-&gt;get();</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    } <span class="keywordflow">while</span>(only_priors_completed);</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;  <span class="keywordflow">return</span> index;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;}</div><div class="ttc" id="namespacelibMesh_1_1MeshTools_1_1Subdivision_html_a9ddda19838f9b54edff4cb8970e7363c"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools_1_1Subdivision.html#a9ddda19838f9b54edff4cb8970e7363c">libMesh::MeshTools::Subdivision::next</a></div><div class="ttdeci">static const unsigned int next[3]</div><div class="ttdef"><b>Definition:</b> <a href="mesh__subdivision__support_8h_source.html#l00103">mesh_subdivision_support.h:103</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a981cb1019c5fd951755cf6e00caaa634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981cb1019c5fd951755cf6e00caaa634">&#9670;&nbsp;</a></span>any_source</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int libMesh::Parallel::any_source</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">  <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(MPI_ANY_SOURCE)</div></div><!-- fragment --><p>Processor id meaning "Accept from any source" </p>

<p class="definition">Definition at line <a class="el" href="communicator_8h_source.html#l00070">70</a> of file <a class="el" href="communicator_8h_source.html">communicator.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="boundary__info_8C_source.html#l01779">libMesh::BoundaryInfo::build_node_list_from_side_list()</a>, <a class="el" href="mesh__refinement_8C_source.html#l00779">libMesh::MeshRefinement::make_coarsening_compatible()</a>, <a class="el" href="parallel__sync_8h_source.html#l00580">pull_parallel_vector_data()</a>, <a class="el" href="parallel__sync_8h_source.html#l00348">push_parallel_vector_data()</a>, <a class="el" href="nemesis__io_8C_source.html#l00148">libMesh::Nemesis_IO::read()</a>, <a class="el" href="system__io_8C_source.html#l00811">libMesh::System::read_serialized_blocked_dof_objects()</a>, <a class="el" href="mesh__refinement_8C_source.html#l01701">libMesh::MeshRefinement::uniformly_coarsen()</a>, and <a class="el" href="system__io_8C_source.html#l01815">libMesh::System::write_serialized_blocked_dof_objects()</a>.</p>

</div>
</div>
<a id="a0c0fd69f268eede17208c4c720ac19d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0fd69f268eede17208c4c720ac19d5">&#9670;&nbsp;</a></span>any_tag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlibMesh_1_1Parallel_1_1MessageTag.html">MessageTag</a> libMesh::Parallel::any_tag = <a class="el" href="classlibMesh_1_1Parallel_1_1MessageTag.html">MessageTag</a>(MPI_ANY_TAG)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default message tag ids </p>

<p class="definition">Definition at line <a class="el" href="message__tag_8h_source.html#l00115">115</a> of file <a class="el" href="message__tag_8h_source.html">message_tag.h</a>.</p>

</div>
</div>
<a id="a0c2f05e8c57da65fd46aaa24d0af4078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2f05e8c57da65fd46aaa24d0af4078">&#9670;&nbsp;</a></span>no_tag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlibMesh_1_1Parallel_1_1MessageTag.html">MessageTag</a> libMesh::Parallel::no_tag = <a class="el" href="classlibMesh_1_1Parallel_1_1MessageTag.html">MessageTag</a>(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="message__tag_8h_source.html#l00120">120</a> of file <a class="el" href="message__tag_8h_source.html">message_tag.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
generated by <a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a>
</small></address>
<!-- dynamic header stuff -->
<script type="text/javascript">
$(document).ready(function(){
  $(window).on('scroll',function() {
    var scrolltop = $(this).scrollTop();
    if(scrolltop >= 215) {
      $('#fixedbar').fadeIn(250);
    }
    else if(scrolltop <= 210) {
      $('#fixedbar').fadeOut(250);
    }
  });
});
</script>
<!-- Google Analytics stuff -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-24978333-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
