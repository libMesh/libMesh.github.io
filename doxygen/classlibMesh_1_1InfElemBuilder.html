<!-- HTML header for doxygen -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libMesh: libMesh::InfElemBuilder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="../styles.css" rel="stylesheet" type="text/css" />
<link href="doxygen_stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <nav id="fixedbar">
    <ul id="fixednav">
      <li><a href="../index.html">Home</a></li>
      <li><a href="../support.html">About Us</a></li>
      <li><a href="../publications.html">Publications</a></li>
      <li><a href="../developers.html">Developers</a></li>
      <li><a href="../installation.html">Installation</a></li>
      <li><a href="../examples.html">Examples</a></li>
      <li><a href="../doxygen/index.html">Documentation</a></li>
    </ul>
  </nav>
  <div id="w">
    <header id="logo"><a href="index.html"><span id="logobg">SomeWebsiteLogo</span></a></header>
    <nav id="navigation">
      <ul>
        <li><a href="../index.html">Home</a></li>
        <li><a href="../support.html">About Us</a></li>
        <li><a href="../publications.html">Publications</a></li>
        <li><a href="../developers.html">Developers</a></li>
        <li><a href="../installation.html">Installation</a></li>
        <li><a href="../examples.html">Examples</a></li>
        <li><a href="../doxygen/index.html">Documentation</a></li>
      </ul>
    </nav>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- <\!--BEGIN TITLEAREA-\-> -->
<!-- <div id="titlearea"> -->
<!-- <table cellspacing="0" cellpadding="0"> -->
<!--  <tbody> -->
<!--  <tr style="height: 56px;"> -->
<!--   <\!--BEGIN PROJECT_LOGO-\-> -->
<!--   <td id="projectlogo"><img alt="Logo" src=""/></td> -->
<!--   <\!--END PROJECT_LOGO-\-> -->
<!--   <\!--BEGIN PROJECT_NAME-\-> -->
<!--   <td style="padding-left: 0.5em;"> -->
<!--    <div id="projectname">libMesh -->
<!--    <\!--BEGIN PROJECT_NUMBER-\->&#160;<span id="projectnumber"></span><\!--END PROJECT_NUMBER-\-> -->
<!--    </div> -->
<!--    <\!--BEGIN PROJECT_BRIEF-\-><div id="projectbrief"></div><\!--END PROJECT_BRIEF-\-> -->
<!--   </td> -->
<!--   <\!--END PROJECT_NAME-\-> -->
<!--   <\!--BEGIN !PROJECT_NAME-\-> -->
<!--    <\!--BEGIN PROJECT_BRIEF-\-> -->
<!--     <td style="padding-left: 0.5em;"> -->
<!--     <div id="projectbrief"></div> -->
<!--     </td> -->
<!--    <\!--END PROJECT_BRIEF-\-> -->
<!--   <\!--END !PROJECT_NAME-\-> -->
<!--   <\!--BEGIN DISABLE_INDEX-\-> -->
<!--    <\!--BEGIN SEARCHENGINE-\-> -->
<!--    <td></td> -->
<!--    <\!--END SEARCHENGINE-\-> -->
<!--   <\!--END DISABLE_INDEX-\-> -->
<!--  </tr> -->
<!--  </tbody> -->
<!-- </table> -->
<!-- </div> -->
<!-- <\!--END TITLEAREA-\-> -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibMesh.html">libMesh</a></li><li class="navelem"><a class="el" href="classlibMesh_1_1InfElemBuilder.html">InfElemBuilder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classlibMesh_1_1InfElemBuilder-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libMesh::InfElemBuilder Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="inf__elem__builder_8h_source.html">inf_elem_builder.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acf45bfe5ace01174cb8acfb54328a367"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; bool, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1InfElemBuilder.html#acf45bfe5ace01174cb8acfb54328a367">InfElemOriginValue</a></td></tr>
<tr class="separator:acf45bfe5ace01174cb8acfb54328a367"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a67a807ba18b3d7ab90eac08227e66669"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1InfElemBuilder.html#a67a807ba18b3d7ab90eac08227e66669">InfElemBuilder</a> (<a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;<a class="el" href="mesh__tools_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>)</td></tr>
<tr class="separator:a67a807ba18b3d7ab90eac08227e66669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bf21d86621176b3497f089bef8a17a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibMesh_1_1Point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1InfElemBuilder.html#ac6bf21d86621176b3497f089bef8a17a">build_inf_elem</a> (const bool be_verbose=false)</td></tr>
<tr class="separator:ac6bf21d86621176b3497f089bef8a17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab393fac04e51979e664993bdf49926e9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibMesh_1_1Point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1InfElemBuilder.html#ab393fac04e51979e664993bdf49926e9">build_inf_elem</a> (const <a class="el" href="classlibMesh_1_1InfElemBuilder.html#acf45bfe5ace01174cb8acfb54328a367">InfElemOriginValue</a> &amp;origin_x, const <a class="el" href="classlibMesh_1_1InfElemBuilder.html#acf45bfe5ace01174cb8acfb54328a367">InfElemOriginValue</a> &amp;origin_y, const <a class="el" href="classlibMesh_1_1InfElemBuilder.html#acf45bfe5ace01174cb8acfb54328a367">InfElemOriginValue</a> &amp;origin_z, const bool x_sym=false, const bool y_sym=false, const bool z_sym=false, const bool be_verbose=false, std::vector&lt; const <a class="el" href="classlibMesh_1_1Node.html">Node</a> * &gt; *inner_boundary_nodes=<a class="el" href="libmesh__nullptr_8h.html#ad10985637963b309cf2bf815e508438d">libmesh_nullptr</a>)</td></tr>
<tr class="separator:ab393fac04e51979e664993bdf49926e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:abfe5b4ac765578c4b9e0850f7c269647"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1InfElemBuilder.html#abfe5b4ac765578c4b9e0850f7c269647">build_inf_elem</a> (const <a class="el" href="classlibMesh_1_1Point.html">Point</a> &amp;origin, const bool x_sym=false, const bool y_sym=false, const bool z_sym=false, const bool be_verbose=false, std::set&lt; std::pair&lt; <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a>, unsigned int &gt; &gt; *inner_faces=<a class="el" href="libmesh__nullptr_8h.html#ad10985637963b309cf2bf815e508438d">libmesh_nullptr</a>)</td></tr>
<tr class="separator:abfe5b4ac765578c4b9e0850f7c269647"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:afbdff790a0e4a9a08c06e178a4d585f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a></td></tr>
<tr class="separator:afbdff790a0e4a9a08c06e178a4d585f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is used to build infinite elements on top of an existing mesh. It only makes sense to use this if LIBMESH_ENABLE_INFINITE_ELEMENTS is true.</p>
<dl class="section author"><dt>Author</dt><dd>Daniel Dreyer </dd>
<dd>
John W. Peterson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2004 </dd></dl>

<p>Definition at line <a class="el" href="inf__elem__builder_8h_source.html#l00053">53</a> of file <a class="el" href="inf__elem__builder_8h_source.html">inf_elem_builder.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="acf45bfe5ace01174cb8acfb54328a367"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;bool, double&gt; <a class="el" href="classlibMesh_1_1InfElemBuilder.html#acf45bfe5ace01174cb8acfb54328a367">libMesh::InfElemBuilder::InfElemOriginValue</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Useful typedef </p>

<p>Definition at line <a class="el" href="inf__elem__builder_8h_source.html#l00065">65</a> of file <a class="el" href="inf__elem__builder_8h_source.html">inf_elem_builder.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a67a807ba18b3d7ab90eac08227e66669"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::InfElemBuilder::InfElemBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. </p>

<p>Definition at line <a class="el" href="inf__elem__builder_8h_source.html#l00060">60</a> of file <a class="el" href="inf__elem__builder_8h_source.html">inf_elem_builder.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;: <a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>(<a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a>) {}</div><div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l01264">mesh_communication.C:1264</a></div></div>
<div class="ttc" id="classlibMesh_1_1InfElemBuilder_html_afbdff790a0e4a9a08c06e178a4d585f5"><div class="ttname"><a href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">libMesh::InfElemBuilder::_mesh</a></div><div class="ttdeci">MeshBase &amp; _mesh</div><div class="ttdef"><b>Definition:</b> <a href="inf__elem__builder_8h_source.html#l00127">inf_elem_builder.h:127</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac6bf21d86621176b3497f089bef8a17a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlibMesh_1_1Point.html">Point</a> libMesh::InfElemBuilder::build_inf_elem </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>be_verbose</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build infinite elements atop a volume-based mesh, determine origin automatically. Also returns the origin as a <code>const</code> <code><a class="el" href="classlibMesh_1_1Point.html" title="A geometric point in (x,y,z) space. ">Point</a></code> to make it more obvious that the origin should not change after the infinite elements have been built. When symmetry planes are present, use the version with optional symmetry switches. The flag <code>be_verbose</code> enables some diagnostic output. </p>

<p>Definition at line <a class="el" href="inf__elem__builder_8C_source.html#l00040">40</a> of file <a class="el" href="inf__elem__builder_8C_source.html">inf_elem_builder.C</a>.</p>

<p>References <a class="el" href="inf__elem__builder_8h_source.html#l00127">_mesh</a>, <a class="el" href="mesh__tools_8C_source.html#l00358">libMesh::MeshTools::bounding_box()</a>, <a class="el" href="libmesh__common_8h_source.html#l00241">libMesh::out</a>, <a class="el" href="mesh__base_8C_source.html#l00174">libMesh::MeshBase::prepare_for_use()</a>, <a class="el" href="parallel__object_8h_source.html#l00099">libMesh::ParallelObject::processor_id()</a>, and <a class="el" href="type__vector_8C_source.html#l00092">libMesh::TypeVector&lt; T &gt;::write_unformatted()</a>.</p>

<p>Referenced by <a class="el" href="inf__elem__builder_8C_source.html#l00081">build_inf_elem()</a>.</p>
<div class="fragment"><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;{</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  <span class="comment">// determine origin automatically,</span></div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;  <span class="comment">// works only if the mesh has no symmetry planes.</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;  <span class="keyword">const</span> MeshTools::BoundingBox b_box = <a class="code" href="namespacelibMesh_1_1MeshTools.html#ab099ca10b8e0521017c6d28644b88135">MeshTools::bounding_box</a>(<a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>);</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;  Point origin = (b_box.first + b_box.second) / 2;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;  <span class="keywordflow">if</span> (be_verbose &amp;&amp; <a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1ParallelObject.html#ae1e7d1a1118f63d9889a761c27433bbc">processor_id</a>() == 0)</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    {</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;      <a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> &lt;&lt; <span class="stringliteral">&quot; Determined origin for Infinite Elements:&quot;</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;                   &lt;&lt; std::endl</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;                   &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;      origin.write_unformatted(<a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a>);</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;      <a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> &lt;&lt; std::endl;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    }</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  <span class="comment">// Call the protected implementation function with the</span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  <span class="comment">// automatically determined origin.</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1InfElemBuilder.html#ac6bf21d86621176b3497f089bef8a17a">build_inf_elem</a>(origin, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, be_verbose);</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  <span class="comment">// when finished with building the Ifems,</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;  <span class="comment">// it remains to prepare the mesh for use:</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  <span class="comment">// find neighbors (again), partition (if needed)...</span></div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a61ce1c1cdddaa68acd35c7fa49a8a45e">prepare_for_use</a> (<span class="comment">/*skip_renumber =*/</span> <span class="keyword">false</span>);</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  <span class="keywordflow">return</span> origin;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;}</div><div class="ttc" id="namespacelibMesh_1_1MeshTools_html_ab099ca10b8e0521017c6d28644b88135"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#ab099ca10b8e0521017c6d28644b88135">libMesh::MeshTools::bounding_box</a></div><div class="ttdeci">BoundingBox bounding_box(const MeshBase &amp;mesh)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00358">mesh_tools.C:358</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a61ce1c1cdddaa68acd35c7fa49a8a45e"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a61ce1c1cdddaa68acd35c7fa49a8a45e">libMesh::MeshBase::prepare_for_use</a></div><div class="ttdeci">void prepare_for_use(const bool skip_renumber_nodes_and_elements=false, const bool skip_find_neighbors=false)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8C_source.html#l00174">mesh_base.C:174</a></div></div>
<div class="ttc" id="classlibMesh_1_1InfElemBuilder_html_ac6bf21d86621176b3497f089bef8a17a"><div class="ttname"><a href="classlibMesh_1_1InfElemBuilder.html#ac6bf21d86621176b3497f089bef8a17a">libMesh::InfElemBuilder::build_inf_elem</a></div><div class="ttdeci">const Point build_inf_elem(const bool be_verbose=false)</div><div class="ttdef"><b>Definition:</b> <a href="inf__elem__builder_8C_source.html#l00040">inf_elem_builder.C:40</a></div></div>
<div class="ttc" id="classlibMesh_1_1InfElemBuilder_html_afbdff790a0e4a9a08c06e178a4d585f5"><div class="ttname"><a href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">libMesh::InfElemBuilder::_mesh</a></div><div class="ttdeci">MeshBase &amp; _mesh</div><div class="ttdef"><b>Definition:</b> <a href="inf__elem__builder_8h_source.html#l00127">inf_elem_builder.h:127</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a63e3c3158308e2184c12b55ab9ea9a35"><div class="ttname"><a href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a></div><div class="ttdeci">OStreamProxy out(std::cout)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00241">libmesh_common.h:241</a></div></div>
<div class="ttc" id="classlibMesh_1_1ParallelObject_html_ae1e7d1a1118f63d9889a761c27433bbc"><div class="ttname"><a href="classlibMesh_1_1ParallelObject.html#ae1e7d1a1118f63d9889a761c27433bbc">libMesh::ParallelObject::processor_id</a></div><div class="ttdeci">processor_id_type processor_id() const </div><div class="ttdef"><b>Definition:</b> <a href="parallel__object_8h_source.html#l00099">parallel_object.h:99</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab393fac04e51979e664993bdf49926e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlibMesh_1_1Point.html">Point</a> libMesh::InfElemBuilder::build_inf_elem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1InfElemBuilder.html#acf45bfe5ace01174cb8acfb54328a367">InfElemOriginValue</a> &amp;&#160;</td>
          <td class="paramname"><em>origin_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1InfElemBuilder.html#acf45bfe5ace01174cb8acfb54328a367">InfElemOriginValue</a> &amp;&#160;</td>
          <td class="paramname"><em>origin_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1InfElemBuilder.html#acf45bfe5ace01174cb8acfb54328a367">InfElemOriginValue</a> &amp;&#160;</td>
          <td class="paramname"><em>origin_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>x_sym</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>y_sym</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>z_sym</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>be_verbose</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="classlibMesh_1_1Node.html">Node</a> * &gt; *&#160;</td>
          <td class="paramname"><em>inner_boundary_nodes</em> = <code><a class="el" href="libmesh__nullptr_8h.html#ad10985637963b309cf2bf815e508438d">libmesh_nullptr</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the origin of the infinite elements. Builds infinite elements atop a volume-based mesh. Finds all faces on the outer boundary and build infinite elements on them. Using the <code>InfElemOriginValue</code> the user can prescribe only selected origin coordinates. The remaining coordinates are computed from the center of the bounding box of the mesh.</dd></dl>
<p>During the search for faces on which infinite elements are built, <em>interior</em> faces that are not on symmetry planes are found, too. When an (optional) pointer to <code>inner_boundary_nodes</code> is provided, then this vector will be filled with the nodes that lie on the inner boundary.</p>
<p>Faces which lie in at least one symmetry plane are skipped. The three optional booleans <code>x_sym</code>, <code>y_sym</code>, <code>z_sym</code> indicate symmetry planes (through the origin, obviously) perpendicular to the <code>x</code>, <code>y</code> and <code>z</code> direction, respectively. The flag <code>be_verbose</code> enables some diagnostic output. </p>

<p>Definition at line <a class="el" href="inf__elem__builder_8C_source.html#l00081">81</a> of file <a class="el" href="inf__elem__builder_8C_source.html">inf_elem_builder.C</a>.</p>

<p>References <a class="el" href="inf__elem__builder_8h_source.html#l00127">_mesh</a>, <a class="el" href="mesh__tools_8C_source.html#l00358">libMesh::MeshTools::bounding_box()</a>, <a class="el" href="inf__elem__builder_8C_source.html#l00040">build_inf_elem()</a>, <a class="el" href="classlibMesh_1_1Elem.html#ab0a351f621dd01e540718ffc25bb2618">libMesh::Elem::build_side_ptr()</a>, <a class="el" href="mesh__base_8h_source.html#l00453">libMesh::MeshBase::elem_ref()</a>, <a class="el" href="libmesh__nullptr_8h.html#ad10985637963b309cf2bf815e508438d">libmesh_nullptr</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#ac83917705d802d1c29b9dbf050f73ed4">libMesh::MeshBase::node_ptr()</a>, <a class="el" href="libmesh__common_8h_source.html#l00241">libMesh::out</a>, <a class="el" href="mesh__base_8C_source.html#l00174">libMesh::MeshBase::prepare_for_use()</a>, <a class="el" href="mesh__base_8C_source.html#l00446">libMesh::MeshBase::print_info()</a>, <a class="el" href="xdr__io_8C_source.html#l00049">side</a>, and <a class="el" href="type__vector_8C_source.html#l00092">libMesh::TypeVector&lt; T &gt;::write_unformatted()</a>.</p>
<div class="fragment"><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;{</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;  START_LOG(<span class="stringliteral">&quot;build_inf_elem()&quot;</span>, <span class="stringliteral">&quot;InfElemBuilder&quot;</span>);</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;  <span class="comment">// first determine the origin of the</span></div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;  <span class="comment">// infinite elements.  For this, the</span></div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;  <span class="comment">// origin defaults to the given values,</span></div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;  <span class="comment">// and may be overridden when the user</span></div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  <span class="comment">// provided values</span></div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  Point origin(origin_x.second, origin_y.second, origin_z.second);</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  <span class="comment">// when only _one_ of the origin coordinates is _not_</span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;  <span class="comment">// given, we have to determine it on our own</span></div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  <span class="keywordflow">if</span> ( !origin_x.first || !origin_y.first || !origin_z.first)</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    {</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;      <span class="comment">// determine origin</span></div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;      <span class="keyword">const</span> MeshTools::BoundingBox b_box = <a class="code" href="namespacelibMesh_1_1MeshTools.html#ab099ca10b8e0521017c6d28644b88135">MeshTools::bounding_box</a>(<a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>);</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;      <span class="keyword">const</span> Point auto_origin = (b_box.first+b_box.second)/2;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;      <span class="comment">// override default values, if necessary</span></div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;      <span class="keywordflow">if</span> (!origin_x.first)</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        origin(0) = auto_origin(0);</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;      <span class="keywordflow">if</span> (!origin_y.first)</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        origin(1) = auto_origin(1);</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;      <span class="keywordflow">if</span> (!origin_z.first)</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        origin(2) = auto_origin(2);</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;      <span class="keywordflow">if</span> (be_verbose)</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        {</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;          <a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> &lt;&lt; <span class="stringliteral">&quot; Origin for Infinite Elements:&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;          <span class="keywordflow">if</span> (!origin_x.first)</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;            <a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> &lt;&lt; <span class="stringliteral">&quot;  determined x-coordinate&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;          <span class="keywordflow">if</span> (!origin_y.first)</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;            <a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> &lt;&lt; <span class="stringliteral">&quot;  determined y-coordinate&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;          <span class="keywordflow">if</span> (!origin_z.first)</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;            <a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> &lt;&lt; <span class="stringliteral">&quot;  determined z-coordinate&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;          <a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> &lt;&lt; <span class="stringliteral">&quot;  coordinates: &quot;</span>;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;          origin.write_unformatted(<a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a>);</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;          <a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> &lt;&lt; std::endl;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        }</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    }</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (be_verbose)</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    {</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;      <a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> &lt;&lt; <span class="stringliteral">&quot; Origin for Infinite Elements:&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;      <a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> &lt;&lt; <span class="stringliteral">&quot;  coordinates: &quot;</span>;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;      origin.write_unformatted(<a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a>);</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;      <a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> &lt;&lt; std::endl;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    }</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  <span class="comment">// Now that we have the origin, check if the user provided an \p</span></div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;  <span class="comment">// inner_boundary_nodes.  If so, we pass a std::set to the actual</span></div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;  <span class="comment">// implementation of the build_inf_elem(), so that we can convert</span></div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;  <span class="comment">// this to the Node * vector</span></div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;  <span class="keywordflow">if</span> (inner_boundary_nodes != <a class="code" href="libmesh__nullptr_8h.html#ad10985637963b309cf2bf815e508438d">libmesh_nullptr</a>)</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    {</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;      <span class="comment">// note that the std::set that we will get</span></div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;      <span class="comment">// from build_inf_elem() uses the index of</span></div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;      <span class="comment">// the element in this-&gt;_elements vector,</span></div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;      <span class="comment">// and the second entry is the side index</span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;      <span class="comment">// for this element.  Therefore, we do _not_</span></div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;      <span class="comment">// need to renumber nodes and elements</span></div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;      <span class="comment">// prior to building the infinite elements.</span></div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;      <span class="comment">//</span></div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;      <span class="comment">// However, note that this method here uses</span></div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;      <span class="comment">// node id&#39;s... Do we need to renumber?</span></div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;      <span class="comment">// Form the list of faces of elements which finally</span></div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;      <span class="comment">// will tell us which nodes should receive boundary</span></div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;      <span class="comment">// conditions (to form the std::vector&lt;const Node *&gt;)</span></div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;      std::set&lt; std::pair&lt;<a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a>,</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;                          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&gt; &gt; inner_faces;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;      <span class="comment">// build infinite elements</span></div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;      this-&gt;<a class="code" href="classlibMesh_1_1InfElemBuilder.html#ac6bf21d86621176b3497f089bef8a17a">build_inf_elem</a>(origin,</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                           x_sym, y_sym, z_sym,</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;                           be_verbose,</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                           &amp;inner_faces);</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;      <span class="keywordflow">if</span> (be_verbose)</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        {</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;          this-&gt;<a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a94180309af3081c9da2a0064e66040e6">print_info</a>();</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;          <a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> &lt;&lt; <span class="stringliteral">&quot;Data pre-processing:&quot;</span> &lt;&lt; std::endl</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;                       &lt;&lt; <span class="stringliteral">&quot; convert the &lt;int,int&gt; list to a Node * list...&quot;</span></div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                       &lt;&lt; std::endl;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;        }</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;      <span class="comment">// First use a std::vector&lt;dof_id_type&gt; that holds</span></div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;      <span class="comment">// the global node numbers.  Then sort this vector,</span></div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;      <span class="comment">// so that it can be made unique (no multiple occurence</span></div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;      <span class="comment">// of a node), and then finally insert the Node * in</span></div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;      <span class="comment">// the vector inner_boundary_nodes.</span></div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;      <span class="comment">//</span></div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;      <span class="comment">// Reserve memory for the vector&lt;&gt; with</span></div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;      <span class="comment">// 4 times the size of the number of elements in the</span></div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;      <span class="comment">// std::set. This is a good bet for Quad4 face elements.</span></div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;      <span class="comment">// For higher-order elements, this probably _has_ to lead</span></div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;      <span class="comment">// to additional allocations...</span></div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;      <span class="comment">// Practice has to show how this affects performance.</span></div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;      std::vector&lt;dof_id_type&gt; inner_boundary_node_numbers;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;      inner_boundary_node_numbers.reserve(4*inner_faces.size());</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;      <span class="comment">// Now transform the set of pairs to a list of (possibly</span></div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;      <span class="comment">// duplicate) global node numbers.</span></div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;      std::set&lt; std::pair&lt;dof_id_type,unsigned int&gt; &gt;::iterator face_it = inner_faces.begin();</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;      <span class="keyword">const</span> std::set&lt; std::pair&lt;dof_id_type,unsigned int&gt; &gt;::iterator face_end = inner_faces.end();</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;      <span class="keywordflow">for</span>(; face_it!=face_end; ++face_it)</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        {</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;          std::pair&lt;dof_id_type,unsigned int&gt; p = *face_it;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;          <span class="comment">// build a full-ordered side element to get _all_ the base nodes</span></div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;          UniquePtr&lt;Elem&gt; <a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>(this-&gt;<a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a42b7a9f2869772ac1a7d072f45a8378d">elem_ref</a>(p.first).<a class="code" href="classlibMesh_1_1Elem.html#ab0a351f621dd01e540718ffc25bb2618">build_side_ptr</a>(p.second));</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;          <span class="comment">// insert all the node numbers in inner_boundary_node_numbers</span></div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n=0; n&lt; <a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>-&gt;n_nodes(); n++)</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;            inner_boundary_node_numbers.push_back(<a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>-&gt;node_id(n));</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;        }</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;      <span class="comment">// inner_boundary_node_numbers now still holds multiple entries of</span></div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;      <span class="comment">// node numbers.  So first sort, then unique the vector.</span></div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;      <span class="comment">// Note that \p std::unique only puts the new ones in</span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;      <span class="comment">// front, while to leftovers are @e not deleted.  Instead,</span></div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;      <span class="comment">// it returns a pointer to the end of the unique range.</span></div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;      <span class="comment">//TODO:[BSK] int_ibn_size_before is not the same type as unique_size!</span></div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;<span class="preprocessor">#ifndef NDEBUG</span></div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;      <span class="keyword">const</span> std::size_t ibn_size_before = inner_boundary_node_numbers.size();</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;      std::sort (inner_boundary_node_numbers.begin(), inner_boundary_node_numbers.end());</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;      std::vector&lt;dof_id_type&gt;::iterator unique_end =</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;        std::unique (inner_boundary_node_numbers.begin(), inner_boundary_node_numbers.end());</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;      std::size_t unique_size = std::distance(inner_boundary_node_numbers.begin(), unique_end);</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;      libmesh_assert_less_equal (unique_size, ibn_size_before);</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;      <span class="comment">// Finally, create const Node * in the inner_boundary_nodes</span></div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;      <span class="comment">// vector.  Reserve, not resize (otherwise, the push_back</span></div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;      <span class="comment">// would append the interesting nodes, while NULL-nodes</span></div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;      <span class="comment">// live in the resize&#39;d area...</span></div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;      inner_boundary_nodes-&gt;reserve (unique_size);</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;      inner_boundary_nodes-&gt;clear();</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;      std::vector&lt;dof_id_type&gt;::iterator pos_it = inner_boundary_node_numbers.begin();</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;      <span class="keywordflow">for</span> (; pos_it != unique_end; ++pos_it)</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        {</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;          <span class="keyword">const</span> Node * node = this-&gt;<a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#ac83917705d802d1c29b9dbf050f73ed4">node_ptr</a>(*pos_it);</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;          inner_boundary_nodes-&gt;push_back(node);</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;        }</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;      <span class="keywordflow">if</span> (be_verbose)</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        <a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> &lt;&lt; <span class="stringliteral">&quot;  finished identifying &quot;</span> &lt;&lt; unique_size</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;                     &lt;&lt; <span class="stringliteral">&quot; target nodes.&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    }</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;  <span class="keywordflow">else</span></div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;    {</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;      <span class="comment">// There are no inner boundary nodes, so simply build the infinite elements</span></div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;      this-&gt;<a class="code" href="classlibMesh_1_1InfElemBuilder.html#ac6bf21d86621176b3497f089bef8a17a">build_inf_elem</a>(origin, x_sym, y_sym, z_sym, be_verbose);</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;    }</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;  STOP_LOG(<span class="stringliteral">&quot;build_inf_elem()&quot;</span>, <span class="stringliteral">&quot;InfElemBuilder&quot;</span>);</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;  <span class="comment">// when finished with building the Ifems,</span></div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;  <span class="comment">// it remains to prepare the mesh for use:</span></div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;  <span class="comment">// find neighbors again, partition (if needed)...</span></div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a61ce1c1cdddaa68acd35c7fa49a8a45e">prepare_for_use</a> (<span class="comment">/*skip_renumber =*/</span> <span class="keyword">false</span>);</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;  <span class="keywordflow">return</span> origin;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;}</div><div class="ttc" id="classlibMesh_1_1Elem_html_ab0a351f621dd01e540718ffc25bb2618"><div class="ttname"><a href="classlibMesh_1_1Elem.html#ab0a351f621dd01e540718ffc25bb2618">libMesh::Elem::build_side_ptr</a></div><div class="ttdeci">virtual UniquePtr&lt; Elem &gt; build_side_ptr(const unsigned int i, bool proxy=true)=0</div></div>
<div class="ttc" id="xdr__io_8C_html_a538c9c249908c84b07be8ce1400b82c9"><div class="ttname"><a href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a></div><div class="ttdeci">unsigned short int side</div><div class="ttdef"><b>Definition:</b> <a href="xdr__io_8C_source.html#l00049">xdr_io.C:49</a></div></div>
<div class="ttc" id="libmesh__nullptr_8h_html_ad10985637963b309cf2bf815e508438d"><div class="ttname"><a href="libmesh__nullptr_8h.html#ad10985637963b309cf2bf815e508438d">libmesh_nullptr</a></div><div class="ttdeci">const class libmesh_nullptr_t libmesh_nullptr</div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_ac83917705d802d1c29b9dbf050f73ed4"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#ac83917705d802d1c29b9dbf050f73ed4">libMesh::MeshBase::node_ptr</a></div><div class="ttdeci">virtual const Node * node_ptr(const dof_id_type i) const  =0</div></div>
<div class="ttc" id="namespacelibMesh_1_1MeshTools_html_ab099ca10b8e0521017c6d28644b88135"><div class="ttname"><a href="namespacelibMesh_1_1MeshTools.html#ab099ca10b8e0521017c6d28644b88135">libMesh::MeshTools::bounding_box</a></div><div class="ttdeci">BoundingBox bounding_box(const MeshBase &amp;mesh)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__tools_8C_source.html#l00358">mesh_tools.C:358</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a61ce1c1cdddaa68acd35c7fa49a8a45e"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a61ce1c1cdddaa68acd35c7fa49a8a45e">libMesh::MeshBase::prepare_for_use</a></div><div class="ttdeci">void prepare_for_use(const bool skip_renumber_nodes_and_elements=false, const bool skip_find_neighbors=false)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8C_source.html#l00174">mesh_base.C:174</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a42b7a9f2869772ac1a7d072f45a8378d"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a42b7a9f2869772ac1a7d072f45a8378d">libMesh::MeshBase::elem_ref</a></div><div class="ttdeci">virtual const Elem &amp; elem_ref(const dof_id_type i) const </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l00453">mesh_base.h:453</a></div></div>
<div class="ttc" id="classlibMesh_1_1InfElemBuilder_html_ac6bf21d86621176b3497f089bef8a17a"><div class="ttname"><a href="classlibMesh_1_1InfElemBuilder.html#ac6bf21d86621176b3497f089bef8a17a">libMesh::InfElemBuilder::build_inf_elem</a></div><div class="ttdeci">const Point build_inf_elem(const bool be_verbose=false)</div><div class="ttdef"><b>Definition:</b> <a href="inf__elem__builder_8C_source.html#l00040">inf_elem_builder.C:40</a></div></div>
<div class="ttc" id="classlibMesh_1_1InfElemBuilder_html_afbdff790a0e4a9a08c06e178a4d585f5"><div class="ttname"><a href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">libMesh::InfElemBuilder::_mesh</a></div><div class="ttdeci">MeshBase &amp; _mesh</div><div class="ttdef"><b>Definition:</b> <a href="inf__elem__builder_8h_source.html#l00127">inf_elem_builder.h:127</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a63e3c3158308e2184c12b55ab9ea9a35"><div class="ttname"><a href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a></div><div class="ttdeci">OStreamProxy out(std::cout)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00241">libmesh_common.h:241</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a94180309af3081c9da2a0064e66040e6"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a94180309af3081c9da2a0064e66040e6">libMesh::MeshBase::print_info</a></div><div class="ttdeci">void print_info(std::ostream &amp;os=libMesh::out) const </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8C_source.html#l00446">mesh_base.C:446</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00064">id_types.h:64</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abfe5b4ac765578c4b9e0850f7c269647"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::InfElemBuilder::build_inf_elem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>x_sym</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>y_sym</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>z_sym</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>be_verbose</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::pair&lt; <a class="el" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a>, unsigned int &gt; &gt; *&#160;</td>
          <td class="paramname"><em>inner_faces</em> = <code><a class="el" href="libmesh__nullptr_8h.html#ad10985637963b309cf2bf815e508438d">libmesh_nullptr</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Build infinite elements atop a volume-based mesh. Actual implementation. </p>

<p>Definition at line <a class="el" href="inf__elem__builder_8C_source.html#l00277">277</a> of file <a class="el" href="inf__elem__builder_8C_source.html">inf_elem_builder.C</a>.</p>

<p>References <a class="el" href="inf__elem__builder_8h_source.html#l00127">_mesh</a>, <a class="el" href="libmesh__augment__std__namespace_8h_source.html#l00059">std::abs()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#aefa4ded9eaf654a45ab593a0963ecbf3">libMesh::MeshBase::active_elements_begin()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#ae3f09f1b7556aef88919249861728e23">libMesh::MeshBase::active_elements_end()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a5ab834283fa6bc335ad623d2b737ec5e">libMesh::MeshBase::add_elem()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a9361e2879e37831f80afb43b762d651f">libMesh::MeshBase::add_point()</a>, <a class="el" href="classlibMesh_1_1Elem.html#ab0a351f621dd01e540718ffc25bb2618">libMesh::Elem::build_side_ptr()</a>, <a class="el" href="enum__elem__type_8h_source.html#l00030">libMesh::EDGE2</a>, <a class="el" href="enum__elem__type_8h_source.html#l00031">libMesh::EDGE3</a>, <a class="el" href="mesh__base_8h_source.html#l00453">libMesh::MeshBase::elem_ref()</a>, <a class="el" href="variant__filter__iterator_8h_source.html#l00334">end</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a7edb2ad9b032287e750880883cdcf0f3">libMesh::MeshBase::find_neighbors()</a>, <a class="el" href="dof__object_8h_source.html#l00624">libMesh::DofObject::id()</a>, <a class="el" href="mesh__base_8h_source.html#l00134">libMesh::MeshBase::is_serial()</a>, <a class="el" href="mesh__base_8h_source.html#l00916">libMesh::MeshBase::libmesh_assert_valid_parallel_ids()</a>, <a class="el" href="libmesh__nullptr_8h.html#ad10985637963b309cf2bf815e508438d">libmesh_nullptr</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a24ae8994de4fa6b54d042f79c0ce6621">libMesh::MeshBase::max_elem_id()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a3a3c70f6cd2f7811d555e21db397451c">libMesh::MeshBase::max_node_id()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a5bc6bf3c535104fb6586a51039f9eac3">libMesh::MeshBase::n_elem()</a>, <a class="el" href="elem_8h_source.html#l00530">libMesh::Elem::n_neighbors()</a>, <a class="el" href="classlibMesh_1_1Elem.html#afea917f088ff1f2bb66f36288b2f78f9">libMesh::Elem::n_vertices()</a>, <a class="el" href="elem_8h_source.html#l01769">libMesh::Elem::neighbor()</a>, <a class="el" href="mesh__base_8h_source.html#l00385">libMesh::MeshBase::node_ref()</a>, <a class="el" href="type__vector_8h_source.html#l00887">libMesh::TypeVector&lt; T &gt;::norm()</a>, <a class="el" href="libmesh__common_8h_source.html#l00241">libMesh::out</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#afdc9b7d80fa3fa447def161a78fc1e6e">libMesh::MeshBase::point()</a>, <a class="el" href="dof__object_8h_source.html#l00686">libMesh::DofObject::processor_id()</a>, <a class="el" href="enum__elem__type_8h_source.html#l00037">libMesh::QUAD4</a>, <a class="el" href="enum__elem__type_8h_source.html#l00038">libMesh::QUAD8</a>, <a class="el" href="enum__elem__type_8h_source.html#l00039">libMesh::QUAD9</a>, <a class="el" href="libmesh__common_8h_source.html#l00131">libMesh::Real</a>, <a class="el" href="dof__object_8h_source.html#l00633">libMesh::DofObject::set_id()</a>, <a class="el" href="elem_8h_source.html#l01723">libMesh::Elem::set_node()</a>, <a class="el" href="xdr__io_8C_source.html#l00049">side</a>, <a class="el" href="enum__elem__type_8h_source.html#l00034">libMesh::TRI3</a>, and <a class="el" href="enum__elem__type_8h_source.html#l00035">libMesh::TRI6</a>.</p>
<div class="fragment"><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;{</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;  <span class="keywordflow">if</span> (be_verbose)</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    {</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;      <a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> &lt;&lt; <span class="stringliteral">&quot; Building Infinite Elements:&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;      <a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> &lt;&lt; <span class="stringliteral">&quot;  updating element neighbor tables...&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;      <a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> &lt;&lt; <span class="stringliteral">&quot; Verbose mode disabled in non-debug mode.&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    }</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;  <span class="comment">// update element neighbors</span></div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a7edb2ad9b032287e750880883cdcf0f3">find_neighbors</a>();</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;  LOG_SCOPE(<span class="stringliteral">&quot;build_inf_elem()&quot;</span>, <span class="stringliteral">&quot;InfElemBuilder&quot;</span>);</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;  <span class="comment">// A set for storing element number, side number pairs.</span></div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;  <span class="comment">// pair.first == element number, pair.second == side number</span></div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;  std::set&lt; std::pair&lt;dof_id_type,unsigned int&gt; &gt; faces;</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;  std::set&lt; std::pair&lt;dof_id_type,unsigned int&gt; &gt; ofaces;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;  <span class="comment">// A set for storing node numbers on the outer faces.</span></div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;  std::set&lt;dof_id_type&gt; onodes;</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;  <span class="comment">// The distance to the farthest point in the mesh from the origin</span></div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;  <a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> max_r=0.;</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;  <span class="comment">// The index of the farthest point in the mesh from the origin</span></div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;  <span class="keywordtype">int</span> max_r_node = -1;</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;  <span class="keywordflow">if</span> (be_verbose)</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    {</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;      <a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> &lt;&lt; <span class="stringliteral">&quot;  collecting boundary sides&quot;</span>;</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;      <span class="keywordflow">if</span> (x_sym || y_sym || z_sym)</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;        <a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> &lt;&lt; <span class="stringliteral">&quot;, skipping sides in symmetry planes...&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;        <a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> &lt;&lt; <span class="stringliteral">&quot;...&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    }</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;  <span class="comment">// Iterate through all elements and sides, collect indices of all active</span></div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;  <span class="comment">// boundary sides in the faces set. Skip sides which lie in symmetry planes.</span></div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;  <span class="comment">// Later, sides of the inner boundary will be sorted out.</span></div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;  {</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    MeshBase::element_iterator       it  = this-&gt;<a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#aefa4ded9eaf654a45ab593a0963ecbf3">active_elements_begin</a>();</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    <span class="keyword">const</span> MeshBase::element_iterator <a class="code" href="variant__filter__iterator_8h.html#a785f0bd261d7bd1918b031c5133da2b9">end</a> = this-&gt;<a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#ae3f09f1b7556aef88919249861728e23">active_elements_end</a>();</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    <span class="keywordflow">for</span>(; it != <a class="code" href="variant__filter__iterator_8h.html#a785f0bd261d7bd1918b031c5133da2b9">end</a>; ++it)</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;      {</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;        Elem * elem = *it;</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> s=0; s&lt;elem-&gt;n_neighbors(); s++)</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;          {</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;            <span class="comment">// check if element e is on the boundary</span></div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;            <span class="keywordflow">if</span> (elem-&gt;neighbor(s) == <a class="code" href="libmesh__nullptr_8h.html#ad10985637963b309cf2bf815e508438d">libmesh_nullptr</a>)</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;              {</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;                <span class="comment">// note that it is safe to use the Elem::side() method,</span></div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;                <span class="comment">// which gives a non-full-ordered element</span></div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;                UniquePtr&lt;Elem&gt; <a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>(elem-&gt;build_side_ptr(s));</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;                <span class="comment">// bool flags for symmetry detection</span></div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;                <span class="keywordtype">bool</span> sym_side=<span class="keyword">false</span>;</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;                <span class="keywordtype">bool</span> on_x_sym=<span class="keyword">true</span>;</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;                <span class="keywordtype">bool</span> on_y_sym=<span class="keyword">true</span>;</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;                <span class="keywordtype">bool</span> on_z_sym=<span class="keyword">true</span>;</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;                <span class="comment">// Loop over the nodes to check whether they are on the symmetry planes,</span></div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;                <span class="comment">// and therefore sufficient to use a non-full-ordered side element</span></div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;                <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n=0; n&lt;<a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>-&gt;n_nodes(); n++)</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;                  {</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;                    <span class="keyword">const</span> Point dist_from_origin =</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;                      this-&gt;<a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#afdc9b7d80fa3fa447def161a78fc1e6e">point</a>(<a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>-&gt;node_id(n)) - origin;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;                    <span class="keywordflow">if</span>(x_sym)</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;                      <span class="keywordflow">if</span>( <a class="code" href="namespacestd.html#a267975f6c8fdf9f989e14d438036706a">std::abs</a>(dist_from_origin(0)) &gt; 1.e-3 )</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;                        on_x_sym=<span class="keyword">false</span>;</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;                    <span class="keywordflow">if</span>(y_sym)</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;                      <span class="keywordflow">if</span>( <a class="code" href="namespacestd.html#a267975f6c8fdf9f989e14d438036706a">std::abs</a>(dist_from_origin(1)) &gt; 1.e-3 )</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;                        on_y_sym=<span class="keyword">false</span>;</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;                    <span class="keywordflow">if</span>(z_sym)</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;                      <span class="keywordflow">if</span>( <a class="code" href="namespacestd.html#a267975f6c8fdf9f989e14d438036706a">std::abs</a>(dist_from_origin(2)) &gt; 1.e-3 )</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;                        on_z_sym=<span class="keyword">false</span>;</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;                    <span class="comment">//       if(x_sym)</span></div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;                    <span class="comment">// if( std::abs(dist_from_origin(0)) &gt; 1.e-6 )</span></div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;                    <span class="comment">//   on_x_sym=false;</span></div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;                    <span class="comment">//       if(y_sym)</span></div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;                    <span class="comment">// if( std::abs(dist_from_origin(1)) &gt; 1.e-6 )</span></div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;                    <span class="comment">//   on_y_sym=false;</span></div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;                    <span class="comment">//       if(z_sym)</span></div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;                    <span class="comment">// if( std::abs(dist_from_origin(2)) &gt; 1.e-6 )</span></div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;                    <span class="comment">//   on_z_sym=false;</span></div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;                    <span class="comment">//find the node most distant from origin</span></div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;                    <a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> r = dist_from_origin.norm();</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;                    <span class="keywordflow">if</span> (r &gt; max_r)</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;                      {</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;                        max_r = r;</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;                        max_r_node=<a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>-&gt;node_id(n);</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;                      }</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;                  }</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;                sym_side = (x_sym &amp;&amp; on_x_sym) || (y_sym &amp;&amp; on_y_sym) || (z_sym &amp;&amp; on_z_sym);</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;                <span class="keywordflow">if</span> (!sym_side)</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;                  faces.insert( std::make_pair(elem-&gt;id(), s) );</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;              } <span class="comment">// neighbor(s) == libmesh_nullptr</span></div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;          } <span class="comment">// sides</span></div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;      } <span class="comment">// elems</span></div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;  }</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;  <span class="comment">//  If a boundary side has one node on the outer boundary,</span></div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;  <span class="comment">//  all points of this side are on the outer boundary.</span></div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;  <span class="comment">//  Start with the node most distant from origin, which has</span></div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;  <span class="comment">//  to be on the outer boundary, then recursively find all</span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;  <span class="comment">//  sides and nodes connected to it. Found sides are moved</span></div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;  <span class="comment">//  from faces to ofaces, nodes are collected in onodes.</span></div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;  <span class="comment">//  Here, the search is done iteratively, because, depending on</span></div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;  <span class="comment">//  the mesh, a very high level of recursion might be necessary.</span></div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;  <span class="keywordflow">if</span> (max_r_node &gt;= 0)</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;    <span class="comment">// include the possibility of the 1st element being most far away.</span></div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    <span class="comment">// Only the case of no outer boundary is to be excluded.</span></div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;    onodes.insert(max_r_node);</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;  {</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;    std::set&lt; std::pair&lt;dof_id_type,unsigned int&gt; &gt;::iterator face_it = faces.begin();</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> facesfound=0;</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    <span class="keywordflow">while</span> (face_it != faces.end()) {</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;      std::pair&lt;dof_id_type, unsigned int&gt; p;</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;      p = *face_it;</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;      <span class="comment">// This has to be a full-ordered side element,</span></div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;      <span class="comment">// since we need the correct n_nodes,</span></div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;      UniquePtr&lt;Elem&gt; <a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>(this-&gt;<a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a42b7a9f2869772ac1a7d072f45a8378d">elem_ref</a>(p.first).<a class="code" href="classlibMesh_1_1Elem.html#ab0a351f621dd01e540718ffc25bb2618">build_side_ptr</a>(p.second));</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;      <span class="keywordtype">bool</span> found=<span class="keyword">false</span>;</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;      <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sn=0; sn&lt;<a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>-&gt;n_nodes(); sn++)</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;        <span class="keywordflow">if</span>(onodes.count(<a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>-&gt;node_id(sn)))</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;          {</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;            found=<span class="keyword">true</span>;</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;          }</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;      <span class="comment">// If a new oface is found, include its nodes in onodes</span></div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;      <span class="keywordflow">if</span>(found)</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;        {</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;          <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sn=0; sn&lt;<a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>-&gt;n_nodes(); sn++)</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;            onodes.insert(<a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>-&gt;node_id(sn));</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;          ofaces.insert(p);</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;          ++face_it; <span class="comment">// iteration is done here</span></div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;          faces.erase(p);</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;          facesfound++;</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;        }</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;        ++face_it; <span class="comment">// iteration is done here</span></div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;      <span class="comment">// If at least one new oface was found in this cycle,</span></div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;      <span class="comment">// do another search cycle.</span></div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;      <span class="keywordflow">if</span>(facesfound&gt;0 &amp;&amp; face_it == faces.end())</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;        {</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;          facesfound = 0;</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;          face_it    = faces.begin();</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;        }</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;    }</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;  }</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;  <span class="keywordflow">if</span> (be_verbose)</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    <a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> &lt;&lt; <span class="stringliteral">&quot;  found &quot;</span></div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;                 &lt;&lt; faces.size()</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;                 &lt;&lt; <span class="stringliteral">&quot; inner and &quot;</span></div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;                 &lt;&lt; ofaces.size()</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;                 &lt;&lt; <span class="stringliteral">&quot; outer boundary faces&quot;</span></div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;                 &lt;&lt; std::endl;</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;  <span class="comment">// When the user provided a non-null pointer to</span></div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;  <span class="comment">// inner_faces, that implies he wants to have</span></div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;  <span class="comment">// this std::set.  For now, simply copy the data.</span></div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;  <span class="keywordflow">if</span> (inner_faces != <a class="code" href="libmesh__nullptr_8h.html#ad10985637963b309cf2bf815e508438d">libmesh_nullptr</a>)</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    *inner_faces = faces;</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;  <span class="comment">// free memory, clear our local variable, no need</span></div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;  <span class="comment">// for it any more.</span></div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;  faces.clear();</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;  <span class="comment">// outer_nodes maps onodes to their duplicates</span></div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;  std::map&lt;dof_id_type, Node *&gt; outer_nodes;</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;  <span class="comment">// We may need to pick our own object ids in parallel</span></div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;  <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> old_max_node_id = <a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a3a3c70f6cd2f7811d555e21db397451c">max_node_id</a>();</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;  <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> old_max_elem_id = <a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a24ae8994de4fa6b54d042f79c0ce6621">max_elem_id</a>();</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;  <span class="comment">// for each boundary node, add an outer_node with</span></div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;  <span class="comment">// double distance from origin.</span></div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;  std::set&lt;dof_id_type&gt;::iterator on_it = onodes.begin();</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;  <span class="keywordflow">for</span>( ; on_it != onodes.end(); ++on_it)</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;    {</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;      Point p = (Point(this-&gt;<a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#afdc9b7d80fa3fa447def161a78fc1e6e">point</a>(*on_it)) * 2) - origin;</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a3c7d22fed3feea4c9ebd1fb41e7dbb4f">is_serial</a>())</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;        {</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;          <span class="comment">// Add with a default id in serial</span></div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;          outer_nodes[*on_it]=this-&gt;<a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a9361e2879e37831f80afb43b762d651f">add_point</a>(p);</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;        }</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;        {</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;          <span class="comment">// Pick a unique id in parallel</span></div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;          Node &amp; bnode = <a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#af6e7cea860ccee9625012f9fcb0ae13b">node_ref</a>(*on_it);</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;          <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> new_id = bnode.id() + old_max_node_id;</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;          outer_nodes[*on_it] =</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;            this-&gt;<a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a9361e2879e37831f80afb43b762d651f">add_point</a>(p, new_id,</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;                                  bnode.processor_id());</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;        }</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;    }</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;  <span class="comment">// for verbose, remember n_elem</span></div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;  <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> n_conventional_elem = this-&gt;<a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a5bc6bf3c535104fb6586a51039f9eac3">n_elem</a>();</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;  <span class="comment">// build Elems based on boundary side type</span></div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;  std::set&lt; std::pair&lt;dof_id_type,unsigned int&gt; &gt;::iterator face_it = ofaces.begin();</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;  <span class="keywordflow">for</span>( ; face_it != ofaces.end(); ++face_it)</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;    {</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;      <span class="comment">// Shortcut to the pair being iterated over</span></div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;      std::pair&lt;dof_id_type,unsigned int&gt; p = *face_it;</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;      <span class="comment">// build a full-ordered side element to get the base nodes</span></div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;      UniquePtr&lt;Elem&gt; <a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>(this-&gt;<a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a42b7a9f2869772ac1a7d072f45a8378d">elem_ref</a>(p.first).<a class="code" href="classlibMesh_1_1Elem.html#ab0a351f621dd01e540718ffc25bb2618">build_side_ptr</a>(p.second));</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;      <span class="comment">// create cell depending on side type, assign nodes,</span></div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;      <span class="comment">// use braces to force scope.</span></div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;      <span class="keywordtype">bool</span> is_higher_order_elem = <span class="keyword">false</span>;</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;      Elem * el;</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;      <span class="keywordflow">switch</span>(<a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>-&gt;type())</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;        {</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;          <span class="comment">// 3D infinite elements</span></div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;          <span class="comment">// TRIs</span></div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;        <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a16d066cfcd1a19aa971a530807e0deb2acccb9e40eddc1b28768f2128fe1a8f08">TRI3</a>:</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;          el=<span class="keyword">new</span> InfPrism6;</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;          <span class="keywordflow">break</span>;</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;        <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a16d066cfcd1a19aa971a530807e0deb2aad2d0656d7cf0f061899c655560c1e55">TRI6</a>:</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;          el=<span class="keyword">new</span> InfPrism12;</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;          is_higher_order_elem = <span class="keyword">true</span>;</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;          <span class="keywordflow">break</span>;</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;          <span class="comment">// QUADs</span></div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;        <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a16d066cfcd1a19aa971a530807e0deb2af4b68709f9e0a488822d3399de3508b1">QUAD4</a>:</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;          el=<span class="keyword">new</span> InfHex8;</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;          <span class="keywordflow">break</span>;</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;        <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a16d066cfcd1a19aa971a530807e0deb2a850fa5218d8f69ab09f5bccaf40b615a">QUAD8</a>:</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;          el=<span class="keyword">new</span> InfHex16;</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;          is_higher_order_elem = <span class="keyword">true</span>;</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;          <span class="keywordflow">break</span>;</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;        <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a16d066cfcd1a19aa971a530807e0deb2a2d7bef790b667ca2769e52ce6de8b9fd">QUAD9</a>:</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;          el=<span class="keyword">new</span> InfHex18;</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;          <span class="comment">// the method of assigning nodes (which follows below)</span></div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;          <span class="comment">// omits in the case of QUAD9 the bubble node; therefore</span></div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;          <span class="comment">// we assign these first by hand here.</span></div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;          el-&gt;set_node(16) = <a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>-&gt;node_ptr(8);</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;          el-&gt;set_node(17) = outer_nodes[<a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>-&gt;node_id(8)];</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;          is_higher_order_elem=<span class="keyword">true</span>;</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;          <span class="keywordflow">break</span>;</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;          <span class="comment">// 2D infinite elements</span></div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;        <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a16d066cfcd1a19aa971a530807e0deb2aa656f2b4aa8cff7ff974765c83a76820">EDGE2</a>:</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;          el=<span class="keyword">new</span> InfQuad4;</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;          <span class="keywordflow">break</span>;</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;        <span class="keywordflow">case</span> <a class="code" href="namespacelibMesh.html#a16d066cfcd1a19aa971a530807e0deb2a3251dc5224670944ad87d1b9ab397c59">EDGE3</a>:</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;          el=<span class="keyword">new</span> InfQuad6;</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;          el-&gt;set_node(4) = <a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>-&gt;node_ptr(2);</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;          <span class="keywordflow">break</span>;</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;          <span class="comment">// 1D infinite elements not supported</span></div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;          <a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> &lt;&lt; <span class="stringliteral">&quot;InfElemBuilder::build_inf_elem(Point, bool, bool, bool, bool): &quot;</span></div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;                       &lt;&lt; <span class="stringliteral">&quot;invalid face element &quot;</span></div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;                       &lt;&lt; std::endl;</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;          <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;        }</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;      <span class="comment">// In parallel, assign unique ids to the new element</span></div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;      <span class="keywordflow">if</span> (!<a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a3c7d22fed3feea4c9ebd1fb41e7dbb4f">is_serial</a>())</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;        {</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;          Elem &amp; belem = <a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a42b7a9f2869772ac1a7d072f45a8378d">elem_ref</a>(p.first);</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;          el-&gt;<a class="code" href="classlibMesh_1_1DofObject.html#a0e8748b2c01f78902c9c432ad79cf546">processor_id</a>() = belem.processor_id();</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;          <span class="comment">// We&#39;d better not have elements with more than 6 sides</span></div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;          el-&gt;set_id (belem.id() * 6 + p.second + old_max_elem_id);</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;        }</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;      <span class="comment">// assign vertices to the new infinite element</span></div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_base_vertices = <a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>-&gt;n_vertices();</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;      <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_base_vertices; i++)</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;        {</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;          el-&gt;set_node(i                ) = <a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>-&gt;node_ptr(i);</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;          el-&gt;set_node(i+n_base_vertices) = outer_nodes[<a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>-&gt;node_id(i)];</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;        }</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;      <span class="comment">// when this is a higher order element,</span></div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;      <span class="comment">// assign also the nodes in between</span></div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;      <span class="keywordflow">if</span> (is_higher_order_elem)</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;        {</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;          <span class="comment">// n_safe_base_nodes is the number of nodes in \p side</span></div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;          <span class="comment">// that may be safely assigned using below for loop.</span></div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;          <span class="comment">// Actually, n_safe_base_nodes is _identical_ with el-&gt;n_vertices(),</span></div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;          <span class="comment">// since for QUAD9, the 9th node was already assigned above</span></div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_safe_base_nodes   = el-&gt;n_vertices();</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;          <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=n_base_vertices; i&lt;n_safe_base_nodes; i++)</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;            {</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;              el-&gt;set_node(i+n_base_vertices)   = <a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>-&gt;node_ptr(i);</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;              el-&gt;set_node(i+n_safe_base_nodes) =</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;                outer_nodes[<a class="code" href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a>-&gt;node_id(i)];</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;            }</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;        }</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;      <span class="comment">// add infinite element to mesh</span></div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;      this-&gt;<a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a5ab834283fa6bc335ad623d2b737ec5e">add_elem</a>(el);</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;    } <span class="comment">// for</span></div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;  <a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#adda5cd6af09b7fcc88a890a71a07c1a8">libmesh_assert_valid_parallel_ids</a>();</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;  <span class="keywordflow">if</span> (be_verbose)</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;    <a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> &lt;&lt; <span class="stringliteral">&quot;  added &quot;</span></div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;                 &lt;&lt; this-&gt;<a class="code" href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">_mesh</a>.<a class="code" href="classlibMesh_1_1MeshBase.html#a5bc6bf3c535104fb6586a51039f9eac3">n_elem</a>() - n_conventional_elem</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;                 &lt;&lt; <span class="stringliteral">&quot; infinite elements and &quot;</span></div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;                 &lt;&lt; onodes.size()</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;                 &lt;&lt; <span class="stringliteral">&quot; nodes to the mesh&quot;</span></div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;                 &lt;&lt; std::endl</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;                 &lt;&lt; std::endl;</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;}</div><div class="ttc" id="namespacestd_html_a267975f6c8fdf9f989e14d438036706a"><div class="ttname"><a href="namespacestd.html#a267975f6c8fdf9f989e14d438036706a">std::abs</a></div><div class="ttdeci">double abs(double a)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__augment__std__namespace_8h_source.html#l00059">libmesh_augment_std_namespace.h:59</a></div></div>
<div class="ttc" id="classlibMesh_1_1Elem_html_ab0a351f621dd01e540718ffc25bb2618"><div class="ttname"><a href="classlibMesh_1_1Elem.html#ab0a351f621dd01e540718ffc25bb2618">libMesh::Elem::build_side_ptr</a></div><div class="ttdeci">virtual UniquePtr&lt; Elem &gt; build_side_ptr(const unsigned int i, bool proxy=true)=0</div></div>
<div class="ttc" id="namespacelibMesh_html_a16d066cfcd1a19aa971a530807e0deb2aad2d0656d7cf0f061899c655560c1e55"><div class="ttname"><a href="namespacelibMesh.html#a16d066cfcd1a19aa971a530807e0deb2aad2d0656d7cf0f061899c655560c1e55">libMesh::TRI6</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00035">enum_elem_type.h:35</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_adda5cd6af09b7fcc88a890a71a07c1a8"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#adda5cd6af09b7fcc88a890a71a07c1a8">libMesh::MeshBase::libmesh_assert_valid_parallel_ids</a></div><div class="ttdeci">virtual void libmesh_assert_valid_parallel_ids() const </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l00916">mesh_base.h:916</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a3c7d22fed3feea4c9ebd1fb41e7dbb4f"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a3c7d22fed3feea4c9ebd1fb41e7dbb4f">libMesh::MeshBase::is_serial</a></div><div class="ttdeci">virtual bool is_serial() const </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l00134">mesh_base.h:134</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_afdc9b7d80fa3fa447def161a78fc1e6e"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#afdc9b7d80fa3fa447def161a78fc1e6e">libMesh::MeshBase::point</a></div><div class="ttdeci">virtual const Point &amp; point(const dof_id_type i) const  =0</div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_af6e7cea860ccee9625012f9fcb0ae13b"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#af6e7cea860ccee9625012f9fcb0ae13b">libMesh::MeshBase::node_ref</a></div><div class="ttdeci">virtual const Node &amp; node_ref(const dof_id_type i) const </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l00385">mesh_base.h:385</a></div></div>
<div class="ttc" id="xdr__io_8C_html_a538c9c249908c84b07be8ce1400b82c9"><div class="ttname"><a href="xdr__io_8C.html#a538c9c249908c84b07be8ce1400b82c9">side</a></div><div class="ttdeci">unsigned short int side</div><div class="ttdef"><b>Definition:</b> <a href="xdr__io_8C_source.html#l00049">xdr_io.C:49</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a3a3c70f6cd2f7811d555e21db397451c"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a3a3c70f6cd2f7811d555e21db397451c">libMesh::MeshBase::max_node_id</a></div><div class="ttdeci">virtual dof_id_type max_node_id() const  =0</div></div>
<div class="ttc" id="libmesh__nullptr_8h_html_ad10985637963b309cf2bf815e508438d"><div class="ttname"><a href="libmesh__nullptr_8h.html#ad10985637963b309cf2bf815e508438d">libmesh_nullptr</a></div><div class="ttdeci">const class libmesh_nullptr_t libmesh_nullptr</div></div>
<div class="ttc" id="namespacelibMesh_html_a16d066cfcd1a19aa971a530807e0deb2a3251dc5224670944ad87d1b9ab397c59"><div class="ttname"><a href="namespacelibMesh.html#a16d066cfcd1a19aa971a530807e0deb2a3251dc5224670944ad87d1b9ab397c59">libMesh::EDGE3</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00031">enum_elem_type.h:31</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a16d066cfcd1a19aa971a530807e0deb2af4b68709f9e0a488822d3399de3508b1"><div class="ttname"><a href="namespacelibMesh.html#a16d066cfcd1a19aa971a530807e0deb2af4b68709f9e0a488822d3399de3508b1">libMesh::QUAD4</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00037">enum_elem_type.h:37</a></div></div>
<div class="ttc" id="variant__filter__iterator_8h_html_a785f0bd261d7bd1918b031c5133da2b9"><div class="ttname"><a href="variant__filter__iterator_8h.html#a785f0bd261d7bd1918b031c5133da2b9">end</a></div><div class="ttdeci">IterBase * end</div><div class="ttdef"><b>Definition:</b> <a href="variant__filter__iterator_8h_source.html#l00334">variant_filter_iterator.h:334</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a9361e2879e37831f80afb43b762d651f"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a9361e2879e37831f80afb43b762d651f">libMesh::MeshBase::add_point</a></div><div class="ttdeci">virtual Node * add_point(const Point &amp;p, const dof_id_type id=DofObject::invalid_id, const processor_id_type proc_id=DofObject::invalid_processor_id)=0</div></div>
<div class="ttc" id="namespacelibMesh_html_a16d066cfcd1a19aa971a530807e0deb2acccb9e40eddc1b28768f2128fe1a8f08"><div class="ttname"><a href="namespacelibMesh.html#a16d066cfcd1a19aa971a530807e0deb2acccb9e40eddc1b28768f2128fe1a8f08">libMesh::TRI3</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00034">enum_elem_type.h:34</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a24ae8994de4fa6b54d042f79c0ce6621"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a24ae8994de4fa6b54d042f79c0ce6621">libMesh::MeshBase::max_elem_id</a></div><div class="ttdeci">virtual dof_id_type max_elem_id() const  =0</div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a7edb2ad9b032287e750880883cdcf0f3"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a7edb2ad9b032287e750880883cdcf0f3">libMesh::MeshBase::find_neighbors</a></div><div class="ttdeci">virtual void find_neighbors(const bool reset_remote_elements=false, const bool reset_current_list=true)=0</div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a5ab834283fa6bc335ad623d2b737ec5e"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a5ab834283fa6bc335ad623d2b737ec5e">libMesh::MeshBase::add_elem</a></div><div class="ttdeci">virtual Elem * add_elem(Elem *e)=0</div></div>
<div class="ttc" id="namespacelibMesh_html_a16d066cfcd1a19aa971a530807e0deb2aa656f2b4aa8cff7ff974765c83a76820"><div class="ttname"><a href="namespacelibMesh.html#a16d066cfcd1a19aa971a530807e0deb2aa656f2b4aa8cff7ff974765c83a76820">libMesh::EDGE2</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00030">enum_elem_type.h:30</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_aefa4ded9eaf654a45ab593a0963ecbf3"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#aefa4ded9eaf654a45ab593a0963ecbf3">libMesh::MeshBase::active_elements_begin</a></div><div class="ttdeci">virtual element_iterator active_elements_begin()=0</div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_ae3f09f1b7556aef88919249861728e23"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#ae3f09f1b7556aef88919249861728e23">libMesh::MeshBase::active_elements_end</a></div><div class="ttdeci">virtual element_iterator active_elements_end()=0</div></div>
<div class="ttc" id="namespacelibMesh_html_a16d066cfcd1a19aa971a530807e0deb2a850fa5218d8f69ab09f5bccaf40b615a"><div class="ttname"><a href="namespacelibMesh.html#a16d066cfcd1a19aa971a530807e0deb2a850fa5218d8f69ab09f5bccaf40b615a">libMesh::QUAD8</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00038">enum_elem_type.h:38</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a42b7a9f2869772ac1a7d072f45a8378d"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a42b7a9f2869772ac1a7d072f45a8378d">libMesh::MeshBase::elem_ref</a></div><div class="ttdeci">virtual const Elem &amp; elem_ref(const dof_id_type i) const </div><div class="ttdef"><b>Definition:</b> <a href="mesh__base_8h_source.html#l00453">mesh_base.h:453</a></div></div>
<div class="ttc" id="namespacelibMesh_html_aef28359fb4851abec08fc99cfbac118d"><div class="ttname"><a href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">libMesh::Real</a></div><div class="ttdeci">DIE A HORRIBLE DEATH HERE typedef LIBMESH_DEFAULT_SCALAR_TYPE Real</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00131">libmesh_common.h:131</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a16d066cfcd1a19aa971a530807e0deb2a2d7bef790b667ca2769e52ce6de8b9fd"><div class="ttname"><a href="namespacelibMesh.html#a16d066cfcd1a19aa971a530807e0deb2a2d7bef790b667ca2769e52ce6de8b9fd">libMesh::QUAD9</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__elem__type_8h_source.html#l00039">enum_elem_type.h:39</a></div></div>
<div class="ttc" id="classlibMesh_1_1MeshBase_html_a5bc6bf3c535104fb6586a51039f9eac3"><div class="ttname"><a href="classlibMesh_1_1MeshBase.html#a5bc6bf3c535104fb6586a51039f9eac3">libMesh::MeshBase::n_elem</a></div><div class="ttdeci">virtual dof_id_type n_elem() const  =0</div></div>
<div class="ttc" id="classlibMesh_1_1InfElemBuilder_html_afbdff790a0e4a9a08c06e178a4d585f5"><div class="ttname"><a href="classlibMesh_1_1InfElemBuilder.html#afbdff790a0e4a9a08c06e178a4d585f5">libMesh::InfElemBuilder::_mesh</a></div><div class="ttdeci">MeshBase &amp; _mesh</div><div class="ttdef"><b>Definition:</b> <a href="inf__elem__builder_8h_source.html#l00127">inf_elem_builder.h:127</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a63e3c3158308e2184c12b55ab9ea9a35"><div class="ttname"><a href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a></div><div class="ttdeci">OStreamProxy out(std::cout)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00241">libmesh_common.h:241</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00064">id_types.h:64</a></div></div>
<div class="ttc" id="classlibMesh_1_1DofObject_html_a0e8748b2c01f78902c9c432ad79cf546"><div class="ttname"><a href="classlibMesh_1_1DofObject.html#a0e8748b2c01f78902c9c432ad79cf546">libMesh::DofObject::processor_id</a></div><div class="ttdeci">processor_id_type processor_id() const </div><div class="ttdef"><b>Definition:</b> <a href="dof__object_8h_source.html#l00686">dof_object.h:686</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="afbdff790a0e4a9a08c06e178a4d585f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1MeshBase.html">MeshBase</a>&amp; libMesh::InfElemBuilder::_mesh</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reference to the mesh we're building infinite elements for. </p>

<p>Definition at line <a class="el" href="inf__elem__builder_8h_source.html#l00127">127</a> of file <a class="el" href="inf__elem__builder_8h_source.html">inf_elem_builder.h</a>.</p>

<p>Referenced by <a class="el" href="inf__elem__builder_8C_source.html#l00040">build_inf_elem()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="inf__elem__builder_8h_source.html">inf_elem_builder.h</a></li>
<li><a class="el" href="inf__elem__builder_8C_source.html">inf_elem_builder.C</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
generated by <a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a>
</small></address>
<!-- dynamic header stuff -->
<script type="text/javascript">
$(document).ready(function(){
  $(window).on('scroll',function() {
    var scrolltop = $(this).scrollTop();
    if(scrolltop >= 215) {
      $('#fixedbar').fadeIn(250);
    }
    else if(scrolltop <= 210) {
      $('#fixedbar').fadeOut(250);
    }
  });
});
</script>
<!-- Google Analytics stuff -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-24978333-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
